{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note The (open) AEA framework provides the necessary tools for creating Autonomous Economic Agents (AEA). It is a fork of the legacy AEA framework that gives no priority to any package vendor. What are Autonomous Economic Agents (AEAs)? We define an AEA as: An intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value for its owner. The AEA framework offers the owner, either an individual, an organisation, or another application, the ability to outsource the pursuit of their economic interests. Such interests may include maximizing the acquisition of items from a desired basket of goods, adaptive management of market exposure, or minimization of transaction costs within an application to benefit its users. In order to be able to act on an owner's behalf AEAs need to be endowed with a sense of agency, which requires the ability to enact behaviour and exercise control over its consequences in a way that is commensurate with its owners' goals. The ability to autonomously interact with their environment and proactively engage in peer-to-peer dialogue is a distinctive feature of AEAs. Where otherwise the execution of skills and decision-making logic are left as an exercise to the reader, AEAs allow developers to design systems that pursue economic interests without the requirement of an owner to actively partake or continuously intervene in the process. Information on areas and applications of AEAs and examples of their implementation are provided to illustrate their use. What is the AEA Framework? The AEA development suite, implemented in Python, equips the developer with an easily accessible set of tools for building AEAs. The framework is modular, composable and extensible. Its purpose is to make agent development as straightforward as web development became with the introduction of Django and Flask. A modular design of components facilitates their reuse as parts of other applications that might serve an entirely different set of needs. The framework provided offers the user: A peer-to-peer agent communication network (ACN) allows your AEAs to interact with all other AEAs over the public internet. The framework's crypto and ledger APIs make it possible for AEAs to interact with blockchains such as Ethereum , and use these as a financial settlement and commitment layer. A registry that enables code sharing and re-use by providing a space in which AEAs or their individual components may be shared. The contract packages enable AEAs to interact with smart contracts on various decentralised ledgers. Next steps To get started developing your own AEA, check out the getting started section. If you want to run a demo, check out the demo guides . To learn more about the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . Help us improve Note This developer documentation is a work in progress. If you spot any errors please open an issue on Github or contact us in the developer Discord channel .","title":"Introduction"},{"location":"#what-are-autonomous-economic-agents-aeas","text":"We define an AEA as: An intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value for its owner. The AEA framework offers the owner, either an individual, an organisation, or another application, the ability to outsource the pursuit of their economic interests. Such interests may include maximizing the acquisition of items from a desired basket of goods, adaptive management of market exposure, or minimization of transaction costs within an application to benefit its users. In order to be able to act on an owner's behalf AEAs need to be endowed with a sense of agency, which requires the ability to enact behaviour and exercise control over its consequences in a way that is commensurate with its owners' goals. The ability to autonomously interact with their environment and proactively engage in peer-to-peer dialogue is a distinctive feature of AEAs. Where otherwise the execution of skills and decision-making logic are left as an exercise to the reader, AEAs allow developers to design systems that pursue economic interests without the requirement of an owner to actively partake or continuously intervene in the process. Information on areas and applications of AEAs and examples of their implementation are provided to illustrate their use.","title":"What are Autonomous Economic Agents (AEAs)?"},{"location":"#what-is-the-aea-framework","text":"The AEA development suite, implemented in Python, equips the developer with an easily accessible set of tools for building AEAs. The framework is modular, composable and extensible. Its purpose is to make agent development as straightforward as web development became with the introduction of Django and Flask. A modular design of components facilitates their reuse as parts of other applications that might serve an entirely different set of needs. The framework provided offers the user: A peer-to-peer agent communication network (ACN) allows your AEAs to interact with all other AEAs over the public internet. The framework's crypto and ledger APIs make it possible for AEAs to interact with blockchains such as Ethereum , and use these as a financial settlement and commitment layer. A registry that enables code sharing and re-use by providing a space in which AEAs or their individual components may be shared. The contract packages enable AEAs to interact with smart contracts on various decentralised ledgers.","title":"What is the AEA Framework?"},{"location":"#next-steps","text":"To get started developing your own AEA, check out the getting started section. If you want to run a demo, check out the demo guides . To learn more about the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development .","title":"Next steps"},{"location":"#help-us-improve","text":"Note This developer documentation is a work in progress. If you spot any errors please open an issue on Github or contact us in the developer Discord channel .","title":"Help us improve"},{"location":"12-factor/","text":"Relationship with the Twelve-Factor App methodology. The Twelve-Factor App is a set of best practices to build modern web applications, or software-as-a-service . In this section, we will see how the AEA framework facilitates the achievement of those in the development, release and deployment phases of an AEA project. Note that an AEA instance, as a software agent, can be seen as a more general case of a web app, as it not only shows reactive behaviour, but it is also proactive , depending on the goals assigned to it. Codebase One codebase tracked in revision control, many deploys Support: Excellent The framework does not impose any particular requirement or convention on the type of version control software to be used to store an AEA project. Dependencies Explicitly declare and isolate dependencies Support: Good The framework allows an AEA project to explicitly declare the AEA package dependencies, and the PyPI dependencies needed to proper working. However, it does not provide built-in support for checking platform-specific dependencies, e.g. specific Python version, or needed system-wide available libraries. Nevertheless, this can be indirectly achieved by means of build scripts called on aea build , which can do the checks manually according to the specific requirements of the project. Configuration Store configuration in the environment Support: Good An AEA project can specify an environment configuration file .env , stored in the project root, that the framework will use to update environment variables before the execution of the AEA instance. The CLI tool command aea run accepts the option --env PATH to change the default configuration file. However, the framework does not automatically switch between, nor allows to add, different types of configuration files, one for each deployment step (e.g. development, staging, production), without using the --env option. Backing services Treat backing services as attached resources Support: Good A persistent storage of an AEA can be seen as an attached resource in the 12-factor terminology. The default storage is SQLite, but the interface AbstractStorageBacked allows to implement specific wrappers to other backing services, without changing the AEA project code. The support for integrating different storage back-end implementations in an AEA project by using a plug-in mechanism is currently missing. Moreover, new adapters to backing services can be implemented as custom connections, which can connect to attached resources. This does not usually requires a change in the skill code, especially in the case when a custom protocol can abstract the details of the interaction with the specific resource. Build, release, run Strictly separate build and run stages Support: Excellent The phases of build, release and run of an AEA project are neatly separated, both for programmatic usage and through the usage of the CLI tool, as each of them corresponds to different subcommands. Processes Execute the app as one or more stateless processes Support: Excellent Whether the process is stateless depends on the specific AEA. No strict enforcement is applied by the framework. Moreover, dialogue histories can be stored with persistent storage, if enabled by the developer. Port binding Export services via port binding Support: Excellent An AEA project may not need to expose services via HTTP. This property depends on the specific choices of the project developer, and the framework does not impose any restriction. One of the provided package, the \"HTTP server\" connection, relies on aiohttp , which makes the connection completely self-contained\u2014therefore, it satisfies the requirement. Another relevant example is the ACN node, which exposes its service to the Libp2p AEA connection Concurrency Scale out via the process model Support: Not Supported The framework does not easily allow to scale up an AEA instance with multiple processes, as it is bound to a process. However, note that its attached services can live in a different process, which could give better scalability. Disposability Maximize robustness with fast startup and graceful shutdown Support: Good Disposability of an AEA instance depends, in general, on the AEA itself; whether the connections can be quickly connected and disconnected, whether skills can be easily torn down or not, whether other resources can be detached successfully like the persistent storage, just to name a few examples. There has been put some effort into reducing startup time, and to ensure that a graceful shut down can happen when the process receives a SIGTERM under normal circumstances, but robustness cannot be ensured for individual components, as it depends on their implementation. Additionally, the framework does provide some features to control some aspects of AEA disposability, e.g. the possibility to change execution timeout for behaviours or handlers, implementation of an effective exception propagation from a component code to the main agent loop. Dev/prod parity Keep development, staging, and production as similar as possible Support: Good This aspect mostly depends on the specific AEA project, and the framework does not impose particular restrictions on best deployment practices (e.g. continuous integration, same backing services between development and production stages). Logs Treat logs as event streams Support: Excellent Thanks to the seamless integration with the Python standard library logging , the developer or the deployer has great control on the routing and filtering of log records. The behaviour can be changed by providing a proper configuration in the AEA project configuration file, according to the standard library specification. The framework facilitates this by creating ad-hoc logger names that can be used for finer-grained routing or filtering; for example, each AEA instance uses its own logging namespace to send logging events. Integration with other log handlers is delegated to extensions of the standard library, hence not necessarily coupled with the AEA framework. Admin processes Run admin/management tasks as one-off processes Support: Good The CLI tool provides commands to manage private keys and ledger related operations, and it is possible to extend it with a plugin to manage databases of AEA's persistent storage for maintenance operations. Moreover, the Python programming language makes it easy to run one-off scripts or running a console (also known as REPL) to do management tasks. It follows that it is also easy to ensure dependency isolation and same configurations of the running AEA instance.","title":"12-Factor app and AEAs"},{"location":"12-factor/#relationship-with-the-twelve-factor-app-methodology","text":"The Twelve-Factor App is a set of best practices to build modern web applications, or software-as-a-service . In this section, we will see how the AEA framework facilitates the achievement of those in the development, release and deployment phases of an AEA project. Note that an AEA instance, as a software agent, can be seen as a more general case of a web app, as it not only shows reactive behaviour, but it is also proactive , depending on the goals assigned to it.","title":"Relationship with the Twelve-Factor App methodology."},{"location":"12-factor/#codebase","text":"One codebase tracked in revision control, many deploys Support: Excellent The framework does not impose any particular requirement or convention on the type of version control software to be used to store an AEA project.","title":"Codebase"},{"location":"12-factor/#dependencies","text":"Explicitly declare and isolate dependencies Support: Good The framework allows an AEA project to explicitly declare the AEA package dependencies, and the PyPI dependencies needed to proper working. However, it does not provide built-in support for checking platform-specific dependencies, e.g. specific Python version, or needed system-wide available libraries. Nevertheless, this can be indirectly achieved by means of build scripts called on aea build , which can do the checks manually according to the specific requirements of the project.","title":"Dependencies"},{"location":"12-factor/#configuration","text":"Store configuration in the environment Support: Good An AEA project can specify an environment configuration file .env , stored in the project root, that the framework will use to update environment variables before the execution of the AEA instance. The CLI tool command aea run accepts the option --env PATH to change the default configuration file. However, the framework does not automatically switch between, nor allows to add, different types of configuration files, one for each deployment step (e.g. development, staging, production), without using the --env option.","title":"Configuration"},{"location":"12-factor/#backing-services","text":"Treat backing services as attached resources Support: Good A persistent storage of an AEA can be seen as an attached resource in the 12-factor terminology. The default storage is SQLite, but the interface AbstractStorageBacked allows to implement specific wrappers to other backing services, without changing the AEA project code. The support for integrating different storage back-end implementations in an AEA project by using a plug-in mechanism is currently missing. Moreover, new adapters to backing services can be implemented as custom connections, which can connect to attached resources. This does not usually requires a change in the skill code, especially in the case when a custom protocol can abstract the details of the interaction with the specific resource.","title":"Backing services"},{"location":"12-factor/#build-release-run","text":"Strictly separate build and run stages Support: Excellent The phases of build, release and run of an AEA project are neatly separated, both for programmatic usage and through the usage of the CLI tool, as each of them corresponds to different subcommands.","title":"Build, release, run"},{"location":"12-factor/#processes","text":"Execute the app as one or more stateless processes Support: Excellent Whether the process is stateless depends on the specific AEA. No strict enforcement is applied by the framework. Moreover, dialogue histories can be stored with persistent storage, if enabled by the developer.","title":"Processes"},{"location":"12-factor/#port-binding","text":"Export services via port binding Support: Excellent An AEA project may not need to expose services via HTTP. This property depends on the specific choices of the project developer, and the framework does not impose any restriction. One of the provided package, the \"HTTP server\" connection, relies on aiohttp , which makes the connection completely self-contained\u2014therefore, it satisfies the requirement. Another relevant example is the ACN node, which exposes its service to the Libp2p AEA connection","title":"Port binding"},{"location":"12-factor/#concurrency","text":"Scale out via the process model Support: Not Supported The framework does not easily allow to scale up an AEA instance with multiple processes, as it is bound to a process. However, note that its attached services can live in a different process, which could give better scalability.","title":"Concurrency"},{"location":"12-factor/#disposability","text":"Maximize robustness with fast startup and graceful shutdown Support: Good Disposability of an AEA instance depends, in general, on the AEA itself; whether the connections can be quickly connected and disconnected, whether skills can be easily torn down or not, whether other resources can be detached successfully like the persistent storage, just to name a few examples. There has been put some effort into reducing startup time, and to ensure that a graceful shut down can happen when the process receives a SIGTERM under normal circumstances, but robustness cannot be ensured for individual components, as it depends on their implementation. Additionally, the framework does provide some features to control some aspects of AEA disposability, e.g. the possibility to change execution timeout for behaviours or handlers, implementation of an effective exception propagation from a component code to the main agent loop.","title":"Disposability"},{"location":"12-factor/#devprod-parity","text":"Keep development, staging, and production as similar as possible Support: Good This aspect mostly depends on the specific AEA project, and the framework does not impose particular restrictions on best deployment practices (e.g. continuous integration, same backing services between development and production stages).","title":"Dev/prod parity"},{"location":"12-factor/#logs","text":"Treat logs as event streams Support: Excellent Thanks to the seamless integration with the Python standard library logging , the developer or the deployer has great control on the routing and filtering of log records. The behaviour can be changed by providing a proper configuration in the AEA project configuration file, according to the standard library specification. The framework facilitates this by creating ad-hoc logger names that can be used for finer-grained routing or filtering; for example, each AEA instance uses its own logging namespace to send logging events. Integration with other log handlers is delegated to extensions of the standard library, hence not necessarily coupled with the AEA framework.","title":"Logs"},{"location":"12-factor/#admin-processes","text":"Run admin/management tasks as one-off processes Support: Good The CLI tool provides commands to manage private keys and ledger related operations, and it is possible to extend it with a plugin to manage databases of AEA's persistent storage for maintenance operations. Moreover, the Python programming language makes it easy to run one-off scripts or running a console (also known as REPL) to do management tasks. It follows that it is also easy to ensure dependency isolation and same configurations of the running AEA instance.","title":"Admin processes"},{"location":"acn-internals/","text":"The aim of this document is to describe at a high-level the main implementation of the Agent Communication Network (ACN). In particular: The open-acn Golang library; At the moment a copy resides locally in open-aea here as libp2p_node . The valory/p2p_libp2p AEA connection, written in Python, that implements the direct connection with an ACN peer; The valory/p2p_libp2p_client AEA connection, written in Python, which implements the delegate connection with an ACN peer. It is assumed the reader already knows what is the ACN and its purposes; if not, we suggest reading this page . This documentation page is structured as follows: Firstly, the ACN protocol is described: all the messages and data structures involved, as well as some example of interaction protocol with these messages; Then, it is explained how a peer can join an existing ACN network, and the message exchange involved; It follows the description of the journey of an envelope in the ACN network: from the agent connection to its contact peer, between ACN peers, and then from the contact peer of the destination agent to the target agent; The following section describes the functionalities of the AEA connections that allow to communicate through the ACN: valory/p2p_libp2p and valory/p2p_libp2p_client ; The documentation ends with a section of known issues and limitations of the current implementation. Messages and Data Structures At the foundation of the ACN there is the ACN protocol . The protocol messages and the reply structure are generated from this protocol specification , using the protocol generator . Therefore, it uses Protocol Buffers as a serialization format, and the definition of the data structures involved is defined in this .proto file . To know more about the protocol generator, refer to the relevant section of the documentation: Protocol Generator . Agent Record An agent record is a data structure containing information about an agent and its Proof-of-Representation (PoR) to be used by a peer for other peers. This data structure is used as a payload in other ACN messages (see below). The AgentRecord data structure contains the following fields: service_id : a string describing the service identifier. ledger_id : a string. It is the identifier of the ledger this agent record is associated to. Currently, the allowed values are: fetchai , the identifier for the Fetch.AI ledger; ethereum , the identifier for the Ethereum ledger; cosmos , the identifier for the Cosmos ledger; address : a string. It is the public key of a public-private key pair. It is used as an identifier for routing purposes. public_key : a string. The representative's public key. Used in case of (PoR). peer_public_key : a string. The public key of the peer. signature : a string. The signature for PoR. not_before : a string. Specify the lower bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0 not_after : a string. Specify the upper bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0. ACN Message Entities in the ACN (i.e. either agents or peers) exchange ACN messages . An ACN message contains a payload field, which is the actual content of the message. There are different types of payloads: Status Register LookupRequest LookupResponse AeaEnvelope Status The Status payload is used as a response message to inform the sender about the handling of certain requests. The payload contains: the status_code , a positive integer among the ones in the Protobuf file . a list of error messages (string). A status code 0 , identified as SUCCESS , means that the request has been processed successfully. Status codes greater than 0 can be: Generic errors: errors that occur under generic circumstances. ERROR_UNSUPPORTED_VERSION , with integer value 1 : the receiver of the message does not support the protocol version of the sender; ERROR_UNEXPECTED_PAYLOAD , with integer value 2 : the payload could not be deserialised on the receiver side; ERROR_GENERIC , with integer value 3 : an internal error; ERROR_SERIALIZATION , with integer value 4 : a serialization error occurred on the receiving end; Register errors: errors that occur during agent registration operations in the ACN. ERROR_WRONG_AGENT_ADDRESS , with integer value 10 : the PoR by a peer from another peer does not match the destination address of the envelope to be routed by the receiving peer. ERROR_WRONG_PUBLIC_KEY , with integer value 11 : the representative peer public key does not match the one in the agent record; ERROR_INVALID_PROOF , with integer value 12 : the signature is invalid; ERROR_UNSUPPORTED_LEDGER , with integer value 13 : the ledger of the PoR is not supported by the peer; Lookup and delivery errors: errors that occur during lookup to the DHT and envelope delivery operations in the ACN. ERROR_UNKNOWN_AGENT_ADDRESS , with integer value 20 : the requested agent address has not been found in the local DHT of the peer; ERROR_AGENT_NOT_READY , with integer value 21 : the agent is not ready for envelope delivery. Register The Register payload is used to request a peer to register an agent among his known ones. The payload contains the field record , which is an instance of AgentRecord . LookupRequest The LookupRequest payload is sent between peer to look-up addresses in the Distributed Hash Table (DHT). It contains the agent address (a string) that the sender needs to correctly route an envelope. LookupResponse The LookupResponse payload is the response sent by a peer that received a LookupRequest . It contains the AgentRecord associated to the requested address. AeaEnvelope The AeaEnvelope payload contains the envelope sent by an agent and to be delivered to another agent. It contains: envelope : the envelope to be forwarded, in byte representation; an AgentRecord (see above). ACN Protocol Interactions The ACN protocol specifies three different possible interactions: the registration interaction the look-up interaction the routing interaction \"Registration\" Interaction The registration interaction is used by delegate agents or relayed peers to register themselves to another peer. sequenceDiagram participant Agent/RelayedPeer participant Peer Agent/RelayedPeer->>Peer: Register(AgentRecord) alt success note over Peer: check PoR Peer->>Agent/RelayedPeer: Status(SUCCESS) else wrong agent address Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_AGENT_ADDRESS) else wrong public key Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_PUBLIC_KEY) else invalid proof of representation Peer->>Agent/RelayedPeer: Status(ERROR_INVALID_PROOF) else unsupported ledger Peer->>Agent/RelayedPeer: Status(ERROR_UNSUPPORTED_LEDGER) end \"Look-up\" Interaction The look-up interaction is used by a peer to request information to another peer about an agent address. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest(address) alt success Peer2->>Peer1: LookupResponse(AgentRecord) else unknown agent address Peer2->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end \"Routing\" Interaction The routing interaction is used by agents and peers to route the envelope through the ACN. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: AeaEnvelope(envelope, AgentRecord) alt success note over Peer2: check PoR Peer2->>Peer1: Status(SUCCESS) else error on decoding of Envelope payload Peer2->>Peer1: Status(ERROR_SERIALIZATION) else PoR errors note over Peer1,Peer2: see above end Joining the ACN network When an ACN peer wants to join the network, it has to start from a list of bootstrap peers , i.e. a list of ACN peers to connect with (at least one). Each node handles four different types of libp2p streams : the notification stream , identified by the URI /aea-notif/ : this stream is used by new peers to notify their existence to the address stream , identified by the URI /aea-address/ : used to send look-up requests and look-up responses; the envelope stream , identified by the URI /aea/ : used to forward and to receive ACN envelopes; the register relay stream , identified by the URI /aea-register/ : this is to receive messages from clients that want to register their agents addresses; this peer, and then it can register their addresses. To begin with, the node process initializes the transport connections with the bootstrap peers, the local copy of the Kademlia Distributed Hash Table (DHT), the persistent storage for agent records, and performs other non-functional operations like setting up the Prometheus monitoring system . Optionally, can also start listening for relay connections and delegate connections. Then, it sets up the notification stream and notifies the bootstrap peers (if any). sequenceDiagram participant Peer1 participant Peer2 participant Peer3 note over Peer1: notify bootstrap peers Peer1->>Peer2: notify Peer2->>Peer2: wait until notifying peer added to DHT activate Peer2 Peer1->>Peer3: notify Peer3->>Peer3: wait until notifying peer added to DHT activate Peer3 note over Peer2,Peer3: Peer1 registered to DHT deactivate Peer2 deactivate Peer3 loop for each local/relay/delegate address Peer1->>Peer1: compute CID from address Peer1->>Peer2: register address Peer1->>Peer3: register address end note over Peer1: set up: - address stream - envelope stream - register relay stream Relay connections If the ACN node is configured to run the relay service, it sets up the register relay stream, waiting for registration requests. The following diagram shows an example of the message exchanged during a registration request: sequenceDiagram participant Agent participant Peer Agent->>Peer: Register alt decoding error of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else wrong payload Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer->>Agent: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer->>Agent: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Peer->>Agent: Status(SUCCESS) note over Peer: announce agent address to other peers end Delegate connections If the ACN node is configured to run the delegate service, it starts listening from a TCP socket at a configurable URI. To see a diagram of the message exchanged during a registration request read this section . ACN transport In the following sections, we describe the main three steps of the routing of an envelope through the ACN: ACN entrance : when an envelope sent by an agent enters the peer-to-peer network via the peer the agent is connected to i.e. agent-to-peer communication; ACN routing : when an envelope gets routed through the peer-to-peer network, i.e. peer-to-peer communication; ACN exit : when an envelope gets delivered to the receiving agent through its representative peer, i.e. peer-to-agent communication. ACN Envelope Entrance: Agent -> Peer In this section, we will describe the interaction protocols between agents and peers for the messages sent by the agent to the ACN network; in particular, the communication from the contact peer of an agent to the agent. The following diagram explains the exchange of messages on entering an envelope in the ACN. In the case of direct connection , Agent is a Python process, whereas Peer is in a separate (Golang) process. The logic of the Python Agent client is implemented in the valory/p2p_libp2p connection. The communication between Agent and Peer is done through an OS pipe for Inter-Process Communication (IPC) between the AEAs process and the libp2p node process; then, the message gets enqueued to an output queue by an input coroutine. Finally, the envelope ends up in an output queue, which is processed by an output coroutine and routed to the next peer. In the case of delegate connection , the message exchange is very similar; however, instead of using pipes, the communication is done through the network, i.e. TCP, with a peer which has the delegate service enabled. The logic of the Agent client connected with a delegate connection is implemented in the open-aea valory/p2p_libp2p_client connection. sequenceDiagram participant Agent participant Peer loop until Status(success) received Agent->>Peer: AeaEnvelope Agent->>Agent: wait note left of Agent: Wait until Status(success) alt successful case Peer->>Agent: Status(success) note over Agent: break loop else ack-timeout OR conn-error note left of Agent: continue: Try to resend/reconnect else version not supported Peer->>Agent: Status(ERROR_UNSUPPORTED_VERSION) else error on decoding of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else error on decoding of Envelope payload Peer->>Agent: Status(ERROR_SERIALIZATION) else the payload cannot be handled Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) end end note over Peer: route envelope to next peer ACN Envelope Routing In this section, we describe the interaction between peers when it comes to envelope routing. Assume an envelope arrives from an agent to peer Peer1 , i.e. Peer1 is the first hop of the routing. Let Agent be the local agent directly connected to Peer1 , Peer2 a direct peer of peer Peer1 . When the envelope is leaving Peer1 , we may have different scenario: 1) In case of direct connection, and the field sender of the envelope is not the local agent address: the message is considered invalid, and it is dropped. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt envelope sender not registered locally note over Peer1: stop, log error end 2) the target of the envelope is the local agent connected to the peer: the envelope is routed to the local agent. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt target == peer1.my_agent note over Peer1: envelope designated to local agent, not routing loop agent not ready note over Peer1: sleep for 100ms end Peer1->>Agent: AeaEnvelope Agent->>Peer1: Status(Success) end 3) the target is a delegate client. Send the envelope via TCP. sequenceDiagram participant Delegate participant Peer1 participant Peer2 Delegate->>Peer1: AeaEnvelope alt destination is a delegate note over Peer1: send envelope to delegate via TCP Peer1->>Delegate: AeaEnvelope Delegate->>Peer1: Status(Success) end 4) Otherwise, look up the local DHT. If an entry is found, use it; otherwise, send a look-up request to connected peers. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt address found in DHT note over Peer1: destination is a relay client else lookup address in DHT note over Peer1: send lookup request to all peers Peer1->>Peer2: LookupRequest alt generic error Peer2->>Peer1: Status(GENERIC_ERROR) else look-up response Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end note over Peer1,Peer2: Now Peer1 knows the contact peer is PeerX In particular, when a peer receives a LookupRequest message, it does the following: sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest alt error Peer2->>Peer1: Status(Error) else local agent/relay/delegate note over Peer2: requested address is a local agent OR requested address is in my relay clients OR requested address is in my delegate clients Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found locally note over Peer2: send lookup request to other peers... alt found Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end Let Peer3 the contact peer of the recipient of the envelope. The following diagram shows how the contact peer of the envelope recipient handles the incoming envelope: sequenceDiagram participant Peer1 participant Peer3 Peer1->>Peer3: AeaEnvelope alt decoding error of ACN message Peer3->>Peer1: Status(ERROR_SERIALIZATION) else unexpected payload Peer3->>Peer1: Status(ERROR_UNEXPECTED_PAYLOAD) else decoding error of envelope payload Peer3->>Peer1: Status(ERROR_SERIALIZATION) else PoR check fails alt wrong agent address Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer3->>Peer1: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer3->>Peer1: Status(ERROR_INVALID_PROOF) end else PoR check succeeds alt target is delegate, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else exists delegate, ready note over Peer3: forward envelope via delegate connection Peer3->>Peer1: Status(SUCCESS) else target is local agent, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else target is local agent, ready note over Peer3: forward envelope via direct connection Peer3->>Peer1: Status(SUCCESS) else agent does not exist Peer3->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end end ACN Envelope Exit: Peer -> Agent The following diagram explains the exchange of messages on exiting an envelope in the ACN. That is, the communication from the contact peer of an agent to the agent. The same message exchange is done both in the case of direct connection and delegate connection, similarly for what has been described for the envelope entrance (see above) . sequenceDiagram participant Agent participant Peer Peer->>Agent: AeaEnvelope alt successful case Agent->>Peer: Status(success) else ack-timeout OR conn-error note left of Peer: do nothing else error on decoding of ACN message Agent->>Peer: Status(GENERIC_ERROR) else error on decoding of Envelope payload Agent->>Peer: Status(GENERIC_ERROR) else wrong payload Agent->>Peer: Status(GENERIC_ERROR) end Connect your AEA to the ACN To connect the AEA to the ACN network, there are two AEA connections available: the valory/p2p_libp2p , that implements a direct connection, and the valory/p2p_libp2p_client connection, that implements the delegate connection. For more information on the AEA connection package type, refer to this guide . The valory/p2p_libp2p connection The source code of the valory/p2p_libp2p connection can be downloaded here . The package provides the connection class P2PLibp2pConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection spawns a new instance of the libp2p_node program (i.e. an ACN peer node) and connects to it through OS pipes. Then, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Connection participant sending loop participant receiving loop participant Libp2p Node Libp2p Connection->>Libp2p Node: spawn process activate Libp2p Node Libp2p Connection->>sending loop: start recv loop sending loop->>sending loop: wait messages from output queue activate sending loop Libp2p Connection->>receiving loop: start send loop receiving loop->>receiving loop: wait messages from input queue activate receiving loop deactivate Libp2p Node deactivate sending loop deactivate receiving loop The send method enqueues a message in the output queue. The message is then dequeued by the sending loop, and then sent to the Libp2p node. sequenceDiagram participant Libp2p Connection participant sending loop participant Libp2p Node activate sending loop Libp2p Connection->>Libp2p Connection: enqueue message to output queue sending loop->>sending loop: dequeue message from output queue deactivate sending loop sending loop->>Libp2p Node: AeaEnvelope sending loop->>sending loop: wait for status activate sending loop alt success note over Libp2p Node: route envelope Libp2p Node->>sending loop: Status(SUCCESS) deactivate sending loop note over sending loop: OK else timed out note over sending loop: raise with error else acn message decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) else unexpected payload Libp2p Node->>sending loop: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) end The receive method dequeues a message from the input queue. The queue is populated by the receiving loop, which receives messages from the Libp2p node. sequenceDiagram participant Libp2p Connection participant receiving loop participant Libp2p Node activate receiving loop Libp2p Node->>receiving loop: AeaEnvelope deactivate receiving loop Libp2p Node->>Libp2p Node: wait for status activate Libp2p Node alt success note over receiving loop: enqueue envelope to input queue receiving loop->>Libp2p Node: Status(SUCCESS) deactivate Libp2p Node note over receiving loop: OK else timed out note over Libp2p Node: ignore else acn message decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) else unexpected payload receiving loop->>Libp2p Node: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) end Libp2p Connection->>receiving loop: read message from output queue note over Libp2p Connection: return message to Multiplexer the disconnect method stops both the receiving loop and the sending loop, and stops the Libp2p node. The valory/p2p_libp2p_client connection The source code of the valory/p2p_libp2p_client connection can be downloaded here . The package provides the connection class P2PLibp2pClientConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection will set up a TCP connection to the URI of the delegate peer. Then, it will send a Register request to register the agent among the peer's client connections. On registration success, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Client Connection participant Libp2p Node activate Libp2p Node Libp2p Node->>Libp2p Node: listening for TCP connections Libp2p Client Connection->>Libp2p Node: Register (via TCP) deactivate Libp2p Node alt decoding error of ACN message Libp2p Node->>Libp2p Client Connection: Status(ERROR_SERIALIZATION) else wrong payload Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Libp2p Node->>Libp2p Client Connection: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Libp2p Node->>Libp2p Client Connection: Status(SUCCESS) note over Libp2p Node: announce agent address to other peers Libp2p Node->>Libp2p Node: wait data from socket activate Libp2p Node deactivate Libp2p Node end The send method and the receive methods behave similarly to the send and receive methods of the valory/p2p_libp2p connection, in terms of message exchange; however, the communication is done via TCP rather than pipes. The disconnect method interrupts the connection with the delegate peer, without explicitly unregistering. Known issues and limitations In this section, we provide a list of known issues and limitations of the current implementation of the ACN, considering both the ACN nodes (written in Golang) and the AEA connections, for the Python AEA framework, to interact with them. Delegate client on client disconnection/reconnection In case of disconnection/reconnection, delegate client record will be removed. This can cause two problems: either the delegate client is not found, or connection is closed during the send operation. Possible solutions: Create more complicated structure for clients storage; Keep the delegate client record for longer; Clean up the record by timeout, per client queues. Code references: agent record removal message routing Golang Node <> Python Client libp2p connection In case of connection between the Golang side (i.e. ACN node) and the Python side (i.e. the libp2p AEA connection) is broken, there is no reconnection attempt. The Golang side connect to the Python server opened, but if the connection is broken Golang can try to reconnect; however, the Python side does not know about this and will restart the node completely. Possible solutions: the problem requires updates on both sides and assume possible timeouts on broken connection. If connection is broken, the Python side awaits for reconnection from Golang side, and restart node completely after timeout. What a peer should do if it receives an acknowledgement with an error? If an ACN response is the Status with error code different from SUCCESS , the forwarding to other peers is not repeated. A possible solution is to resend the message; however, not clear why it should help in case of healthy connection, how many times the sender should retry, and how it would help. Discussion on GitHub: https://github.com/fetchai/agents-aea/pull/2509#discussion_r642628983 No possibility of switching peers In case of a peer becoming unavailable, a delegate client or relay client currently has no means to automatically switch the peer. In particular, the DHT should be updated when a client switches peers.","title":"ACN Internals"},{"location":"acn-internals/#messages-and-data-structures","text":"At the foundation of the ACN there is the ACN protocol . The protocol messages and the reply structure are generated from this protocol specification , using the protocol generator . Therefore, it uses Protocol Buffers as a serialization format, and the definition of the data structures involved is defined in this .proto file . To know more about the protocol generator, refer to the relevant section of the documentation: Protocol Generator .","title":"Messages and Data Structures"},{"location":"acn-internals/#agent-record","text":"An agent record is a data structure containing information about an agent and its Proof-of-Representation (PoR) to be used by a peer for other peers. This data structure is used as a payload in other ACN messages (see below). The AgentRecord data structure contains the following fields: service_id : a string describing the service identifier. ledger_id : a string. It is the identifier of the ledger this agent record is associated to. Currently, the allowed values are: fetchai , the identifier for the Fetch.AI ledger; ethereum , the identifier for the Ethereum ledger; cosmos , the identifier for the Cosmos ledger; address : a string. It is the public key of a public-private key pair. It is used as an identifier for routing purposes. public_key : a string. The representative's public key. Used in case of (PoR). peer_public_key : a string. The public key of the peer. signature : a string. The signature for PoR. not_before : a string. Specify the lower bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0 not_after : a string. Specify the upper bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0.","title":"Agent Record"},{"location":"acn-internals/#acn-message","text":"Entities in the ACN (i.e. either agents or peers) exchange ACN messages . An ACN message contains a payload field, which is the actual content of the message. There are different types of payloads: Status Register LookupRequest LookupResponse AeaEnvelope","title":"ACN Message"},{"location":"acn-internals/#status","text":"The Status payload is used as a response message to inform the sender about the handling of certain requests. The payload contains: the status_code , a positive integer among the ones in the Protobuf file . a list of error messages (string). A status code 0 , identified as SUCCESS , means that the request has been processed successfully. Status codes greater than 0 can be: Generic errors: errors that occur under generic circumstances. ERROR_UNSUPPORTED_VERSION , with integer value 1 : the receiver of the message does not support the protocol version of the sender; ERROR_UNEXPECTED_PAYLOAD , with integer value 2 : the payload could not be deserialised on the receiver side; ERROR_GENERIC , with integer value 3 : an internal error; ERROR_SERIALIZATION , with integer value 4 : a serialization error occurred on the receiving end; Register errors: errors that occur during agent registration operations in the ACN. ERROR_WRONG_AGENT_ADDRESS , with integer value 10 : the PoR by a peer from another peer does not match the destination address of the envelope to be routed by the receiving peer. ERROR_WRONG_PUBLIC_KEY , with integer value 11 : the representative peer public key does not match the one in the agent record; ERROR_INVALID_PROOF , with integer value 12 : the signature is invalid; ERROR_UNSUPPORTED_LEDGER , with integer value 13 : the ledger of the PoR is not supported by the peer; Lookup and delivery errors: errors that occur during lookup to the DHT and envelope delivery operations in the ACN. ERROR_UNKNOWN_AGENT_ADDRESS , with integer value 20 : the requested agent address has not been found in the local DHT of the peer; ERROR_AGENT_NOT_READY , with integer value 21 : the agent is not ready for envelope delivery.","title":"Status"},{"location":"acn-internals/#register","text":"The Register payload is used to request a peer to register an agent among his known ones. The payload contains the field record , which is an instance of AgentRecord .","title":"Register"},{"location":"acn-internals/#lookuprequest","text":"The LookupRequest payload is sent between peer to look-up addresses in the Distributed Hash Table (DHT). It contains the agent address (a string) that the sender needs to correctly route an envelope.","title":"LookupRequest"},{"location":"acn-internals/#lookupresponse","text":"The LookupResponse payload is the response sent by a peer that received a LookupRequest . It contains the AgentRecord associated to the requested address.","title":"LookupResponse"},{"location":"acn-internals/#aeaenvelope","text":"The AeaEnvelope payload contains the envelope sent by an agent and to be delivered to another agent. It contains: envelope : the envelope to be forwarded, in byte representation; an AgentRecord (see above).","title":"AeaEnvelope"},{"location":"acn-internals/#acn-protocol-interactions","text":"The ACN protocol specifies three different possible interactions: the registration interaction the look-up interaction the routing interaction","title":"ACN Protocol Interactions"},{"location":"acn-internals/#registration-interaction","text":"The registration interaction is used by delegate agents or relayed peers to register themselves to another peer. sequenceDiagram participant Agent/RelayedPeer participant Peer Agent/RelayedPeer->>Peer: Register(AgentRecord) alt success note over Peer: check PoR Peer->>Agent/RelayedPeer: Status(SUCCESS) else wrong agent address Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_AGENT_ADDRESS) else wrong public key Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_PUBLIC_KEY) else invalid proof of representation Peer->>Agent/RelayedPeer: Status(ERROR_INVALID_PROOF) else unsupported ledger Peer->>Agent/RelayedPeer: Status(ERROR_UNSUPPORTED_LEDGER) end","title":"\"Registration\" Interaction"},{"location":"acn-internals/#look-up-interaction","text":"The look-up interaction is used by a peer to request information to another peer about an agent address. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest(address) alt success Peer2->>Peer1: LookupResponse(AgentRecord) else unknown agent address Peer2->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end","title":"\"Look-up\" Interaction"},{"location":"acn-internals/#routing-interaction","text":"The routing interaction is used by agents and peers to route the envelope through the ACN. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: AeaEnvelope(envelope, AgentRecord) alt success note over Peer2: check PoR Peer2->>Peer1: Status(SUCCESS) else error on decoding of Envelope payload Peer2->>Peer1: Status(ERROR_SERIALIZATION) else PoR errors note over Peer1,Peer2: see above end","title":"\"Routing\" Interaction"},{"location":"acn-internals/#joining-the-acn-network","text":"When an ACN peer wants to join the network, it has to start from a list of bootstrap peers , i.e. a list of ACN peers to connect with (at least one). Each node handles four different types of libp2p streams : the notification stream , identified by the URI /aea-notif/ : this stream is used by new peers to notify their existence to the address stream , identified by the URI /aea-address/ : used to send look-up requests and look-up responses; the envelope stream , identified by the URI /aea/ : used to forward and to receive ACN envelopes; the register relay stream , identified by the URI /aea-register/ : this is to receive messages from clients that want to register their agents addresses; this peer, and then it can register their addresses. To begin with, the node process initializes the transport connections with the bootstrap peers, the local copy of the Kademlia Distributed Hash Table (DHT), the persistent storage for agent records, and performs other non-functional operations like setting up the Prometheus monitoring system . Optionally, can also start listening for relay connections and delegate connections. Then, it sets up the notification stream and notifies the bootstrap peers (if any). sequenceDiagram participant Peer1 participant Peer2 participant Peer3 note over Peer1: notify bootstrap peers Peer1->>Peer2: notify Peer2->>Peer2: wait until notifying peer added to DHT activate Peer2 Peer1->>Peer3: notify Peer3->>Peer3: wait until notifying peer added to DHT activate Peer3 note over Peer2,Peer3: Peer1 registered to DHT deactivate Peer2 deactivate Peer3 loop for each local/relay/delegate address Peer1->>Peer1: compute CID from address Peer1->>Peer2: register address Peer1->>Peer3: register address end note over Peer1: set up: - address stream - envelope stream - register relay stream","title":"Joining the ACN network"},{"location":"acn-internals/#relay-connections","text":"If the ACN node is configured to run the relay service, it sets up the register relay stream, waiting for registration requests. The following diagram shows an example of the message exchanged during a registration request: sequenceDiagram participant Agent participant Peer Agent->>Peer: Register alt decoding error of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else wrong payload Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer->>Agent: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer->>Agent: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Peer->>Agent: Status(SUCCESS) note over Peer: announce agent address to other peers end","title":"Relay connections"},{"location":"acn-internals/#delegate-connections","text":"If the ACN node is configured to run the delegate service, it starts listening from a TCP socket at a configurable URI. To see a diagram of the message exchanged during a registration request read this section .","title":"Delegate connections"},{"location":"acn-internals/#acn-transport","text":"In the following sections, we describe the main three steps of the routing of an envelope through the ACN: ACN entrance : when an envelope sent by an agent enters the peer-to-peer network via the peer the agent is connected to i.e. agent-to-peer communication; ACN routing : when an envelope gets routed through the peer-to-peer network, i.e. peer-to-peer communication; ACN exit : when an envelope gets delivered to the receiving agent through its representative peer, i.e. peer-to-agent communication.","title":"ACN transport"},{"location":"acn-internals/#acn-envelope-entrance-agent-peer","text":"In this section, we will describe the interaction protocols between agents and peers for the messages sent by the agent to the ACN network; in particular, the communication from the contact peer of an agent to the agent. The following diagram explains the exchange of messages on entering an envelope in the ACN. In the case of direct connection , Agent is a Python process, whereas Peer is in a separate (Golang) process. The logic of the Python Agent client is implemented in the valory/p2p_libp2p connection. The communication between Agent and Peer is done through an OS pipe for Inter-Process Communication (IPC) between the AEAs process and the libp2p node process; then, the message gets enqueued to an output queue by an input coroutine. Finally, the envelope ends up in an output queue, which is processed by an output coroutine and routed to the next peer. In the case of delegate connection , the message exchange is very similar; however, instead of using pipes, the communication is done through the network, i.e. TCP, with a peer which has the delegate service enabled. The logic of the Agent client connected with a delegate connection is implemented in the open-aea valory/p2p_libp2p_client connection. sequenceDiagram participant Agent participant Peer loop until Status(success) received Agent->>Peer: AeaEnvelope Agent->>Agent: wait note left of Agent: Wait until Status(success) alt successful case Peer->>Agent: Status(success) note over Agent: break loop else ack-timeout OR conn-error note left of Agent: continue: Try to resend/reconnect else version not supported Peer->>Agent: Status(ERROR_UNSUPPORTED_VERSION) else error on decoding of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else error on decoding of Envelope payload Peer->>Agent: Status(ERROR_SERIALIZATION) else the payload cannot be handled Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) end end note over Peer: route envelope to next peer","title":"ACN Envelope Entrance: Agent -&gt; Peer"},{"location":"acn-internals/#acn-envelope-routing","text":"In this section, we describe the interaction between peers when it comes to envelope routing. Assume an envelope arrives from an agent to peer Peer1 , i.e. Peer1 is the first hop of the routing. Let Agent be the local agent directly connected to Peer1 , Peer2 a direct peer of peer Peer1 . When the envelope is leaving Peer1 , we may have different scenario: 1) In case of direct connection, and the field sender of the envelope is not the local agent address: the message is considered invalid, and it is dropped. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt envelope sender not registered locally note over Peer1: stop, log error end 2) the target of the envelope is the local agent connected to the peer: the envelope is routed to the local agent. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt target == peer1.my_agent note over Peer1: envelope designated to local agent, not routing loop agent not ready note over Peer1: sleep for 100ms end Peer1->>Agent: AeaEnvelope Agent->>Peer1: Status(Success) end 3) the target is a delegate client. Send the envelope via TCP. sequenceDiagram participant Delegate participant Peer1 participant Peer2 Delegate->>Peer1: AeaEnvelope alt destination is a delegate note over Peer1: send envelope to delegate via TCP Peer1->>Delegate: AeaEnvelope Delegate->>Peer1: Status(Success) end 4) Otherwise, look up the local DHT. If an entry is found, use it; otherwise, send a look-up request to connected peers. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt address found in DHT note over Peer1: destination is a relay client else lookup address in DHT note over Peer1: send lookup request to all peers Peer1->>Peer2: LookupRequest alt generic error Peer2->>Peer1: Status(GENERIC_ERROR) else look-up response Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end note over Peer1,Peer2: Now Peer1 knows the contact peer is PeerX In particular, when a peer receives a LookupRequest message, it does the following: sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest alt error Peer2->>Peer1: Status(Error) else local agent/relay/delegate note over Peer2: requested address is a local agent OR requested address is in my relay clients OR requested address is in my delegate clients Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found locally note over Peer2: send lookup request to other peers... alt found Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end Let Peer3 the contact peer of the recipient of the envelope. The following diagram shows how the contact peer of the envelope recipient handles the incoming envelope: sequenceDiagram participant Peer1 participant Peer3 Peer1->>Peer3: AeaEnvelope alt decoding error of ACN message Peer3->>Peer1: Status(ERROR_SERIALIZATION) else unexpected payload Peer3->>Peer1: Status(ERROR_UNEXPECTED_PAYLOAD) else decoding error of envelope payload Peer3->>Peer1: Status(ERROR_SERIALIZATION) else PoR check fails alt wrong agent address Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer3->>Peer1: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer3->>Peer1: Status(ERROR_INVALID_PROOF) end else PoR check succeeds alt target is delegate, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else exists delegate, ready note over Peer3: forward envelope via delegate connection Peer3->>Peer1: Status(SUCCESS) else target is local agent, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else target is local agent, ready note over Peer3: forward envelope via direct connection Peer3->>Peer1: Status(SUCCESS) else agent does not exist Peer3->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end end","title":"ACN Envelope Routing"},{"location":"acn-internals/#acn-envelope-exit-peer-agent","text":"The following diagram explains the exchange of messages on exiting an envelope in the ACN. That is, the communication from the contact peer of an agent to the agent. The same message exchange is done both in the case of direct connection and delegate connection, similarly for what has been described for the envelope entrance (see above) . sequenceDiagram participant Agent participant Peer Peer->>Agent: AeaEnvelope alt successful case Agent->>Peer: Status(success) else ack-timeout OR conn-error note left of Peer: do nothing else error on decoding of ACN message Agent->>Peer: Status(GENERIC_ERROR) else error on decoding of Envelope payload Agent->>Peer: Status(GENERIC_ERROR) else wrong payload Agent->>Peer: Status(GENERIC_ERROR) end","title":"ACN Envelope Exit: Peer -&gt; Agent"},{"location":"acn-internals/#connect-your-aea-to-the-acn","text":"To connect the AEA to the ACN network, there are two AEA connections available: the valory/p2p_libp2p , that implements a direct connection, and the valory/p2p_libp2p_client connection, that implements the delegate connection. For more information on the AEA connection package type, refer to this guide .","title":"Connect your AEA to the ACN"},{"location":"acn-internals/#the-valoryp2p_libp2p-connection","text":"The source code of the valory/p2p_libp2p connection can be downloaded here . The package provides the connection class P2PLibp2pConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection spawns a new instance of the libp2p_node program (i.e. an ACN peer node) and connects to it through OS pipes. Then, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Connection participant sending loop participant receiving loop participant Libp2p Node Libp2p Connection->>Libp2p Node: spawn process activate Libp2p Node Libp2p Connection->>sending loop: start recv loop sending loop->>sending loop: wait messages from output queue activate sending loop Libp2p Connection->>receiving loop: start send loop receiving loop->>receiving loop: wait messages from input queue activate receiving loop deactivate Libp2p Node deactivate sending loop deactivate receiving loop The send method enqueues a message in the output queue. The message is then dequeued by the sending loop, and then sent to the Libp2p node. sequenceDiagram participant Libp2p Connection participant sending loop participant Libp2p Node activate sending loop Libp2p Connection->>Libp2p Connection: enqueue message to output queue sending loop->>sending loop: dequeue message from output queue deactivate sending loop sending loop->>Libp2p Node: AeaEnvelope sending loop->>sending loop: wait for status activate sending loop alt success note over Libp2p Node: route envelope Libp2p Node->>sending loop: Status(SUCCESS) deactivate sending loop note over sending loop: OK else timed out note over sending loop: raise with error else acn message decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) else unexpected payload Libp2p Node->>sending loop: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) end The receive method dequeues a message from the input queue. The queue is populated by the receiving loop, which receives messages from the Libp2p node. sequenceDiagram participant Libp2p Connection participant receiving loop participant Libp2p Node activate receiving loop Libp2p Node->>receiving loop: AeaEnvelope deactivate receiving loop Libp2p Node->>Libp2p Node: wait for status activate Libp2p Node alt success note over receiving loop: enqueue envelope to input queue receiving loop->>Libp2p Node: Status(SUCCESS) deactivate Libp2p Node note over receiving loop: OK else timed out note over Libp2p Node: ignore else acn message decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) else unexpected payload receiving loop->>Libp2p Node: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) end Libp2p Connection->>receiving loop: read message from output queue note over Libp2p Connection: return message to Multiplexer the disconnect method stops both the receiving loop and the sending loop, and stops the Libp2p node.","title":"The valory/p2p_libp2p connection"},{"location":"acn-internals/#the-valoryp2p_libp2p_client-connection","text":"The source code of the valory/p2p_libp2p_client connection can be downloaded here . The package provides the connection class P2PLibp2pClientConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection will set up a TCP connection to the URI of the delegate peer. Then, it will send a Register request to register the agent among the peer's client connections. On registration success, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Client Connection participant Libp2p Node activate Libp2p Node Libp2p Node->>Libp2p Node: listening for TCP connections Libp2p Client Connection->>Libp2p Node: Register (via TCP) deactivate Libp2p Node alt decoding error of ACN message Libp2p Node->>Libp2p Client Connection: Status(ERROR_SERIALIZATION) else wrong payload Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Libp2p Node->>Libp2p Client Connection: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Libp2p Node->>Libp2p Client Connection: Status(SUCCESS) note over Libp2p Node: announce agent address to other peers Libp2p Node->>Libp2p Node: wait data from socket activate Libp2p Node deactivate Libp2p Node end The send method and the receive methods behave similarly to the send and receive methods of the valory/p2p_libp2p connection, in terms of message exchange; however, the communication is done via TCP rather than pipes. The disconnect method interrupts the connection with the delegate peer, without explicitly unregistering.","title":"The valory/p2p_libp2p_client connection"},{"location":"acn-internals/#known-issues-and-limitations","text":"In this section, we provide a list of known issues and limitations of the current implementation of the ACN, considering both the ACN nodes (written in Golang) and the AEA connections, for the Python AEA framework, to interact with them.","title":"Known issues and limitations"},{"location":"acn-internals/#delegate-client-on-client-disconnectionreconnection","text":"In case of disconnection/reconnection, delegate client record will be removed. This can cause two problems: either the delegate client is not found, or connection is closed during the send operation. Possible solutions: Create more complicated structure for clients storage; Keep the delegate client record for longer; Clean up the record by timeout, per client queues. Code references: agent record removal message routing","title":"Delegate client on client disconnection/reconnection"},{"location":"acn-internals/#golang-node-python-client-libp2p-connection","text":"In case of connection between the Golang side (i.e. ACN node) and the Python side (i.e. the libp2p AEA connection) is broken, there is no reconnection attempt. The Golang side connect to the Python server opened, but if the connection is broken Golang can try to reconnect; however, the Python side does not know about this and will restart the node completely. Possible solutions: the problem requires updates on both sides and assume possible timeouts on broken connection. If connection is broken, the Python side awaits for reconnection from Golang side, and restart node completely after timeout.","title":"Golang Node &lt;&gt; Python Client libp2p connection"},{"location":"acn-internals/#what-a-peer-should-do-if-it-receives-an-acknowledgement-with-an-error","text":"If an ACN response is the Status with error code different from SUCCESS , the forwarding to other peers is not repeated. A possible solution is to resend the message; however, not clear why it should help in case of healthy connection, how many times the sender should retry, and how it would help. Discussion on GitHub: https://github.com/fetchai/agents-aea/pull/2509#discussion_r642628983","title":"What a peer should do if it receives an acknowledgement with an error?"},{"location":"acn-internals/#no-possibility-of-switching-peers","text":"In case of a peer becoming unavailable, a delegate client or relay client currently has no means to automatically switch the peer. In particular, the DHT should be updated when a client switches peers.","title":"No possibility of switching peers"},{"location":"acn/","text":"The agent communication network (ACN) provides a system for agents to find each other and communicate, solely based on their wallet addresses. It addresses the message delivery problem. Message delivery problem Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties? The properties we would like are: Reliability: with guarantees on message reception Authentication: to prevent impersonation Confidentiality: to prevent exposing sensitive information within the message Availability: some guarantees about the liveness of the service (tampering detection) The problem statement and the agent framework context impose a number of design constraints: Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet Decentralized environment: no trusted central authority Support for resource-constrained devices The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints. Peers The ACN is maintained by peers. Peers are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system. Distributed hash table At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by: Consistent hashing: decide responsibility for assignment of the DHT key-value storage Structured overlays: organize the participating peers in a well-defined topology for efficient routing For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer. N-tier architecture To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different Connections : Note The p2p_libp2p_mailbox connection is not available yet. Trust and security An agent can choose which connection to use depending on the resource and trust requirements: valory/p2p_libp2p connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity. valory/p2p_libp2p_client connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer. All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys.","title":"Agent Communication Network"},{"location":"acn/#message-delivery-problem","text":"Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties? The properties we would like are: Reliability: with guarantees on message reception Authentication: to prevent impersonation Confidentiality: to prevent exposing sensitive information within the message Availability: some guarantees about the liveness of the service (tampering detection) The problem statement and the agent framework context impose a number of design constraints: Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet Decentralized environment: no trusted central authority Support for resource-constrained devices The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints.","title":"Message delivery problem"},{"location":"acn/#peers","text":"The ACN is maintained by peers. Peers are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system.","title":"Peers"},{"location":"acn/#distributed-hash-table","text":"At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by: Consistent hashing: decide responsibility for assignment of the DHT key-value storage Structured overlays: organize the participating peers in a well-defined topology for efficient routing For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer.","title":"Distributed hash table"},{"location":"acn/#n-tier-architecture","text":"To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different Connections : Note The p2p_libp2p_mailbox connection is not available yet.","title":"N-tier architecture"},{"location":"acn/#trust-and-security","text":"An agent can choose which connection to use depending on the resource and trust requirements: valory/p2p_libp2p connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity. valory/p2p_libp2p_client connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer. All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys.","title":"Trust and security"},{"location":"aea-vs-mvc/","text":"The AEA framework borrows several concepts from popular web frameworks like Django and Ruby on Rails . MVC Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the HTML templates Controller: deals with the request-response handling Comparison to AEA framework The AEA framework is based on asynchronous messaging and other agent-oriented development assumptions . Hence, there is not a direct one-to-one relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make quick progress in the AEA framework, in particular the development of Skills : Handler : receives messages for the protocol it is registered against and is supposed to handle these messages. Handlers are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. They can also send new messages. Behaviour : a behaviour encapsulates proactive components of the agent. Since web apps do not have any goals or intentions, they do not proactively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours also can, but do not have to, send messages. Task : they are meant to deal with long-running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : they implement business logic and data representation, and as such, they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services. Next steps We recommend you continue with the next step in the 'Getting Started' series: Core components 2","title":"AEA and web frameworks"},{"location":"aea-vs-mvc/#mvc","text":"Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the HTML templates Controller: deals with the request-response handling","title":"MVC"},{"location":"aea-vs-mvc/#comparison-to-aea-framework","text":"The AEA framework is based on asynchronous messaging and other agent-oriented development assumptions . Hence, there is not a direct one-to-one relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make quick progress in the AEA framework, in particular the development of Skills : Handler : receives messages for the protocol it is registered against and is supposed to handle these messages. Handlers are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. They can also send new messages. Behaviour : a behaviour encapsulates proactive components of the agent. Since web apps do not have any goals or intentions, they do not proactively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours also can, but do not have to, send messages. Task : they are meant to deal with long-running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : they implement business logic and data representation, and as such, they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services.","title":"Comparison to AEA framework"},{"location":"aea-vs-mvc/#next-steps","text":"We recommend you continue with the next step in the 'Getting Started' series: Core components 2","title":"Next steps"},{"location":"aev-echo-demo/","text":"Configuring with Environment Variables The purpose of this demonstration is to show the open-aea framework can dynamically configure agents from environment variables. A full break down of the development flow is covered within the Development Quickstart . It is highly recommended that developers begin by following the quick start! After you have followed the quick start, create a HTTP Echo Agent . It is assumed that developers are within a pipenv virtual environment. Notice, that the configuration of the AEA is as so; agent_name : http_echo author : open_aea version : 0.1.0 license : Apache-2.0 description : Http echo agent configured with default variables. aea_version : '>=1.3.0, <2.0.0' fingerprint : {} fingerprint_ignore_patterns : [] connections : - fetchai/http_server:0.22.0 contracts : [] protocols : - fetchai/default:1.0.0 - fetchai/http:1.0.0 - open_aea/signing:1.0.0 skills : - fetchai/http_echo:0.20.0 default_ledger : ethereum required_ledgers : - ethereum default_routing : {} connection_private_key_paths : {} private_key_paths : ethereum : ethereum_private_key.txt logging_config : disable_existing_loggers : false version : 1 dependencies : open-aea-ledger-ethereum : {} default_connection : null --- public_id : fetchai/http_server:0.22.0 type : connection config : host : ${HOST:str:localhost} port : ${PORT:int:5000} target_skill_id : ${TARGET_SKILL:str:fetchai/http_echo:0.20.0} Notice how the fetchai/http_server:0.22.0 has a number of override parameters specified: host : ${HOST:str:localhost} port : ${PORT:int:5000} target_skill_id : ${TARGET_SKILL:str:fetchai/http_echo:0.20.0} Please notice the values provided to the over-rides. The syntax is as follows; ${ENVIRONMENT_VALUE:PYTHON_TYPE:DEFAULT_VALUE} We can use environment variables to override these default values. First run the agent with the default port (assuming you are within the agent directory created within HTTP Echo Agent ) as so: aea run --aev The --aev flag specifies to apply environment overrides The AEA will then start a web server as so: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.4.0 Starting AEA 'http_echo' in 'async' mode... info: [ http_echo ] HTTP Server has connected to port: 5000 . info: [ http_echo ] Start processing messages... We can interact with this server using curl in another terminal as so; curl localhost:5000 { \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }} In order to use the environment overrides, we must first stop our AEA. Once the AEA is stopped: export PORT = 8081 aea run --aev _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.4.0 Starting AEA 'http_echo' in 'async' mode... info: [ http_echo ] HTTP Server has connected to port: 8081 . info: [ http_echo ] Start processing messages... We can confirm that we are now serving on a different port as so; curl localhost:8081 { \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }} Congratulations! You have just used an AEA successfully as a web server! Tear Down aea delete http_echo","title":"Configure with Environment Variables"},{"location":"aev-echo-demo/#configuring-with-environment-variables","text":"The purpose of this demonstration is to show the open-aea framework can dynamically configure agents from environment variables. A full break down of the development flow is covered within the Development Quickstart . It is highly recommended that developers begin by following the quick start! After you have followed the quick start, create a HTTP Echo Agent . It is assumed that developers are within a pipenv virtual environment. Notice, that the configuration of the AEA is as so; agent_name : http_echo author : open_aea version : 0.1.0 license : Apache-2.0 description : Http echo agent configured with default variables. aea_version : '>=1.3.0, <2.0.0' fingerprint : {} fingerprint_ignore_patterns : [] connections : - fetchai/http_server:0.22.0 contracts : [] protocols : - fetchai/default:1.0.0 - fetchai/http:1.0.0 - open_aea/signing:1.0.0 skills : - fetchai/http_echo:0.20.0 default_ledger : ethereum required_ledgers : - ethereum default_routing : {} connection_private_key_paths : {} private_key_paths : ethereum : ethereum_private_key.txt logging_config : disable_existing_loggers : false version : 1 dependencies : open-aea-ledger-ethereum : {} default_connection : null --- public_id : fetchai/http_server:0.22.0 type : connection config : host : ${HOST:str:localhost} port : ${PORT:int:5000} target_skill_id : ${TARGET_SKILL:str:fetchai/http_echo:0.20.0} Notice how the fetchai/http_server:0.22.0 has a number of override parameters specified: host : ${HOST:str:localhost} port : ${PORT:int:5000} target_skill_id : ${TARGET_SKILL:str:fetchai/http_echo:0.20.0} Please notice the values provided to the over-rides. The syntax is as follows; ${ENVIRONMENT_VALUE:PYTHON_TYPE:DEFAULT_VALUE} We can use environment variables to override these default values. First run the agent with the default port (assuming you are within the agent directory created within HTTP Echo Agent ) as so: aea run --aev The --aev flag specifies to apply environment overrides The AEA will then start a web server as so: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.4.0 Starting AEA 'http_echo' in 'async' mode... info: [ http_echo ] HTTP Server has connected to port: 5000 . info: [ http_echo ] Start processing messages... We can interact with this server using curl in another terminal as so; curl localhost:5000 { \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }} In order to use the environment overrides, we must first stop our AEA. Once the AEA is stopped: export PORT = 8081 aea run --aev _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.4.0 Starting AEA 'http_echo' in 'async' mode... info: [ http_echo ] HTTP Server has connected to port: 8081 . info: [ http_echo ] Start processing messages... We can confirm that we are now serving on a different port as so; curl localhost:8081 { \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }} Congratulations! You have just used an AEA successfully as a web server!","title":"Configuring with Environment Variables"},{"location":"aev-echo-demo/#tear-down","text":"aea delete http_echo","title":"Tear Down"},{"location":"agent-oriented-development/","text":"Agent-oriented development This section introduces concepts and characteristics of agent-based systems and problem-solving approaches. At the end of this section the reader will know how problems can be contextualized in a way that allows them to be addressed by agent-based systems, and possess the necessary knowledge to start working on the design and implementation of agent-based solutions to real world problems. Decentralisation Allowing for direct peer-to-peer communication makes Multi-Agent Systems ( MAS ) inherently decentralized. This contrasts conventional systems design, such as that of the client-server model, in which clients are forced to trust the server host - a central point of authority in the network - as the mediator of all client interactions. That does not imply that facilitators of services and middlemen have no place in a multi-agent system; rather it is the notion of a ' commanding reliance on middlemen ' that is rejected. Lack of a centralized authority is not their only distinctive characteristic. The agents and their components - those enabling them to enact, react and engage in decision-making - generally belong to different stakeholders - e.g. individuals, companies or governments - and need to share no more commonality than a network connection and an interaction protocol to be able to interact. The consequence hereof is that they can be exceptionally diverse in terms of their design, the standards they adhere to, the software used to implement them and the hardware they operate on. Moreover, each of the agents has their own objectives, which may well be unaligned, inconsistent or even conflicting with those of others. Division of responsibilities: In a decentralised system every agent is equally privileged and (in principle) able to interact with any other agent. Without a central authority that provides the services needed to mediate agent interactions, hosting them becomes part of the agents' responsibility. An example hereof is the access to a registry of contact addresses that is otherwise maintained by a service provider. Without any form of government, however, a central database that can be updated at the sole discretion of any individual agent is easily corrupted. Yet, a system in which every agent is only responsible for maintaining their own set of records is also problematic, since errors and the asynchronous execution of events inevitably leads to a situation in which agents possess different versions of the record. Instead, agents must share responsibility over the state of records and do so by maintaining a local copy of it and periodically synchronizing this state by requiring consensus to be achieved over it and any updates to it. Distributed ledger technologies, such as blockchain-based cryptocurrencies, are a prime example of this. A characteristic feature of cryptocurrencies is the absence of central trusted entities (e.g. banks). The notion of decentralisation extends as far as ownership and control. Although enabled through the use of open source code and cryptographic primitives offering security precautions, the validation of transactions and accuracy of ledger is ultimately the responsibility of individuals. Decentralised vs distributed: It is important to distinguish the concepts of distributed and decentralised systems. A distributed system is one whose components are physically separated and connected over a network, whereas a decentralised system requires control over its governance to be shared among its stakeholders. Google or Microsoft's cloud infrastructure are examples of the former; nodes of these networks are distributed across the globe, yet these systems are centralized because governance over them resides solely with centralized entities. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service - provided, owned and run by the commerce company itself - which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However, in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for. Conflicting Environment Since decentralisation implies shared ownership and control of governance, with each of the entities in these networks acting in pursuit of their own objectives, conflicts of interest are expected to arise. Practical implications hereof on the design of agents that need to be considered by a developer are that information available to it is: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. This uncertainty poses a challenge to the agents, who, since they cannot blindly trust other agents, need to validate the information that they provide. Asynchronous task execution A system of self-interested agents favours a design that allowed for asynchronous execution, such that agents can express behaviour independently each other. Asynchronous programming: Generally speaking, asynchronous programming allows the decoupling of the tasks that the agents carry out via concurrent processing. This leads to uncertainty regarding the behaviour of the system, since the order of code execution will vary. For example, suppose an agent i sends a message requesting some resources from an agent j . Since agents are distributed, there is uncertainties associated with the communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There is a myriad of reasons why it may choose to do that. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. This makes developing applications for systems whose constituents are autonomous fundamentally different from conventional object-oriented systems design. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object has no control over access to its attributes or the execution of its methods by other objects in the system. We cannot take for granted that an agent i will execute an action (the equivalent of a method in object-oriented systems) just because another agent j wants it to. We therefore do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. The control structure of these systems in different and can be summarised with the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. Time Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time X ). Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour. Complex, Incomplete, Inconsistent and Uncertain The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment. Further Reading Wooldridge, M. (2009). An Introduction to MultiAgent Systems . Wiley, Second edition. Shoham, Y. and Leyton-Brown, K. (2008). Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations . Cambridge University Press","title":"Agent-oriented development"},{"location":"agent-oriented-development/#agent-oriented-development","text":"This section introduces concepts and characteristics of agent-based systems and problem-solving approaches. At the end of this section the reader will know how problems can be contextualized in a way that allows them to be addressed by agent-based systems, and possess the necessary knowledge to start working on the design and implementation of agent-based solutions to real world problems.","title":"Agent-oriented development"},{"location":"agent-oriented-development/#decentralisation","text":"Allowing for direct peer-to-peer communication makes Multi-Agent Systems ( MAS ) inherently decentralized. This contrasts conventional systems design, such as that of the client-server model, in which clients are forced to trust the server host - a central point of authority in the network - as the mediator of all client interactions. That does not imply that facilitators of services and middlemen have no place in a multi-agent system; rather it is the notion of a ' commanding reliance on middlemen ' that is rejected. Lack of a centralized authority is not their only distinctive characteristic. The agents and their components - those enabling them to enact, react and engage in decision-making - generally belong to different stakeholders - e.g. individuals, companies or governments - and need to share no more commonality than a network connection and an interaction protocol to be able to interact. The consequence hereof is that they can be exceptionally diverse in terms of their design, the standards they adhere to, the software used to implement them and the hardware they operate on. Moreover, each of the agents has their own objectives, which may well be unaligned, inconsistent or even conflicting with those of others. Division of responsibilities: In a decentralised system every agent is equally privileged and (in principle) able to interact with any other agent. Without a central authority that provides the services needed to mediate agent interactions, hosting them becomes part of the agents' responsibility. An example hereof is the access to a registry of contact addresses that is otherwise maintained by a service provider. Without any form of government, however, a central database that can be updated at the sole discretion of any individual agent is easily corrupted. Yet, a system in which every agent is only responsible for maintaining their own set of records is also problematic, since errors and the asynchronous execution of events inevitably leads to a situation in which agents possess different versions of the record. Instead, agents must share responsibility over the state of records and do so by maintaining a local copy of it and periodically synchronizing this state by requiring consensus to be achieved over it and any updates to it. Distributed ledger technologies, such as blockchain-based cryptocurrencies, are a prime example of this. A characteristic feature of cryptocurrencies is the absence of central trusted entities (e.g. banks). The notion of decentralisation extends as far as ownership and control. Although enabled through the use of open source code and cryptographic primitives offering security precautions, the validation of transactions and accuracy of ledger is ultimately the responsibility of individuals. Decentralised vs distributed: It is important to distinguish the concepts of distributed and decentralised systems. A distributed system is one whose components are physically separated and connected over a network, whereas a decentralised system requires control over its governance to be shared among its stakeholders. Google or Microsoft's cloud infrastructure are examples of the former; nodes of these networks are distributed across the globe, yet these systems are centralized because governance over them resides solely with centralized entities. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service - provided, owned and run by the commerce company itself - which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However, in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for.","title":"Decentralisation"},{"location":"agent-oriented-development/#conflicting-environment","text":"Since decentralisation implies shared ownership and control of governance, with each of the entities in these networks acting in pursuit of their own objectives, conflicts of interest are expected to arise. Practical implications hereof on the design of agents that need to be considered by a developer are that information available to it is: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. This uncertainty poses a challenge to the agents, who, since they cannot blindly trust other agents, need to validate the information that they provide.","title":"Conflicting Environment"},{"location":"agent-oriented-development/#asynchronous-task-execution","text":"A system of self-interested agents favours a design that allowed for asynchronous execution, such that agents can express behaviour independently each other. Asynchronous programming: Generally speaking, asynchronous programming allows the decoupling of the tasks that the agents carry out via concurrent processing. This leads to uncertainty regarding the behaviour of the system, since the order of code execution will vary. For example, suppose an agent i sends a message requesting some resources from an agent j . Since agents are distributed, there is uncertainties associated with the communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There is a myriad of reasons why it may choose to do that. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. This makes developing applications for systems whose constituents are autonomous fundamentally different from conventional object-oriented systems design. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object has no control over access to its attributes or the execution of its methods by other objects in the system. We cannot take for granted that an agent i will execute an action (the equivalent of a method in object-oriented systems) just because another agent j wants it to. We therefore do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. The control structure of these systems in different and can be summarised with the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to.","title":"Asynchronous task execution"},{"location":"agent-oriented-development/#time","text":"Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time X ). Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour.","title":"Time"},{"location":"agent-oriented-development/#complex-incomplete-inconsistent-and-uncertain","text":"The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.","title":"Complex, Incomplete, Inconsistent and Uncertain"},{"location":"agent-oriented-development/#further-reading","text":"Wooldridge, M. (2009). An Introduction to MultiAgent Systems . Wiley, Second edition. Shoham, Y. and Leyton-Brown, K. (2008). Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations . Cambridge University Press","title":"Further Reading"},{"location":"agent-vs-aea/","text":"AEAs are more than just agents. In this guide we show some of the differences in terms of code. The Build an AEA programmatically guide shows how to programmatically build an AEA. We can build an agent of the Agent class programmatically as well. First, import the python and application specific libraries. (Get the packages directory from the AEA repository svn export https://github.com/valory-xyz/open-aea.git/trunk/packages .) import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage Unlike an AEA , an Agent does not require a Wallet , LedgerApis or Resources module. However, we need to implement 4 abstract methods: - setup() - act() - handle_envelope() - teardown() When we run an agent, start() calls setup() and then the main agent loop. The main agent loop calls act() , react() and update() on each tick. When the agent is stopped via stop() then teardown() is called. Such a lightweight agent can be used to implement simple logic. Code an Agent We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" Instantiate an Agent # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) Start the agent We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) Shutdown Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join () Your turn Now it is your turn to develop a simple agent with the Agent class. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"AEAs vs agents"},{"location":"agent-vs-aea/#code-an-agent","text":"We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\"","title":"Code an Agent"},{"location":"agent-vs-aea/#instantiate-an-agent","text":"# Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ])","title":"Instantiate an Agent"},{"location":"agent-vs-aea/#start-the-agent","text":"We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the agent"},{"location":"agent-vs-aea/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" ))","title":"Send and receive an envelope"},{"location":"agent-vs-aea/#shutdown","text":"Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join ()","title":"Shutdown"},{"location":"agent-vs-aea/#your-turn","text":"Now it is your turn to develop a simple agent with the Agent class.","title":"Your turn"},{"location":"agent-vs-aea/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"app-areas/","text":"The introduction and the agent-oriented development guide together present a picture of the kinds of solution an agent-based approach makes possible, and the types of environment they are most suited for. In short, this is where: the environment is decentralised, involves multiple stakeholders, and is inhabited by AEAs representing the different stakeholders who: interact autonomously, and communicate with one another directly via a peer-to-peer network. In light of those discussions, on this page we identify a number of application areas for AEA-based solutions. This list is by no means comprehensive. In fact, we are most excited about applications which we have not thought of before. Inhabitants : agents representing objects in the IoT (Internet of Things) space. For examples, AEAs paired with real world hardware devices such as drones, laptops, heat sensors, etc. Interfaces : facilitation agents which provide the necessary API interfaces for interaction between existing (Web 2.0) and new (Web 3.0) economic models. An example is an AEA with HTTP connection and skill who has the capability to communicate using HTTP. Pure software : software agents living in the digital space that interact with interface agents and others. Digital data sales agents : software agents that attach to data sources and sell it to other agents. Representative : an agent which represents an individual's activities on the network. Likely short-term applications In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well-defined processes in different domains such as supply chain, mobility and finance, etc. Microtransactions: AEAs make it economically viable to execute trades which involve small value transfers. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify interactions with blockchains for end users. For instance, they can act as \"smart wallets\" which optimize blockchain interactions on behalf of the user. Multi-agent system versus agent-based modelling The multi-agent systems enabled by the AEA framework are technological agent-based solutions to real problems and, although there are some overlap, the framework is not designed from the outset to be used as an agent-based modelling software where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi ; single-agent applications are also supported.","title":"Application areas"},{"location":"app-areas/#likely-short-term-applications","text":"In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well-defined processes in different domains such as supply chain, mobility and finance, etc. Microtransactions: AEAs make it economically viable to execute trades which involve small value transfers. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify interactions with blockchains for end users. For instance, they can act as \"smart wallets\" which optimize blockchain interactions on behalf of the user.","title":"Likely short-term applications"},{"location":"app-areas/#multi-agent-system-versus-agent-based-modelling","text":"The multi-agent systems enabled by the AEA framework are technological agent-based solutions to real problems and, although there are some overlap, the framework is not designed from the outset to be used as an agent-based modelling software where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi ; single-agent applications are also supported.","title":"Multi-agent system versus agent-based modelling"},{"location":"build-aea-programmatically/","text":"These instructions detail the Python code you need for running an AEA outside the cli tool, using the code interface. Preparation Get the packages' directory from the AEA repository: svn export https://github.com/valory-xyz/open-aea.git/trunk/packages Also, install open-aea-ledger-fetchai plug-in: pip install open-aea-ledger-fetchai Imports First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) Create a private key We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Clearing the input and output files We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) Initialise the AEA We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:1.0.0 , fetchai/state_update:1.0.0 and open_aea/signing:1.0.0 protocols. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Next, we add the fetchai/stub:0.15.0 connection which will read/write messages from file: # Add the default protocol (assuming it is present in the local directory 'packages') builder . add_protocol ( \"./packages/fetchai/protocols/default\" ) # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build () Start the AEA We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) Send and receive an envelope We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) Shutdown Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None Running the AEA If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello, output message: other_agent,my_aea,fetchai/default:1.0.0,...\\x05hello Entire code listing If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Add the default protocol (assuming it is present in the local directory 'packages') builder . add_protocol ( \"./packages/fetchai/protocols/default\" ) # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Build an AEA programmatically"},{"location":"build-aea-programmatically/#preparation","text":"Get the packages' directory from the AEA repository: svn export https://github.com/valory-xyz/open-aea.git/trunk/packages Also, install open-aea-ledger-fetchai plug-in: pip install open-aea-ledger-fetchai","title":"Preparation"},{"location":"build-aea-programmatically/#imports","text":"First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier )","title":"Imports"},{"location":"build-aea-programmatically/#create-a-private-key","text":"We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE )","title":"Create a private key"},{"location":"build-aea-programmatically/#clearing-the-input-and-output-files","text":"We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE )","title":"Clearing the input and output files"},{"location":"build-aea-programmatically/#initialise-the-aea","text":"We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:1.0.0 , fetchai/state_update:1.0.0 and open_aea/signing:1.0.0 protocols. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Next, we add the fetchai/stub:0.15.0 connection which will read/write messages from file: # Add the default protocol (assuming it is present in the local directory 'packages') builder . add_protocol ( \"./packages/fetchai/protocols/default\" ) # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build ()","title":"Initialise the AEA"},{"location":"build-aea-programmatically/#start-the-aea","text":"We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 )","title":"Start the AEA"},{"location":"build-aea-programmatically/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"build-aea-programmatically/#shutdown","text":"Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None","title":"Shutdown"},{"location":"build-aea-programmatically/#running-the-aea","text":"If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello, output message: other_agent,my_aea,fetchai/default:1.0.0,...\\x05hello","title":"Running the AEA"},{"location":"build-aea-programmatically/#entire-code-listing","text":"If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Add the default protocol (assuming it is present in the local directory 'packages') builder . add_protocol ( \"./packages/fetchai/protocols/default\" ) # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"build-aea-step-by-step/","text":"Building an AEA step by step (ensure you have followed the Preliminaries and Installation sections from the AEA quick start first): Set up your AEA project with the CLI: aea create my_aea && cd my_aea Look at, then add the right connections for your use case: aea search connections , then aea add connection [public_id] Look for, then add or generate the protocols you require: aea search protocols , then aea add protocol [public_id] or aea generate protocol [path_to_specification] Look for, then add or code the skills you need: aea search skills , then aea add skill [public_id] . This guide shows you step by step how to develop a skill. Where required, scaffold any of the above resources with the scaffolding tool or generate a protocol with the protocol generator . Now, run your AEA: aea run --connections [public_id] See information on the CLI tool here for all the available commands.","title":"Build an AEA with the CLI"},{"location":"cli-commands/","text":"CLI commands Command Description add [package_type] [public_id] Add a package_type connection, contract, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key [ledger_id] file [--connection] Add a private key from a file for ledger_id . build Build the agent and its components. config get [path] Reads the configuration specified in path and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the path . Optionally cast to type. create [name] Create a new AEA project called name . delete [name] Delete an AEA project. See below for disabling a resource. eject [package_type] [public_id] Move a package of package_type and package_id from vendor to project working directory. fetch [public_id] Fetch an AEA project with public_id . fetch --local to fetch from local packages directory. fingerprint [package_type] [public_id] Fingerprint connection, contract, protocol, or skill, with public_id . freeze Get all the dependencies needed for the AEA project and its components. generate protocol [protocol_spec_path] Generate a protocol from the specification. generate-all-protocols Generate all protocols. generate-key [ledger_id] Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth [ledger_id] Generate wealth for address on test network. get-address [ledger_id] Get the address associated with the private key. get-multiaddress [ledger_id]... Get the multiaddress associated with a private key or connection. get-public-key [ledger_id]... Get the public key associated with a private key of the agent. get-wealth [ledger_id] Get the wealth associated with the private key. hash [command] [options] Hashing utils init Initialize your AEA configurations. (With --author to define author.) install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) ipfs IPFS Commands issue-certificates Issue the connection certificates. launch [path_to_agent_project]... Launch many agents at the same time. list [package_type] List the installed resources. local-registry-sync Upgrade the local package registry. login USERNAME [--password password] Login to a registry account with credentials. logout Logout from registry account. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push [package_type] [public_id] Push connection, protocol, or skill with public_id to registry. push --local to push to local packages directory. register Create a new registry account. remove [package_type] [name] Remove connection, protocol, or skill, called name , from AEA. remove-key [ledger_id] [name] Remove a private key registered with id ledger_id . reset_password EMAIL Reset the password of the registry account. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. scaffold [package_type] [name] Scaffold a new connection, protocol, or skill called name . search [package_type] Search for components in the registry. search --local [package_type] [--query searching_query] to search in local packages directory. transfer [type] [address] [amount] Transfer wealth associated with a private key of the agent to another account. upgrade [package_type] [public_id] Upgrade the packages of the agent. -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag --skip-consistency-check . E.g. aea --skip-consistency-check run will bypass the fingerprint checks.","title":"Commands"},{"location":"cli-commands/#cli-commands","text":"Command Description add [package_type] [public_id] Add a package_type connection, contract, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key [ledger_id] file [--connection] Add a private key from a file for ledger_id . build Build the agent and its components. config get [path] Reads the configuration specified in path and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the path . Optionally cast to type. create [name] Create a new AEA project called name . delete [name] Delete an AEA project. See below for disabling a resource. eject [package_type] [public_id] Move a package of package_type and package_id from vendor to project working directory. fetch [public_id] Fetch an AEA project with public_id . fetch --local to fetch from local packages directory. fingerprint [package_type] [public_id] Fingerprint connection, contract, protocol, or skill, with public_id . freeze Get all the dependencies needed for the AEA project and its components. generate protocol [protocol_spec_path] Generate a protocol from the specification. generate-all-protocols Generate all protocols. generate-key [ledger_id] Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth [ledger_id] Generate wealth for address on test network. get-address [ledger_id] Get the address associated with the private key. get-multiaddress [ledger_id]... Get the multiaddress associated with a private key or connection. get-public-key [ledger_id]... Get the public key associated with a private key of the agent. get-wealth [ledger_id] Get the wealth associated with the private key. hash [command] [options] Hashing utils init Initialize your AEA configurations. (With --author to define author.) install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) ipfs IPFS Commands issue-certificates Issue the connection certificates. launch [path_to_agent_project]... Launch many agents at the same time. list [package_type] List the installed resources. local-registry-sync Upgrade the local package registry. login USERNAME [--password password] Login to a registry account with credentials. logout Logout from registry account. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push [package_type] [public_id] Push connection, protocol, or skill with public_id to registry. push --local to push to local packages directory. register Create a new registry account. remove [package_type] [name] Remove connection, protocol, or skill, called name , from AEA. remove-key [ledger_id] [name] Remove a private key registered with id ledger_id . reset_password EMAIL Reset the password of the registry account. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. scaffold [package_type] [name] Scaffold a new connection, protocol, or skill called name . search [package_type] Search for components in the registry. search --local [package_type] [--query searching_query] to search in local packages directory. transfer [type] [address] [amount] Transfer wealth associated with a private key of the agent to another account. upgrade [package_type] [public_id] Upgrade the packages of the agent. -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag --skip-consistency-check . E.g. aea --skip-consistency-check run will bypass the fingerprint checks.","title":"CLI commands"},{"location":"cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA CLI package. pip install aea [ cli ] The following installs the entire AEA package including the CLI. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Be sure that the bin folder of your Python environment is in the PATH variable. If so, you can execute the CLI tool as: aea You might find useful the execution of the aea.cli package as a script: python -m aea.cli which is just an alternative entry-point to the CLI tool. Troubleshooting To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Installation"},{"location":"cli-how-to/#installation","text":"The following installs the AEA CLI package. pip install aea [ cli ] The following installs the entire AEA package including the CLI. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Be sure that the bin folder of your Python environment is in the PATH variable. If so, you can execute the CLI tool as: aea You might find useful the execution of the aea.cli package as a script: python -m aea.cli which is just an alternative entry-point to the CLI tool.","title":"Installation"},{"location":"cli-how-to/#troubleshooting","text":"To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Troubleshooting"},{"location":"config/","text":"This document describes the configuration files of the different packages. AEA configuration YAML The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsory components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.21.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:1.0.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.17.0 default_connection : fetchai/p2p_libp2p:0.25.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) required_ledgers : [ fetchai ] # the list of identifiers of ledgers that the AEA project requires key pairs for (each item must satisfy LEDGER_ID_REGEX) default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) connection_private_key_paths : # The private key paths the AEA project uses for its connections (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 dependencies : {} # The python dependencies the AEA relies on (e.g. plugins). They will be installed when `aea install` is run. The aea-config.yaml can be extended with a number of optional fields: period : 0.05 # The period to call agent's act execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") connection_exception_policy : propagate # The exception policy applied to connections (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") loop_mode : async # The agent loop mode (must be one of \"sync\" or \"async\") runtime_mode : threaded # The runtime mode (must be one of \"threaded\" or \"async\") and determines how agent loop and multiplexer are run error_handler : None # The error handler to be used. decision_maker_handler : None # The decision maker handler to be used. storage_uri : None # The URI to the storage. data_dir : None # The path to the directory for local files. Defaults to current working directory. The aea-config.yaml can further be extended with component configuration overrides. For custom connection configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : connection # for connections, this must be \"connection\". config : ... # a dictionary to overwrite the `config` field (see below) For custom skill configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : skill # for skills, this must be \"skill\". behaviours : # override configurations for behaviours behaviour_1 : # override configurations for \"behaviour_1\" args : # arguments for a specific behaviour (see below) foo : bar handlers : # override configurations for handlers handler_1 : # override configurations for \"handler_1\" args : # arguments for a specific handler (see below) foo : bar models : # override configurations for models model_1 : # override configurations for \"model_1\" args : # arguments for a specific model (see below) foo : bar Connection configuration YAML The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : connection # The type of the package; for connections, it must be \"connection\" description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : [] # The list of connection public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. is_abstract : false # An optional boolean that if `true` makes the connection Contract configuration YAML The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : contract # The type of the package; for contracts, it must be \"contract\" description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. contract_interface_paths : {} # The paths to the contract interfaces (one for each ledger identifier). config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. Protocol configuration YAML The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : protocol # The type of the package; for protocols, it must be \"protocol\" description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. Skill configuration YAML The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : skill # The type of the package; for skills, it must be \"skill\" description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). skills : [] # The list of skill public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). is_abstract : false # An optional boolean that if `true` makes the skill abstract, i.e. not instantiated by the framework but importable from other skills. Defaults to `false`. behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Configurations"},{"location":"config/#aea-configuration-yaml","text":"The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsory components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.21.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:1.0.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.17.0 default_connection : fetchai/p2p_libp2p:0.25.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) required_ledgers : [ fetchai ] # the list of identifiers of ledgers that the AEA project requires key pairs for (each item must satisfy LEDGER_ID_REGEX) default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) connection_private_key_paths : # The private key paths the AEA project uses for its connections (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 dependencies : {} # The python dependencies the AEA relies on (e.g. plugins). They will be installed when `aea install` is run. The aea-config.yaml can be extended with a number of optional fields: period : 0.05 # The period to call agent's act execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") connection_exception_policy : propagate # The exception policy applied to connections (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") loop_mode : async # The agent loop mode (must be one of \"sync\" or \"async\") runtime_mode : threaded # The runtime mode (must be one of \"threaded\" or \"async\") and determines how agent loop and multiplexer are run error_handler : None # The error handler to be used. decision_maker_handler : None # The decision maker handler to be used. storage_uri : None # The URI to the storage. data_dir : None # The path to the directory for local files. Defaults to current working directory. The aea-config.yaml can further be extended with component configuration overrides. For custom connection configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : connection # for connections, this must be \"connection\". config : ... # a dictionary to overwrite the `config` field (see below) For custom skill configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : skill # for skills, this must be \"skill\". behaviours : # override configurations for behaviours behaviour_1 : # override configurations for \"behaviour_1\" args : # arguments for a specific behaviour (see below) foo : bar handlers : # override configurations for handlers handler_1 : # override configurations for \"handler_1\" args : # arguments for a specific handler (see below) foo : bar models : # override configurations for models model_1 : # override configurations for \"model_1\" args : # arguments for a specific model (see below) foo : bar","title":"AEA configuration YAML"},{"location":"config/#connection-configuration-yaml","text":"The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : connection # The type of the package; for connections, it must be \"connection\" description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : [] # The list of connection public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. is_abstract : false # An optional boolean that if `true` makes the connection","title":"Connection configuration YAML"},{"location":"config/#contract-configuration-yaml","text":"The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : contract # The type of the package; for contracts, it must be \"contract\" description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. contract_interface_paths : {} # The paths to the contract interfaces (one for each ledger identifier). config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Contract configuration YAML"},{"location":"config/#protocol-configuration-yaml","text":"The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : protocol # The type of the package; for protocols, it must be \"protocol\" description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Protocol configuration YAML"},{"location":"config/#skill-configuration-yaml","text":"The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : skill # The type of the package; for skills, it must be \"skill\" description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). skills : [] # The list of skill public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). is_abstract : false # An optional boolean that if `true` makes the skill abstract, i.e. not instantiated by the framework but importable from other skills. Defaults to `false`. behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Skill configuration YAML"},{"location":"connect-a-frontend/","text":"This page lays out two options for connecting a front-end to an AEA. The following diagram illustrates these two options. Case 1 The first option is to create a HTTP Server connection that handles incoming requests from a REST API. In this scenario, the REST API communicates with the AEA and requests are handled by the HTTP Server connection package. The REST API should send CRUD requests to the HTTP Server connection ( fetchai/http_server:0.22.0 ) which translates these into Envelopes to be consumed by the correct skill. Case 2 The second option is to create a front-end comprising a stand-alone Multiplexer with a P2P connection ( fetchai/p2p_libp2p:0.25.0 ). In this scenario the Agent Communication Network can be used to send Envelopes from the AEA to the front-end.","title":"Front-end intergration"},{"location":"connect-a-frontend/#case-1","text":"The first option is to create a HTTP Server connection that handles incoming requests from a REST API. In this scenario, the REST API communicates with the AEA and requests are handled by the HTTP Server connection package. The REST API should send CRUD requests to the HTTP Server connection ( fetchai/http_server:0.22.0 ) which translates these into Envelopes to be consumed by the correct skill.","title":"Case 1"},{"location":"connect-a-frontend/#case-2","text":"The second option is to create a front-end comprising a stand-alone Multiplexer with a P2P connection ( fetchai/p2p_libp2p:0.25.0 ). In this scenario the Agent Communication Network can be used to send Envelopes from the AEA to the front-end.","title":"Case 2"},{"location":"connection/","text":"A Connection provides an interface for the agent to connect with entities in the outside world. Connections wrap SDKs or APIs and provide interfaces to networks, ledgers and other services. As such, a connection is concerned with I/O bound and continuously connected operations. Where necessary, a connection is responsible for translating between the framework specific protocol (an Envelope with its contained Message ) and the external service or third-party protocol (e.g. HTTP ). Hence, there are two roles for connections: wrapper and transport connection. The transport connection is responsible to delivering AEA envelopes. The messages constructed or received by a connection are eventually processed by one or several skills which deal with handling and generating messages related to a specific business objective. An AEA can interact with multiple connections at the same time via the Multiplexer . Connections are passive in terms of multiplexer interactions (its methods are called by the Multiplexer), but they can run their own asynchronous or threaded tasks. The Multiplexer maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing envelopes and their contained messages. Developing your connection The easiest way to get started developing your own connection is by using the scaffold command: aea scaffold connection my_new_connection This will scaffold a connection package called my_new_connection with three files: __init__.py connection.py containing the scaffolded connection class connection.yaml containing the scaffolded configuration file As a developer you have the choice between implementing a sync or asynchronous interface. The scaffolded connection.py file contains two classes: the MyScaffoldAsyncConnection inherited from the Connection base class and the MyScaffoldSyncConnection inherited from the BaseSyncConnection . Remove the unused class. Primary methods to develop - asynchronous connection interface The developer needs to implement four public coroutines: The connect coroutine implements the setup logic required to be performed for the connection when it is initially launched. The connect coroutine is called by the AEA framework once when the agent is being started. The disconnect coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The disconnect coroutine is called by the AEA framework once when the agent is being stopped. The send coroutine is called by the AEA framework each time the Multiplexer handles an outgoing envelope specified to be handled by this connection. The send coroutine must implement the processing of the envelope leaving the agent. The receive coroutine is continuously called by the AEA framework. It either returns None or an envelope. The receive coroutine must implement the logic of data being received by the agent, and if necessary, its translation into a relevant protocol. The framework provides a demo stub connection which implements an I/O reader and writer to send and receive messages between the agent and a local file. To gain inspiration and become familiar with the structure of connection packages, you may find it useful to check out fetchai/stub:0.21.0 , fetchai/http_server:0.22.0 or fetchai/http_client:0.23.0 connections. The latter two connections are for external clients to connect with an agent, and for the agent to connect with external servers, respectively. Primary methods to develop - sync connection interface The BaseSyncConnection uses executors to execute synchronous code from the asynchronous context of the Multiplexer in executors/threads, which are limited by the amount of configured workers. The asynchronous methods connect , disconnect and send are converted to callbacks which the developer implements: * on_connect * on_disconnect * on_send All of these methods will be executed in the executor pool. Every method can create a message by putting it into the thread/asynchronous friendly queue that is consumed by the Multiplexer . The receive coroutine has no direct equivalent. Instead, the developer implements a main method which runs synchronously in the background. Configuration Every connection must have a configuration file in connection.yaml , containing meta-information about the connection as well as all the required configuration details. For more details, have a look here . Configuration options The connection.yaml file contains a number of fields that must be edited by the developer of the connection: connections : [] protocols : [] class_name : MyScaffoldConnection config : foo : bar excluded_protocols : [] restricted_to_protocols : [] dependencies : {} is_abstract : false cert_requests : [] connections specifies the list of other connection this connection depends on protocols specifies the list of protocols this connection depends on class_name needs to match the name of the connection class in connection.py config can contain arbitrary configuration information which is made available in the constructor of the connection as keyword arguments ( **kwargs ) excluded_protocols lists the protocols which cannot be used in this connection restricted_to_protocols lists the protocols which this connection is restricted to be used by dependencies lists any Python dependencies of the connection package is_abstract specifies whether this connection is only used as an abstract base class cert_requests lists certification requests of the connection (see proof of representation for details)","title":"Connections"},{"location":"connection/#developing-your-connection","text":"The easiest way to get started developing your own connection is by using the scaffold command: aea scaffold connection my_new_connection This will scaffold a connection package called my_new_connection with three files: __init__.py connection.py containing the scaffolded connection class connection.yaml containing the scaffolded configuration file As a developer you have the choice between implementing a sync or asynchronous interface. The scaffolded connection.py file contains two classes: the MyScaffoldAsyncConnection inherited from the Connection base class and the MyScaffoldSyncConnection inherited from the BaseSyncConnection . Remove the unused class.","title":"Developing your connection"},{"location":"connection/#primary-methods-to-develop-asynchronous-connection-interface","text":"The developer needs to implement four public coroutines: The connect coroutine implements the setup logic required to be performed for the connection when it is initially launched. The connect coroutine is called by the AEA framework once when the agent is being started. The disconnect coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The disconnect coroutine is called by the AEA framework once when the agent is being stopped. The send coroutine is called by the AEA framework each time the Multiplexer handles an outgoing envelope specified to be handled by this connection. The send coroutine must implement the processing of the envelope leaving the agent. The receive coroutine is continuously called by the AEA framework. It either returns None or an envelope. The receive coroutine must implement the logic of data being received by the agent, and if necessary, its translation into a relevant protocol. The framework provides a demo stub connection which implements an I/O reader and writer to send and receive messages between the agent and a local file. To gain inspiration and become familiar with the structure of connection packages, you may find it useful to check out fetchai/stub:0.21.0 , fetchai/http_server:0.22.0 or fetchai/http_client:0.23.0 connections. The latter two connections are for external clients to connect with an agent, and for the agent to connect with external servers, respectively.","title":"Primary methods to develop - asynchronous connection interface"},{"location":"connection/#primary-methods-to-develop-sync-connection-interface","text":"The BaseSyncConnection uses executors to execute synchronous code from the asynchronous context of the Multiplexer in executors/threads, which are limited by the amount of configured workers. The asynchronous methods connect , disconnect and send are converted to callbacks which the developer implements: * on_connect * on_disconnect * on_send All of these methods will be executed in the executor pool. Every method can create a message by putting it into the thread/asynchronous friendly queue that is consumed by the Multiplexer . The receive coroutine has no direct equivalent. Instead, the developer implements a main method which runs synchronously in the background.","title":"Primary methods to develop - sync connection interface"},{"location":"connection/#configuration","text":"Every connection must have a configuration file in connection.yaml , containing meta-information about the connection as well as all the required configuration details. For more details, have a look here .","title":"Configuration"},{"location":"connection/#configuration-options","text":"The connection.yaml file contains a number of fields that must be edited by the developer of the connection: connections : [] protocols : [] class_name : MyScaffoldConnection config : foo : bar excluded_protocols : [] restricted_to_protocols : [] dependencies : {} is_abstract : false cert_requests : [] connections specifies the list of other connection this connection depends on protocols specifies the list of protocols this connection depends on class_name needs to match the name of the connection class in connection.py config can contain arbitrary configuration information which is made available in the constructor of the connection as keyword arguments ( **kwargs ) excluded_protocols lists the protocols which cannot be used in this connection restricted_to_protocols lists the protocols which this connection is restricted to be used by dependencies lists any Python dependencies of the connection package is_abstract specifies whether this connection is only used as an abstract base class cert_requests lists certification requests of the connection (see proof of representation for details)","title":"Configuration options"},{"location":"contract/","text":"Contracts wrap smart contracts for Fetch.ai and third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract and its byte code. They implement a translation between framework messages (in the fetchai/contract_api:1.0.0 protocol) and the implementation specifics of the ABI. Contracts usually implement four types of methods: a method to create a smart contract deployment transaction, methods to create transactions to modify state in the deployed smart contract, methods to create contract calls to execute static methods on the deployed smart contract, and methods to query the state of the deployed smart contract. Contracts can be added as packages which means they become reusable across AEA projects. The smart contract wrapped in a AEA contract package might be a third-party smart contract or your own smart contract potentially interacting with a third-party contract on-chain. Interacting with contracts from skills Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a Connection . In particular, the fetchai/ledger:0.19.0 connection can be used to execute contract related logic. The skills communicate with the fetchai/ledger:0.19.0 connection via the fetchai/contract_api:1.0.0 protocol. This protocol implements a request-response pattern to serve the four types of methods listed above: the get_deploy_transaction message is used to request a deploy transaction for a specific contract. For instance, to request a deploy transaction for the deployment of the smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_DEPLOY_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , callable = \"get_deploy_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address } ), ) Any additional arguments needed by the contract's constructor method should be added to kwargs . This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. For details on how to implement the message handling, see the handlers in the erc1155_deploy skill. CosmWasm based smart contract deployments When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times. Both the store and init messages use the ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an init transaction requires the keyword arguments code_id (integer), label (string), amount (integer) and init_msg (JSON). For an example look at the fetchai/erc1155:0.22.0 package. the get_raw_transaction message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_create_batch_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address , \"token_ids\" : strategy . token_ids , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_create_batch_transaction method with the specified key word arguments (see example in Deploy your own , below). Similarly to above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. the get_raw_message message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_MESSAGE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_hash_single\" , kwargs = ContractApiMessage . Kwargs ( { \"from_address\" : from_address , \"to_address\" : to_address , \"token_id\" : token_id , \"from_supply\" : from_supply , \"to_supply\" : to_supply , \"value\" : value , \"trade_nonce\" : trade_nonce , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_message message will be returned with the matching raw message. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_hash_single method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required. the get_state message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_STATE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_balance\" , kwargs = ContractApiMessage . Kwargs ( { \"agent_address\" : address , \"token_id\" : token_id } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a state message will be returned with the matching state. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_balance method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required. Developing your own The easiest way to get started developing your own contract is by using the scaffold command: aea scaffold contract my_new_contract This will scaffold a contract package called my_new_contract with three files: __init__.py contract.py , containing the scaffolded contract class contract.yaml containing the scaffolded configuration file Once your scaffold is in place, you can create a build folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the contract.yaml . For instance, if you use Ethereum, then you might specify the following: contract_interface_paths : ethereum : build/my_contract.json where ethereum is the ledger id and my_contract.json is the file containing the byte code and ABI. Finally, you will want to implement the part of the contract interface you need in contract.py : from aea.contracts.base import Contract from aea.crypto.base import LedgerApi class MyContract ( Contract ): \"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\" @classmethod def get_create_batch_transaction ( cls , ledger_api : LedgerApi , contract_address : str , deployer_address : str , token_ids : List [ int ], data : Optional [ bytes ] = b \"\" , gas : int = 300000 , ) -> Dict [ str , Any ]: \"\"\" Get the transaction to create a batch of tokens. :param ledger_api: the ledger API :param contract_address: the address of the contract :param deployer_address: the address of the deployer :param token_ids: the list of token ids for creation :param data: the data to include in the transaction :param gas: the gas to be used :return: the transaction object \"\"\" # create the transaction dict nonce = ledger_api . api . eth . get_transaction_count ( deployer_address ) instance = cls . get_instance ( ledger_api , contract_address ) tx = instance . functions . createBatch ( deployer_address , token_ids ) . buildTransaction ( { \"gas\" : gas , \"gasPrice\" : ledger_api . api . toWei ( \"50\" , \"gwei\" ), \"nonce\" : nonce , } ) tx = cls . _try_estimate_gas ( ledger_api , tx ) return tx Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the fetchai/ledger:0.19.0 connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the deployer_address , then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction. It helps to look at existing contract packages, like fetchai/erc1155:0.22.0 , and skills using them, like fetchai/erc1155_client:0.11.0 and fetchai/erc1155_deploy:0.30.0 , for inspiration and guidance.","title":"Contracts"},{"location":"contract/#interacting-with-contracts-from-skills","text":"Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a Connection . In particular, the fetchai/ledger:0.19.0 connection can be used to execute contract related logic. The skills communicate with the fetchai/ledger:0.19.0 connection via the fetchai/contract_api:1.0.0 protocol. This protocol implements a request-response pattern to serve the four types of methods listed above: the get_deploy_transaction message is used to request a deploy transaction for a specific contract. For instance, to request a deploy transaction for the deployment of the smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_DEPLOY_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , callable = \"get_deploy_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address } ), ) Any additional arguments needed by the contract's constructor method should be added to kwargs . This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. For details on how to implement the message handling, see the handlers in the erc1155_deploy skill. CosmWasm based smart contract deployments When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times. Both the store and init messages use the ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an init transaction requires the keyword arguments code_id (integer), label (string), amount (integer) and init_msg (JSON). For an example look at the fetchai/erc1155:0.22.0 package. the get_raw_transaction message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_create_batch_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address , \"token_ids\" : strategy . token_ids , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_create_batch_transaction method with the specified key word arguments (see example in Deploy your own , below). Similarly to above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. the get_raw_message message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_MESSAGE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_hash_single\" , kwargs = ContractApiMessage . Kwargs ( { \"from_address\" : from_address , \"to_address\" : to_address , \"token_id\" : token_id , \"from_supply\" : from_supply , \"to_supply\" : to_supply , \"value\" : value , \"trade_nonce\" : trade_nonce , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_message message will be returned with the matching raw message. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_hash_single method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required. the get_state message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_STATE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_balance\" , kwargs = ContractApiMessage . Kwargs ( { \"agent_address\" : address , \"token_id\" : token_id } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a state message will be returned with the matching state. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_balance method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required.","title":"Interacting with contracts from skills"},{"location":"contract/#developing-your-own","text":"The easiest way to get started developing your own contract is by using the scaffold command: aea scaffold contract my_new_contract This will scaffold a contract package called my_new_contract with three files: __init__.py contract.py , containing the scaffolded contract class contract.yaml containing the scaffolded configuration file Once your scaffold is in place, you can create a build folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the contract.yaml . For instance, if you use Ethereum, then you might specify the following: contract_interface_paths : ethereum : build/my_contract.json where ethereum is the ledger id and my_contract.json is the file containing the byte code and ABI. Finally, you will want to implement the part of the contract interface you need in contract.py : from aea.contracts.base import Contract from aea.crypto.base import LedgerApi class MyContract ( Contract ): \"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\" @classmethod def get_create_batch_transaction ( cls , ledger_api : LedgerApi , contract_address : str , deployer_address : str , token_ids : List [ int ], data : Optional [ bytes ] = b \"\" , gas : int = 300000 , ) -> Dict [ str , Any ]: \"\"\" Get the transaction to create a batch of tokens. :param ledger_api: the ledger API :param contract_address: the address of the contract :param deployer_address: the address of the deployer :param token_ids: the list of token ids for creation :param data: the data to include in the transaction :param gas: the gas to be used :return: the transaction object \"\"\" # create the transaction dict nonce = ledger_api . api . eth . get_transaction_count ( deployer_address ) instance = cls . get_instance ( ledger_api , contract_address ) tx = instance . functions . createBatch ( deployer_address , token_ids ) . buildTransaction ( { \"gas\" : gas , \"gasPrice\" : ledger_api . api . toWei ( \"50\" , \"gwei\" ), \"nonce\" : nonce , } ) tx = cls . _try_estimate_gas ( ledger_api , tx ) return tx Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the fetchai/ledger:0.19.0 connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the deployer_address , then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction. It helps to look at existing contract packages, like fetchai/erc1155:0.22.0 , and skills using them, like fetchai/erc1155_client:0.11.0 and fetchai/erc1155_deploy:0.30.0 , for inspiration and guidance.","title":"Developing your own"},{"location":"core-components-1/","text":"The AEA framework consists of several core components, some required to run an AEA and others optional. The following sections discuss the inner workings of the AEA framework and how it calls the code in custom packages (see inversion of control and a helpful comparison here ). While it is in principle possible to use parts of the framework as a library, we do not recommend it. The elements each AEA uses Envelope AEAs communicate asynchronously via exchange of Messages wrapped in Envelopes containing five attributes: to : defines the destination address. sender : defines the sender address. protocol_specification_id : defines the id of the Protocol . message : is a bytes field which holds the Message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Messages must adhere to a Protocol . Protocol Protocols define agent-to-agent as well as component-to-component interactions within AEAs. As such, they include: Messages defining the syntax of messages; Serialization defining how a Message is encoded for transport; and, optionally Dialogues , which define rules over Message sequences. The framework provides one default Protocol , called signing (current version open_aea/signing:1.0.0 ). This Protocol provides an implementation for an AEA Protocol which includes a SigningMessage class and associated SigningSerializer and SigningDialogue classes. Additional Protocols , for new types of interactions, can be added as packages. For more details on Protocols you can read the protocol guide . To learn how you can easily automate protocol definition, head to the guide for the protocol generator . Protocol specific Messages , wrapped in Envelopes , are sent and received to other agents, agent components and services via Connections . Connection A Connection wraps an SDK or API and provides an interface to networks, ledgers or other services. Where necessary, a Connection is responsible for translating between the framework-specific Envelope with its Message and the external service or third-party protocol (e.g. HTTP ). The framework provides one default Connection , called stub (current version fetchai/stub:0.21.0 ). It implements an I/O reader and writer to send Messages to the agent from a local file. Additional Connections can be added as packages. For more details on Connections read the Connection guide . An AEA runs and manages Connections via a Multiplexer . Multiplexer The Multiplexer is responsible for maintaining (potentially multiple) Connections . It maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing Envelopes from the perspective of Skills . Skill Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A Skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each Skill has zero, one or more Handler objects. There is a one-to-one correspondence between Handlers and the protocols in an AEA (also known as the registered protocols ). Handlers implement AEAs' reactive behaviour. If an AEA understands a Protocol referenced in a received Envelope (i.e. the protocol is registered in this AEA), this envelope is sent to the corresponding Handler which executes the AEA's reaction to this Message . Behaviour : a skill can have zero, one or more Behaviours , each encapsulating actions which further the AEAs goal and are initiated by internals of the AEA rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of simple and composite behaviours (e.g. cyclic, one-shot, finite-state-machine, etc), and these define how often and in what order a behaviour and its sub-behaviours must be executed. Model : zero, one or more Models that inherit from the Model abstract base class and are accessible via the SkillContext . Task : zero, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of Skills , but Tasks are declared in or from Skills if a packaging approach for AEA creation is used. A Skill can read (parts of) an AEA's state (as summarised in the AgentContext ), and suggests actions to the AEA according to its specific logic. As such, more than one Skill could exist per Protocol , competing with each other in suggesting to the AEA the best course of actions to take. In technical terms, this means Skills are horizontally arranged. For instance, an AEA which is trading goods, could subscribe to more than one Skill , where each corresponds to a different trading strategy. The framework places no limits on the complexity of Skills . They can implement simple (e.g. if-this-then-that ) logic or be complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default Skill , called error . Additional Skills can be added as packages. For more details on Skills head over to the Skill guide . Agent loop The AgentLoop performs a series of activities while the AEA state is not stopped . it calls the act() function of all active registered Behaviours at their respective tick rate. it grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the Protocol of the Envelope . it dispatches the internal Messages from the decision maker (described below) to the handler in the relevant Skill . The AgentLoop and Multiplexer are decoupled via the InBox and OutBox , and both are maintained by the Runtime . Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: AEA and web frameworks Relevant deep-dives Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Core components - Part 1"},{"location":"core-components-1/#the-elements-each-aea-uses","text":"","title":"The elements each AEA uses"},{"location":"core-components-1/#envelope","text":"AEAs communicate asynchronously via exchange of Messages wrapped in Envelopes containing five attributes: to : defines the destination address. sender : defines the sender address. protocol_specification_id : defines the id of the Protocol . message : is a bytes field which holds the Message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Messages must adhere to a Protocol .","title":"Envelope"},{"location":"core-components-1/#protocol","text":"Protocols define agent-to-agent as well as component-to-component interactions within AEAs. As such, they include: Messages defining the syntax of messages; Serialization defining how a Message is encoded for transport; and, optionally Dialogues , which define rules over Message sequences. The framework provides one default Protocol , called signing (current version open_aea/signing:1.0.0 ). This Protocol provides an implementation for an AEA Protocol which includes a SigningMessage class and associated SigningSerializer and SigningDialogue classes. Additional Protocols , for new types of interactions, can be added as packages. For more details on Protocols you can read the protocol guide . To learn how you can easily automate protocol definition, head to the guide for the protocol generator . Protocol specific Messages , wrapped in Envelopes , are sent and received to other agents, agent components and services via Connections .","title":"Protocol"},{"location":"core-components-1/#connection","text":"A Connection wraps an SDK or API and provides an interface to networks, ledgers or other services. Where necessary, a Connection is responsible for translating between the framework-specific Envelope with its Message and the external service or third-party protocol (e.g. HTTP ). The framework provides one default Connection , called stub (current version fetchai/stub:0.21.0 ). It implements an I/O reader and writer to send Messages to the agent from a local file. Additional Connections can be added as packages. For more details on Connections read the Connection guide . An AEA runs and manages Connections via a Multiplexer .","title":"Connection"},{"location":"core-components-1/#multiplexer","text":"The Multiplexer is responsible for maintaining (potentially multiple) Connections . It maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing Envelopes from the perspective of Skills .","title":"Multiplexer"},{"location":"core-components-1/#skill","text":"Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A Skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each Skill has zero, one or more Handler objects. There is a one-to-one correspondence between Handlers and the protocols in an AEA (also known as the registered protocols ). Handlers implement AEAs' reactive behaviour. If an AEA understands a Protocol referenced in a received Envelope (i.e. the protocol is registered in this AEA), this envelope is sent to the corresponding Handler which executes the AEA's reaction to this Message . Behaviour : a skill can have zero, one or more Behaviours , each encapsulating actions which further the AEAs goal and are initiated by internals of the AEA rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of simple and composite behaviours (e.g. cyclic, one-shot, finite-state-machine, etc), and these define how often and in what order a behaviour and its sub-behaviours must be executed. Model : zero, one or more Models that inherit from the Model abstract base class and are accessible via the SkillContext . Task : zero, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of Skills , but Tasks are declared in or from Skills if a packaging approach for AEA creation is used. A Skill can read (parts of) an AEA's state (as summarised in the AgentContext ), and suggests actions to the AEA according to its specific logic. As such, more than one Skill could exist per Protocol , competing with each other in suggesting to the AEA the best course of actions to take. In technical terms, this means Skills are horizontally arranged. For instance, an AEA which is trading goods, could subscribe to more than one Skill , where each corresponds to a different trading strategy. The framework places no limits on the complexity of Skills . They can implement simple (e.g. if-this-then-that ) logic or be complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default Skill , called error . Additional Skills can be added as packages. For more details on Skills head over to the Skill guide .","title":"Skill"},{"location":"core-components-1/#agent-loop","text":"The AgentLoop performs a series of activities while the AEA state is not stopped . it calls the act() function of all active registered Behaviours at their respective tick rate. it grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the Protocol of the Envelope . it dispatches the internal Messages from the decision maker (described below) to the handler in the relevant Skill . The AgentLoop and Multiplexer are decoupled via the InBox and OutBox , and both are maintained by the Runtime .","title":"Agent loop"},{"location":"core-components-1/#next-steps","text":"","title":"Next steps"},{"location":"core-components-1/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: AEA and web frameworks","title":"Recommended"},{"location":"core-components-1/#relevant-deep-dives","text":"Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Relevant deep-dives"},{"location":"core-components-2/","text":"The AEA framework consists of several core components, some required to run an AEA and others optional. In Core Components - Part 1 we described the common components each AEA uses. In this page, we will look at more advanced components. Required components used by AEAs Decision Maker The DecisionMaker can be thought of as a Wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component with access to the Wallet 's private keys. You can learn more about the decision maker here . In its simplest form, the decision maker acts like a Wallet with Handler to react to messages it receives from the skills. Wallet The Wallet contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does. The agent has two sets of private keys, as configured in the aea-config.yaml : private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in the AEA. For each identifier, e.g. fetchai , the AEA can have one private key. The private keys listed here are available in the Decision Maker and the associated public keys and addresses are available in all skills. The AEA uses these keys to sign transactions and messages. These keys usually hold the AEAs funds. connection_private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in connections. For each identifier, e.g. fetchai , the Multiplexer can have one private key. The private keys listed here are available in the connections. The connections use these keys to secure message transport, for instance. It is the responsibility of the AEA's user to safe-guard the keys used and ensure that keys are only used in a single AEA. Using the same key across different AEAs will lead to various failure modes. Private keys can be encrypted at rest. The CLI commands used for interacting with the wallet allow specifying a password for encryption/decryption. Identity The Identity is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name. The identity can be accessed in a Skill via the AgentContext . Optional components used by AEAs Contracts Contracts wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the Skills . Contracts usually contain the logic to create contract transactions and make contract calls. Contracts can be added as packages. For more details on Contracts also read the Contract guide here . Putting it together Taken together, the core components from this section and the first part provide the following simplified illustration of an AEA: Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: How AEAs talk to each other - Interaction protocols Relevant deep-dives Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the DecisionMaker in the following section: Decision Maker Understanding Contracts is important when developing AEAs that make commitments or use smart contracts for other purposes. You can learn more about the Contracts agents use in the following section: Contracts","title":"Core components - Part 2"},{"location":"core-components-2/#required-components-used-by-aeas","text":"","title":"Required components used by AEAs"},{"location":"core-components-2/#decision-maker","text":"The DecisionMaker can be thought of as a Wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component with access to the Wallet 's private keys. You can learn more about the decision maker here . In its simplest form, the decision maker acts like a Wallet with Handler to react to messages it receives from the skills.","title":"Decision Maker"},{"location":"core-components-2/#wallet","text":"The Wallet contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does. The agent has two sets of private keys, as configured in the aea-config.yaml : private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in the AEA. For each identifier, e.g. fetchai , the AEA can have one private key. The private keys listed here are available in the Decision Maker and the associated public keys and addresses are available in all skills. The AEA uses these keys to sign transactions and messages. These keys usually hold the AEAs funds. connection_private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in connections. For each identifier, e.g. fetchai , the Multiplexer can have one private key. The private keys listed here are available in the connections. The connections use these keys to secure message transport, for instance. It is the responsibility of the AEA's user to safe-guard the keys used and ensure that keys are only used in a single AEA. Using the same key across different AEAs will lead to various failure modes. Private keys can be encrypted at rest. The CLI commands used for interacting with the wallet allow specifying a password for encryption/decryption.","title":"Wallet"},{"location":"core-components-2/#identity","text":"The Identity is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name. The identity can be accessed in a Skill via the AgentContext .","title":"Identity"},{"location":"core-components-2/#optional-components-used-by-aeas","text":"","title":"Optional components used by AEAs"},{"location":"core-components-2/#contracts","text":"Contracts wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the Skills . Contracts usually contain the logic to create contract transactions and make contract calls. Contracts can be added as packages. For more details on Contracts also read the Contract guide here .","title":"Contracts"},{"location":"core-components-2/#putting-it-together","text":"Taken together, the core components from this section and the first part provide the following simplified illustration of an AEA:","title":"Putting it together"},{"location":"core-components-2/#next-steps","text":"","title":"Next steps"},{"location":"core-components-2/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: How AEAs talk to each other - Interaction protocols","title":"Recommended"},{"location":"core-components-2/#relevant-deep-dives","text":"Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the DecisionMaker in the following section: Decision Maker Understanding Contracts is important when developing AEAs that make commitments or use smart contracts for other purposes. You can learn more about the Contracts agents use in the following section: Contracts","title":"Relevant deep-dives"},{"location":"debug/","text":"There are multiple ways in which to configure your AEA for debugging during development. We focus on the standard Python approach here. Using pdb stdlib You can add a debugger anywhere in your code: import pdb ; pdb . set_trace () Then simply run you AEA with the --skip-consistency-check mode: aea -s run For more guidance on how to use pdb check out the documentation . Using an IDE: For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV/bin/aea\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV should be replaced with the path to the virtual environment and CWD with the working directory for the agent to debug (where the aea-config.yaml file is).","title":"Debugging"},{"location":"debug/#using-pdb-stdlib","text":"You can add a debugger anywhere in your code: import pdb ; pdb . set_trace () Then simply run you AEA with the --skip-consistency-check mode: aea -s run For more guidance on how to use pdb check out the documentation .","title":"Using pdb stdlib"},{"location":"debug/#using-an-ide","text":"For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV/bin/aea\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV should be replaced with the path to the virtual environment and CWD with the working directory for the agent to debug (where the aea-config.yaml file is).","title":"Using an IDE:"},{"location":"decision-maker-transaction/","text":"This guide can be considered as a part 2 of the the stand-alone transaction demo . The main difference is that now we are going to use the decision-maker to sign the transaction. First, import the libraries and the set the constant values. (Get the packages directory from the AEA repository svn export https://github.com/valory-xyz/open-aea.git/trunk/packages .) import logging import time from threading import Thread from typing import Optional , cast from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.open_aea.protocols.signing.dialogues import SigningDialogue from packages.open_aea.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.open_aea.protocols.signing.message import SigningMessage from tests.conftest import get_wealth_if_needed logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" Create a private key and an AEA To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () Add a simple skill Add a simple skill with a signing handler and the signing dialogues. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) Create a second identity # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , ) Create the signing message Next, we are creating the signing message and we send it to the decision-maker. # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) Run the agent Finally, we are running the agent and we expect the signed transaction to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () After the completion of the signing, we get the signed transaction. More details To be able to register a handler that reads the internal messages, we have to create a class at the end of the file which processes the signing messages. class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.open_aea.protocols.signing.dialogues import SigningDialogue from packages.open_aea.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.open_aea.protocols.signing.message import SigningMessage from tests.conftest import get_wealth_if_needed logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , ) # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) if __name__ == \"__main__\" : run ()","title":"Create decision-maker transaction"},{"location":"decision-maker-transaction/#create-a-private-key-and-an-aea","text":"To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build ()","title":"Create a private key and an AEA"},{"location":"decision-maker-transaction/#add-a-simple-skill","text":"Add a simple skill with a signing handler and the signing dialogues. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill )","title":"Add a simple skill"},{"location":"decision-maker-transaction/#create-a-second-identity","text":"# create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , )","title":"Create a second identity"},{"location":"decision-maker-transaction/#create-the-signing-message","text":"Next, we are creating the signing message and we send it to the decision-maker. # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg )","title":"Create the signing message"},{"location":"decision-maker-transaction/#run-the-agent","text":"Finally, we are running the agent and we expect the signed transaction to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () After the completion of the signing, we get the signed transaction.","title":"Run the agent"},{"location":"decision-maker-transaction/#more-details","text":"To be able to register a handler that reads the internal messages, we have to create a class at the end of the file which processes the signing messages. class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.open_aea.protocols.signing.dialogues import SigningDialogue from packages.open_aea.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.open_aea.protocols.signing.message import SigningMessage from tests.conftest import get_wealth_if_needed logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , ) # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) if __name__ == \"__main__\" : run ()","title":"More details"},{"location":"decision-maker/","text":"The DecisionMaker can be thought of like a wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component which has access to the wallet's private keys. Interaction with skills Skills communicate with the decision maker via Messages . At present, the decision maker processes messages of two protocols: SigningMessage : it is used by skills to propose a transaction to the decision-maker for signing. A message, say msg , is sent to the decision maker like so from any skill: self.context.decision_maker_message_queue.put_nowait(msg) The decision maker processes messages and can accept or reject them. To process Messages from the decision maker in a given skill you need to create a Handler , in particular a SigningHandler like so: class SigningHandler ( Handler ): protocol_id = SigningMessage . protocol_id def handle ( self , message : Message ): \"\"\" Handle a signing message. :param message: the signing message from the decision maker. \"\"\" # code to handle the message Custom DecisionMaker The framework implements a default DecisionMakerHandler . You can also implement your own and mount it. No further configuration is needed to use the default. To use the advanced decision maker handler, add the following configuration to the aea-config.yaml of your AEA (on page 1): decision_maker_handler : config : {} dotted_path : \"aea.decision_maker.gop:DecisionMakerHandler\" file_path : null The easiest way to add a custom decision maker handler is to run the following command to scaffold a custom DecisionMakerHandler : aea scaffold decision-maker-handler You can then implement your own custom logic to process messages and interact with the Wallet . Note For examples how to use these concepts have a look at the tac_ skills. These functionalities are experimental and subject to change.","title":"Decision Maker"},{"location":"decision-maker/#interaction-with-skills","text":"Skills communicate with the decision maker via Messages . At present, the decision maker processes messages of two protocols: SigningMessage : it is used by skills to propose a transaction to the decision-maker for signing. A message, say msg , is sent to the decision maker like so from any skill: self.context.decision_maker_message_queue.put_nowait(msg) The decision maker processes messages and can accept or reject them. To process Messages from the decision maker in a given skill you need to create a Handler , in particular a SigningHandler like so: class SigningHandler ( Handler ): protocol_id = SigningMessage . protocol_id def handle ( self , message : Message ): \"\"\" Handle a signing message. :param message: the signing message from the decision maker. \"\"\" # code to handle the message","title":"Interaction with skills"},{"location":"decision-maker/#custom-decisionmaker","text":"The framework implements a default DecisionMakerHandler . You can also implement your own and mount it. No further configuration is needed to use the default. To use the advanced decision maker handler, add the following configuration to the aea-config.yaml of your AEA (on page 1): decision_maker_handler : config : {} dotted_path : \"aea.decision_maker.gop:DecisionMakerHandler\" file_path : null The easiest way to add a custom decision maker handler is to run the following command to scaffold a custom DecisionMakerHandler : aea scaffold decision-maker-handler You can then implement your own custom logic to process messages and interact with the Wallet . Note For examples how to use these concepts have a look at the tac_ skills. These functionalities are experimental and subject to change.","title":"Custom DecisionMaker"},{"location":"demos/","text":"We provide demo guides for multiple use-cases, each one involving several AEAs interacting in a different scenario. These demos serve to highlight the concept of AEAs as well as provide inspiration for developers. Demos should not be taken as production ready software, although every care is taken to fix bugs when reported. Demos are alphabetically sorted, we recommend you start with the Echo Skills Demo .","title":"Demos"},{"location":"deployment/","text":"The easiest way to run an AEA is using your development environment. If you would like to run an AEA from a browser you can use Google Colab . This gist can be opened in Colab and implements the quick start . For deployment, we recommend you use Docker . Deployment using a Docker Image First, we fetch a directory containing a Dockerfile and some dependencies: svn export https://github.com/valory-xyz/open-aea/branches/main/deploy-image cd deploy-image Then follow the README.md contained in the folder. Deployment using Kubernetes For an example of how to use Kubernetes navigate to our TAC deployment example .","title":"Deployment"},{"location":"deployment/#deployment-using-a-docker-image","text":"First, we fetch a directory containing a Dockerfile and some dependencies: svn export https://github.com/valory-xyz/open-aea/branches/main/deploy-image cd deploy-image Then follow the README.md contained in the folder.","title":"Deployment using a Docker Image"},{"location":"deployment/#deployment-using-kubernetes","text":"For an example of how to use Kubernetes navigate to our TAC deployment example .","title":"Deployment using Kubernetes"},{"location":"design-principles/","text":"The AEA framework development is guided by the following 8 principles: Accessibility : ease of use. Modularity : encourages module creation, sharing and reuse. Openness : easily extensible with third-party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal-alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"development-setup/","text":"An AEA consists of packages . When developing, it helps to be able to save packages in a local package registry, rather than pushing them to remote registry . This guide helps you set up a local package registry and configure the working directory for development. There are two ways to write code for an AEA: independent of a concrete AEA project, write individual packages from within an AEA project, write packages for that AEA Approach 1 To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps: Either, manually: Ensure you start with an empty working directory to avoid any unnecessary side effects. In your working directory, create an empty folder called packages . This folder will act as the local registry for packages. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_packages_dir where path_to_packages_dir is the path to the packages folder in your working directory. Or, automated: Fork our template repo for AEA development. Then clone it to your machine. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. After developing a package, you can add it to an AEA project in the working directory (e.g. aea create AGENT_NAME && cd AGENT_NAME && aea add --local PACKAGE_TYPE PUBLIC_ID will create a new AEA project AGENT_NAME and add the package of type PACKAGE_TYPE with public id PUBLIC_ID to it.) Approach 2 It is also possible to develop directly in an AEA project: Prepare a directory (henceforth working directory) for development. Create a new project aea create AGENT_NAME && cd AGENT_NAME Scaffold a new package aea scaffold --with-symlinks PACKAGE_TYPE PACKAGE_NAME . This will create the package scaffold under the directory {PACKAGE_TYPE}s and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are purely for your IDE. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_project_dir where path_to_project_dir is the path to the AEA project contained in your working directory. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. General advice This advice partially overlaps with the previous two sections: When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the packages directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag --local or --remote to only point to remote registry (see here for more details on CLI commands). When working on an AEA, it may help to provide a symbolic link to the packages directory, so that the import paths are detected by your editor. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to the packages directory with ln -s ../packages packages . Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to ln -s vendor packages . VSCode For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV/bin/aea\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV should be replaced with the path to the virtual environment and CWD with the working directory for the agent to debug (where the aea-config.yaml file is). Note, if packages are not contained within the CWD, the step referencing packages in Approach 2 will need to be completed.","title":"Development setup"},{"location":"development-setup/#approach-1","text":"To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps: Either, manually: Ensure you start with an empty working directory to avoid any unnecessary side effects. In your working directory, create an empty folder called packages . This folder will act as the local registry for packages. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_packages_dir where path_to_packages_dir is the path to the packages folder in your working directory. Or, automated: Fork our template repo for AEA development. Then clone it to your machine. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. After developing a package, you can add it to an AEA project in the working directory (e.g. aea create AGENT_NAME && cd AGENT_NAME && aea add --local PACKAGE_TYPE PUBLIC_ID will create a new AEA project AGENT_NAME and add the package of type PACKAGE_TYPE with public id PUBLIC_ID to it.)","title":"Approach 1"},{"location":"development-setup/#approach-2","text":"It is also possible to develop directly in an AEA project: Prepare a directory (henceforth working directory) for development. Create a new project aea create AGENT_NAME && cd AGENT_NAME Scaffold a new package aea scaffold --with-symlinks PACKAGE_TYPE PACKAGE_NAME . This will create the package scaffold under the directory {PACKAGE_TYPE}s and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are purely for your IDE. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_project_dir where path_to_project_dir is the path to the AEA project contained in your working directory. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect.","title":"Approach 2"},{"location":"development-setup/#general-advice","text":"This advice partially overlaps with the previous two sections: When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the packages directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag --local or --remote to only point to remote registry (see here for more details on CLI commands). When working on an AEA, it may help to provide a symbolic link to the packages directory, so that the import paths are detected by your editor. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to the packages directory with ln -s ../packages packages . Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to ln -s vendor packages .","title":"General advice"},{"location":"development-setup/#vscode","text":"For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV/bin/aea\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV should be replaced with the path to the virtual environment and CWD with the working directory for the agent to debug (where the aea-config.yaml file is). Note, if packages are not contained within the CWD, the step referencing packages in Approach 2 will need to be completed.","title":"VSCode"},{"location":"diagram/","text":"The framework has two distinctive parts. A core that was originally developed by the Fetch.ai team, that has now been forked by Valory-xyz. Extensions (also known as packages ) developed by any developer. Currently, the framework supports four types of packages which can be added to the core as modules: Skills encapsulate logic that deliver economic value to the AEA. Skills are the main focus of the framework's extensibility. Protocols define the structure of agent-to-agent and component-to-component interactions (messages and dialogues) for agents. Connections provide interfaces for the agent to connect with the outside world. They wrap SDKs or APIs and provide interfaces to networks, ledgers and other services. Contracts wrap smart contracts for Ethereum and third-party decentralized ledgers. The following figure illustrates the framework's architecture: The execution is broken down in more detail below: The agent operation breaks down into three parts: Setup : calls the setup() method of all registered resources Operation : Agent loop (Thread 1 - Asynchronous agent loop): react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() method on the Handler(s) responsible for them. act() : this function calls the act() method of all registered Behaviours. update() : this function enqueues scheduled tasks for execution with the TaskManager and executes the decision maker. Task loop (Thread 2- Synchronous): executes available tasks Decision maker loop (Thread 3- Synchronous): processes internal messages Multiplexer (Thread 4 - Asynchronous event loop): processes incoming and outgoing messages across several connections asynchronously. Teardown : calls the teardown() method of all registered resources To prevent a developer from blocking the main loop with custom skill code, an execution time limit is applied to every Behaviour.act and Handler.handle call. By default, the execution limit is set to 0 seconds, which disables the feature. You can set the limit to a strictly positive value (e.g. 0.1 seconds) to test your AEA for production readiness. If the act or handle time exceed this limit, the call will be terminated. An appropriate message is added to the logs in the case of some code execution being terminated.","title":"Architectural diagram"},{"location":"echo_demo/","text":"This is a simple demo that introduces you to the main components of an AEA. A full break down of the development is covered within the Development Quickstart . It is highly recommended that developers begin by following the quick start! This demo assumes you have followed the setup guide. The fastest way to have your first AEA is to fetch one that already exists! aea fetch open_aea/my_first_aea:0.1.0 --local cd my_first_aea Install AEA dependencies aea install Add and create a private key All AEAs need a private key to run. Add one now: aea generate-key ethereum aea add-key ethereum Run the AEA Run the AEA. aea run You will see the echo skill running in the terminal window (an output similar to the one below). _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.2.0 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... Interact with the AEA From a different terminal and same directory (i.e. the my_first_aea project), you can send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the aea interact command. Stop the AEA You can stop an AEA by pressing CTRL C . Once you do, you should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called. To learn more about the folder structure of an AEA project read on here . A full break down of the development is covered within the Development Quickstart . It is highly recommended that developers begin by following the quick start!","title":"Echo Demo"},{"location":"echo_demo/#install-aea-dependencies","text":"aea install","title":"Install AEA dependencies"},{"location":"echo_demo/#add-and-create-a-private-key","text":"All AEAs need a private key to run. Add one now: aea generate-key ethereum aea add-key ethereum","title":"Add and create a private key"},{"location":"echo_demo/#run-the-aea","text":"Run the AEA. aea run You will see the echo skill running in the terminal window (an output similar to the one below). _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.2.0 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ...","title":"Run the AEA"},{"location":"echo_demo/#interact-with-the-aea","text":"From a different terminal and same directory (i.e. the my_first_aea project), you can send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the aea interact command.","title":"Interact with the AEA"},{"location":"echo_demo/#stop-the-aea","text":"You can stop an AEA by pressing CTRL C . Once you do, you should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called. To learn more about the folder structure of an AEA project read on here . A full break down of the development is covered within the Development Quickstart . It is highly recommended that developers begin by following the quick start!","title":"Stop the AEA"},{"location":"generic-storage/","text":"The AEA generic storage: description and usage. AEA Generic Storage AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style. Configuration Storage is enabled by providing in the agent configuration ( aea-config.yaml ) an optional storage_uri . The storage URI consists of the backend name and string data provided to selected backend. The storage URI schema is <BACKEND_NAME>://[Optional string] Example: storage_uri: sqlite://./some_file.db tells the AEA to use SQLite backend and store data in ./some_file.db . Supported backends: * SQLite - bundled with python simple SQL engine that uses file or in-memory storage. Dialogues and Storage integration One of the most useful cases is the integration of the dialogues subsystem and storage. It helps maintain dialogues state during agent restarts and reduced memory requirements due to the offloading feature. Keep terminal state dialogues The Dialogues class has the optional boolean argument keep_terminal_state_dialogues which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If keep_terminal_state_dialogues is False , dialogues that reach a terminal state are removed from memory and can not be used any more. If keep_terminal_state_dialogues is True , dialogues that reach a terminal state are kept in memory or storage (if configured). If storage is configured, all dialogues in memory are stored on agent stop and restored on agent start. It useful to save memory with dialogues that are in terminal state and probably will be never used again. Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section. Skill configuration to keep terminated dialogues for DefaultDialogues . Example: Dialogues dump/restore on agent restart If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start. Offload terminal state dialogues If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory. All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart. To enable dialogues offloading keep_terminal_state_dialogues has to be enabled and storage configured. Manual usage with skill components Handlers, Behaviours and Models are able to use storage if enabled. Storage is available with skill context: self.context.storage if self.context.storage is not None, storage is enabled and ready to use. Generic storage consists of two parts: objects and collections. Objects consist of the object_id (unique string) and object body. The object body is any JSON friendly python data type: list , dict , int , float , string , bool . Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and _ . To get/put specific object collection instance should be used. my_collection = self . context . storage . get_sync_connection ( 'my_collection' ) Collection instance provide set of methods to handle data objects. List of collection methods: def put ( self , object_id : str , object_body : JSON_TYPES ) -> None : \"\"\" Put object into collection. :param object_id: str object id :param object_body: python dict, json compatible. :return: None \"\"\" def get ( self , object_id : str ) -> Optional [ JSON_TYPES ]: \"\"\" Get object from the collection. :param object_id: str object id :return: dict if object exists in collection otherwise None \"\"\" def remove ( self , object_id : str ) -> None : \"\"\" Remove object from the collection. :param object_id: str object id :return: None \"\"\" def find ( self , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" Get objects from the collection by filtering by field value. :param field: field name to search: example \"parent.field\" :param equals: value field should be equal to :return: List of object bodies \"\"\" def list ( self ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" List all objects with keys from the collection. :return: Tuple of objects keys, bodies. \"\"\" Simple behaviour example: It saves the datetime string of the first act and print it to stdout. class TestBehaviour ( TickerBehaviour ): \"\"\"Simple behaviour to count how many acts were called.\"\"\" def setup ( self ) -> None : \"\"\"Set up behaviour.\"\"\" def act ( self ) -> None : \"\"\"Make an action.\"\"\" if not ( self . context . storage and self . context . storage . is_connected ): return collection = self . context . storage . get_sync_collection ( 'my_collection' ) first_call_datetime = collection . get ( \"first_call_ts\" ) if not first_call_ts : # there is no object with \"first_call_ts\" id. first_call_datetime = str ( datetime . datetime . now ()) col . put ( first_call_ts , first_call_datetime ) print ( \"Act was called for the first time on:\" , first_call_datetime ) Please, pay attention: datetime object is not JSON friendly and can not be stored directly. it should be transformed to timestamp or string before put into the storage.","title":"Generic Storage"},{"location":"generic-storage/#aea-generic-storage","text":"AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style.","title":"AEA Generic Storage"},{"location":"generic-storage/#configuration","text":"Storage is enabled by providing in the agent configuration ( aea-config.yaml ) an optional storage_uri . The storage URI consists of the backend name and string data provided to selected backend. The storage URI schema is <BACKEND_NAME>://[Optional string] Example: storage_uri: sqlite://./some_file.db tells the AEA to use SQLite backend and store data in ./some_file.db . Supported backends: * SQLite - bundled with python simple SQL engine that uses file or in-memory storage.","title":"Configuration"},{"location":"generic-storage/#dialogues-and-storage-integration","text":"One of the most useful cases is the integration of the dialogues subsystem and storage. It helps maintain dialogues state during agent restarts and reduced memory requirements due to the offloading feature.","title":"Dialogues and Storage integration"},{"location":"generic-storage/#keep-terminal-state-dialogues","text":"The Dialogues class has the optional boolean argument keep_terminal_state_dialogues which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If keep_terminal_state_dialogues is False , dialogues that reach a terminal state are removed from memory and can not be used any more. If keep_terminal_state_dialogues is True , dialogues that reach a terminal state are kept in memory or storage (if configured). If storage is configured, all dialogues in memory are stored on agent stop and restored on agent start. It useful to save memory with dialogues that are in terminal state and probably will be never used again. Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section. Skill configuration to keep terminated dialogues for DefaultDialogues . Example:","title":"Keep terminal state dialogues"},{"location":"generic-storage/#dialogues-dumprestore-on-agent-restart","text":"If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start.","title":"Dialogues dump/restore on agent restart"},{"location":"generic-storage/#offload-terminal-state-dialogues","text":"If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory. All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart. To enable dialogues offloading keep_terminal_state_dialogues has to be enabled and storage configured.","title":"Offload terminal state dialogues"},{"location":"generic-storage/#manual-usage-with-skill-components","text":"Handlers, Behaviours and Models are able to use storage if enabled. Storage is available with skill context: self.context.storage if self.context.storage is not None, storage is enabled and ready to use. Generic storage consists of two parts: objects and collections. Objects consist of the object_id (unique string) and object body. The object body is any JSON friendly python data type: list , dict , int , float , string , bool . Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and _ . To get/put specific object collection instance should be used. my_collection = self . context . storage . get_sync_connection ( 'my_collection' ) Collection instance provide set of methods to handle data objects. List of collection methods: def put ( self , object_id : str , object_body : JSON_TYPES ) -> None : \"\"\" Put object into collection. :param object_id: str object id :param object_body: python dict, json compatible. :return: None \"\"\" def get ( self , object_id : str ) -> Optional [ JSON_TYPES ]: \"\"\" Get object from the collection. :param object_id: str object id :return: dict if object exists in collection otherwise None \"\"\" def remove ( self , object_id : str ) -> None : \"\"\" Remove object from the collection. :param object_id: str object id :return: None \"\"\" def find ( self , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" Get objects from the collection by filtering by field value. :param field: field name to search: example \"parent.field\" :param equals: value field should be equal to :return: List of object bodies \"\"\" def list ( self ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" List all objects with keys from the collection. :return: Tuple of objects keys, bodies. \"\"\" Simple behaviour example: It saves the datetime string of the first act and print it to stdout. class TestBehaviour ( TickerBehaviour ): \"\"\"Simple behaviour to count how many acts were called.\"\"\" def setup ( self ) -> None : \"\"\"Set up behaviour.\"\"\" def act ( self ) -> None : \"\"\"Make an action.\"\"\" if not ( self . context . storage and self . context . storage . is_connected ): return collection = self . context . storage . get_sync_collection ( 'my_collection' ) first_call_datetime = collection . get ( \"first_call_ts\" ) if not first_call_ts : # there is no object with \"first_call_ts\" id. first_call_datetime = str ( datetime . datetime . now ()) col . put ( first_call_ts , first_call_datetime ) print ( \"Act was called for the first time on:\" , first_call_datetime ) Please, pay attention: datetime object is not JSON friendly and can not be stored directly. it should be transformed to timestamp or string before put into the storage.","title":"Manual usage with skill components"},{"location":"glossary/","text":"This glossary defines a number of terms commonly used across the documentation. The further information the concepts links provided to the respective sections in the guide or to external resources are provided. For the definitions of framework components one may consult the API docs. Agent : An agent is one that acts as an instrument on behalf of its owner or another agent to achieve a result. [ more ] Software Agent : a software agent is a computer program that acts on behalf of an entity (e.g. individual, organisation, business). [ more ] AEA (Autonomous Economic Agent) : An AEA is \"an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner\". AEAs are a special type of agent. [ more ] MAS (Multi-agent system) : A MAS is a system that is inhabited by agents who can interact with their environment and other agents in the system through the use of decision-making logic. [ more ] ACN (Agent Communication Network) : The ACN is a peer-to-peer communication network for autonomous economic agents. [ more ] Distributed : Distributed systems or computing refers to networks whose nodes are physically separated, and who may be used to solve problems efficiently by dividing their workload. [ more ] Decentralized : Decentralized systems or computing refers to networks whose nodes are owned by different users, which may be used for peer-to-peer communication without a third-party intermediary acting as a central authority. [ more ] Skill : A Skill encapsulates implementations Handler, Behaviour and Model, and may include any number of each of these components. [ more ] Handler : Handlers are used to manage incoming messages. They constitute the means for an AEA to respond to input from its environment. Behaviour : Behaviour encapsulates actions which further the AEAs goal and are initiated by internals of the AEA rather than external events. They constitute an activity that an AEA can proactively engage in. Model : A Model is a dynamic data structure that manages data, logic and rules of the application. Task : Encapsulate skill components that are scheduled for asynchronous execution. They are background processes that enable concurrency in the system, which is a necessity for independence be their behaviour and decision-making. [ more ] Context : The context provides access to the objects in other parts of the implementation. More specifically, the: AgentContext : Provides read access to relevant objects of the agent for the skills. Such information includes public keys and addresses of the AEA. It also provides access to the OutBox. SkillContext : The skill has a SkillContext object which is shared by all Handler, Behaviour, and Model objects. The skill context also has a link to the AgentContext. Ledger : A ledger is a record in which transactions are recorded. With regard to cryptocurrencies these are distributed ledgers which contain information on ownership. [ more ] Decision Maker : The DecisionMaker can be thought of as a Wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEAs crypto-economic security and goal management. The decision maker is the only component with access to the Wallet's private keys. In its simplest form, the decision maker acts like a Wallet with a Handler, which allow it to react to messages it receives. [ more ] Envelopes : AEA objects communicate asynchronously via Envelopes. An Envelope is the core object with which agents communicate. It is a vehicle for Messages. [ more ] Protocol : Protocols define agent-to-agent as well as component-to-component interactions within AEAs. As such, they include: Messages; Serialization; Dialogues (rules over Message sequences). Protocol-specific messages, wrapped in Envelopes, are sent and received to other agents, agent components and services via connections. [ more ] Connection : A Connection wraps an SDK or API and provides an interface to networks, ledgers or other services. Where necessary, a Connection is responsible for translating between the framework specific Envelope with its contained Message and the external service or third-party protocol (e.g. HTTP). [ more ] Multiplexer : The Multiplexer is responsible for maintaining connections. It maintains an InBox and OutBox, which are, respectively, queues for incoming and outgoing Envelopes from the perspective of Skills. [ more ]","title":"Glossary"},{"location":"gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses OpenAI's gym library, may be embedded into an AEA skill and connection. Discussion The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create the AEA First, fetch the gym AEA: aea fetch open_aea/gym_aea:0.1.0 --local cd gym_aea aea install Alternatively, create from scratch. ### Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea ### Add the gym skill aea add skill fetchai/gym:0.20.0 ### Set gym connection as default aea config set agent.default_connection fetchai/gym:0.19.0 ### Install the skill dependencies To install the `gym` package, a dependency of the gym skill, from PyPI run aea install Set up the training environment Copy the gym environment to the AEA directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Update the connection configuration aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom' Create and add a private key aea generate-key ethereum aea add-key ethereum Run the AEA with the gym connection aea run You will see the gym training logs. Delete the AEA When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea Communication This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment Skill Architecture The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Gym skill"},{"location":"gym-skill/#discussion","text":"The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"gym-skill/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"gym-skill/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"gym-skill/#demo-instructions","text":"","title":"Demo instructions"},{"location":"gym-skill/#create-the-aea","text":"First, fetch the gym AEA: aea fetch open_aea/gym_aea:0.1.0 --local cd gym_aea aea install Alternatively, create from scratch. ### Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea ### Add the gym skill aea add skill fetchai/gym:0.20.0 ### Set gym connection as default aea config set agent.default_connection fetchai/gym:0.19.0 ### Install the skill dependencies To install the `gym` package, a dependency of the gym skill, from PyPI run aea install","title":"Create the AEA"},{"location":"gym-skill/#set-up-the-training-environment","text":"","title":"Set up the training environment"},{"location":"gym-skill/#copy-the-gym-environment-to-the-aea-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the AEA directory"},{"location":"gym-skill/#update-the-connection-configuration","text":"aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom'","title":"Update the connection configuration"},{"location":"gym-skill/#create-and-add-a-private-key","text":"aea generate-key ethereum aea add-key ethereum","title":"Create and add a private key"},{"location":"gym-skill/#run-the-aea-with-the-gym-connection","text":"aea run You will see the gym training logs.","title":"Run the AEA with the gym connection"},{"location":"gym-skill/#delete-the-aea","text":"When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea","title":"Delete the AEA"},{"location":"gym-skill/#communication","text":"This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment","title":"Communication"},{"location":"gym-skill/#skill-architecture","text":"The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Skill Architecture"},{"location":"http-connection-and-skill/","text":"Description The HTTP client and HTTP server connections enable an AEA to communicate with external servers, respectively clients, via HTTP. The HTTP client connection receives request envelops from an agent's skill, translates each into an HTTP request and sends it to a server external to the agent. If it receives an HTTP response from the server within a timeout window, it translates it into a response envelope, and sends this back to the relevant skill inside the agent. The HTTP server connection allows you to run a server inside the connection itself which accepts requests from clients external to the agent. The HTTP server connection validates requests it receives against a provided OpenAPI file. It translates each valid request into an envelope and sends it to the skill specified in the connections configuration. If it receives a valid response envelope from the skill within a timeout window, the connection translates the response envelope into an HTTP response and serves it to the client. HTTP Client The fetchai/simple_data_request:0.13.0 skill demonstrates a simple use case of the HTTP Client connection. The HttpRequestBehaviour in behaviours.py periodically sends HTTP envelops to the HTTP client connection. Its act() method, periodically called, simply calls _generate_http_request which contains the logic for enqueueing an HTTP request envelop. The HttpHandler in handler.py is a basic handler for dealing with HTTP response envelops received from the HTTP client connection. In the handle() method, the responses are dealt with by the private _handle_response method which essentially logs the response and adds the body of the response into the skill's shared state. HTTP Server Create a new AEA: aea create my_aea cd my_aea Add the http server connection package: aea add connection fetchai/http_server:0.22.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.22.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Create and add a private key: aea generate-key ethereum aea add-key ethereum Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo You can implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, delete the my_model.py and behaviour.py files (in my_aea/skills/http_echo/ ). The server will be purely reactive, so you only need the handlers.py file, and the dialogues.py to record the state of the dialogues. Update skill.yaml accordingly, so set models: {} and behaviours: {} . Next implement a basic handler which prints the received envelopes and responds. Then, replace the content of handlers.py with the following code snippet, after having replaced the placeholder YOUR_USERNAME with the author username (i.e. the output of aea config get agent.author ): import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default import DefaultMessage from packages.fetchai.protocols.http.message import HttpMessage from packages.YOUR_USERNAME.skills.http_echo.dialogues import ( DefaultDialogues , HttpDialogue , HttpDialogues , ) class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message \"\"\" http_msg = cast ( HttpMessage , message ) # recover dialogue http_dialogues = cast ( HttpDialogues , self . context . http_dialogues ) http_dialogue = cast ( HttpDialogue , http_dialogues . update ( http_msg )) if http_dialogue is None : self . _handle_unidentified_dialogue ( http_msg ) return # handle message if http_msg . performative == HttpMessage . Performative . REQUEST : self . _handle_request ( http_msg , http_dialogue ) else : self . _handle_invalid ( http_msg , http_dialogue ) def _handle_unidentified_dialogue ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param http_msg: the message \"\"\" self . context . logger . info ( \"received invalid http message= {} , unidentified dialogue.\" . format ( http_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = http_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"http_message\" : http_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) def _handle_request ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . info ( \"received http request with method= {} , url= {} and body= {!r} \" . format ( http_msg . method , http_msg . url , http_msg . body , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg , http_dialogue ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg , http_dialogue ) def _handle_get ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_post ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = http_msg . body , ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_invalid ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle an invalid http message. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . warning ( \"cannot handle http message of performative= {} in dialogue= {} .\" . format ( http_msg . performative , http_dialogue ) ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" Moreover, add a dialogues.py file with the following code: from typing import Any from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.http.dialogues import HttpDialogue as BaseHttpDialogue from packages.fetchai.protocols.http.dialogues import HttpDialogues as BaseHttpDialogues DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) HttpDialogue = BaseHttpDialogue class HttpDialogues ( Model , BaseHttpDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseHttpDialogue . Role . SERVER BaseHttpDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) Then, update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler models : default_dialogues : args : {} class_name : DefaultDialogues http_dialogues : args : {} class_name : HttpDialogues Run the fingerprinter (note, you will have to replace the author name with your author handle): aea fingerprint skill fetchai/http_echo:0.20.0 Moreover, we need to tell to the http_server connection to what skill the HTTP requests should be forwarded. In our case, this is the http_echo that you have just scaffolded. Its public id will be <your-author-name>/http_echo:0.1.0 . aea config set vendor.fetchai.connections.http_server.config.target_skill_id \" $( aea config get agent.author ) /http_echo:0.1.0\" You can now run the AEA: aea run In a separate terminal, you can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"HTTP Connection"},{"location":"http-connection-and-skill/#description","text":"The HTTP client and HTTP server connections enable an AEA to communicate with external servers, respectively clients, via HTTP. The HTTP client connection receives request envelops from an agent's skill, translates each into an HTTP request and sends it to a server external to the agent. If it receives an HTTP response from the server within a timeout window, it translates it into a response envelope, and sends this back to the relevant skill inside the agent. The HTTP server connection allows you to run a server inside the connection itself which accepts requests from clients external to the agent. The HTTP server connection validates requests it receives against a provided OpenAPI file. It translates each valid request into an envelope and sends it to the skill specified in the connections configuration. If it receives a valid response envelope from the skill within a timeout window, the connection translates the response envelope into an HTTP response and serves it to the client.","title":"Description"},{"location":"http-connection-and-skill/#http-client","text":"The fetchai/simple_data_request:0.13.0 skill demonstrates a simple use case of the HTTP Client connection. The HttpRequestBehaviour in behaviours.py periodically sends HTTP envelops to the HTTP client connection. Its act() method, periodically called, simply calls _generate_http_request which contains the logic for enqueueing an HTTP request envelop. The HttpHandler in handler.py is a basic handler for dealing with HTTP response envelops received from the HTTP client connection. In the handle() method, the responses are dealt with by the private _handle_response method which essentially logs the response and adds the body of the response into the skill's shared state.","title":"HTTP Client"},{"location":"http-connection-and-skill/#http-server","text":"Create a new AEA: aea create my_aea cd my_aea Add the http server connection package: aea add connection fetchai/http_server:0.22.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.22.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Create and add a private key: aea generate-key ethereum aea add-key ethereum Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo You can implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, delete the my_model.py and behaviour.py files (in my_aea/skills/http_echo/ ). The server will be purely reactive, so you only need the handlers.py file, and the dialogues.py to record the state of the dialogues. Update skill.yaml accordingly, so set models: {} and behaviours: {} . Next implement a basic handler which prints the received envelopes and responds. Then, replace the content of handlers.py with the following code snippet, after having replaced the placeholder YOUR_USERNAME with the author username (i.e. the output of aea config get agent.author ): import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default import DefaultMessage from packages.fetchai.protocols.http.message import HttpMessage from packages.YOUR_USERNAME.skills.http_echo.dialogues import ( DefaultDialogues , HttpDialogue , HttpDialogues , ) class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message \"\"\" http_msg = cast ( HttpMessage , message ) # recover dialogue http_dialogues = cast ( HttpDialogues , self . context . http_dialogues ) http_dialogue = cast ( HttpDialogue , http_dialogues . update ( http_msg )) if http_dialogue is None : self . _handle_unidentified_dialogue ( http_msg ) return # handle message if http_msg . performative == HttpMessage . Performative . REQUEST : self . _handle_request ( http_msg , http_dialogue ) else : self . _handle_invalid ( http_msg , http_dialogue ) def _handle_unidentified_dialogue ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param http_msg: the message \"\"\" self . context . logger . info ( \"received invalid http message= {} , unidentified dialogue.\" . format ( http_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = http_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"http_message\" : http_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) def _handle_request ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . info ( \"received http request with method= {} , url= {} and body= {!r} \" . format ( http_msg . method , http_msg . url , http_msg . body , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg , http_dialogue ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg , http_dialogue ) def _handle_get ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_post ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = http_msg . body , ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_invalid ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle an invalid http message. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . warning ( \"cannot handle http message of performative= {} in dialogue= {} .\" . format ( http_msg . performative , http_dialogue ) ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" Moreover, add a dialogues.py file with the following code: from typing import Any from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.http.dialogues import HttpDialogue as BaseHttpDialogue from packages.fetchai.protocols.http.dialogues import HttpDialogues as BaseHttpDialogues DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) HttpDialogue = BaseHttpDialogue class HttpDialogues ( Model , BaseHttpDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseHttpDialogue . Role . SERVER BaseHttpDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) Then, update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler models : default_dialogues : args : {} class_name : DefaultDialogues http_dialogues : args : {} class_name : HttpDialogues Run the fingerprinter (note, you will have to replace the author name with your author handle): aea fingerprint skill fetchai/http_echo:0.20.0 Moreover, we need to tell to the http_server connection to what skill the HTTP requests should be forwarded. In our case, this is the http_echo that you have just scaffolded. Its public id will be <your-author-name>/http_echo:0.1.0 . aea config set vendor.fetchai.connections.http_server.config.target_skill_id \" $( aea config get agent.author ) /http_echo:0.1.0\" You can now run the AEA: aea run In a separate terminal, you can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"HTTP Server"},{"location":"http-echo-demo/","text":"HTTP Echo Demo The purpose of this demonstration is to show the open-aea framework can be used as a HTTP server. More concretely, an AEA with a http server connection and an appropriate skill can be used as a server. A full break down of the development flow is covered within the Development Quickstart . It is highly recommended that developers begin by following the quick start! It is assumed that developers are within a pipenv virtual environment. A full break down of the development flow is covered within the Development Quickstart . The easiest way to get started with the http server is to use our pre-built example skill. pipenv shell aea fetch open_aea/http_echo:0.1.0 --local cd http_echo aea generate-key ethereum ; aea add-key ethereum aea run --aev Adding protocol 'open_aea/signing:1.0.0' ... Successfully added protocol 'open_aea/signing:1.0.0' . Adding protocol 'fetchai/http:1.0.0' ... Successfully added protocol 'fetchai/http:1.0.0' . Adding protocol 'fetchai/default:1.0.0' ... Successfully added protocol 'fetchai/default:1.0.0' . Adding connection 'fetchai/http_server:0.22.0' ... Successfully added connection 'fetchai/http_server:0.22.0' . Adding skill 'fetchai/http_echo:0.20.0' ... Successfully added skill 'fetchai/http_echo:0.20.0' . Agent http_echo successfully fetched. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.4.0 Starting AEA 'http_echo' in 'async' mode... info: [ http_echo ] HTTP Server has connected to port: 5000 . info: [ http_echo ] Start processing messages... in a second terminal curl 0 .0.0.0:5000 { \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }} Congratulations! You have just used an AEA successfully as a web server! Tear Down aea delete http_echo","title":"HTTP Echo Demo"},{"location":"http-echo-demo/#http-echo-demo","text":"The purpose of this demonstration is to show the open-aea framework can be used as a HTTP server. More concretely, an AEA with a http server connection and an appropriate skill can be used as a server. A full break down of the development flow is covered within the Development Quickstart . It is highly recommended that developers begin by following the quick start! It is assumed that developers are within a pipenv virtual environment. A full break down of the development flow is covered within the Development Quickstart . The easiest way to get started with the http server is to use our pre-built example skill. pipenv shell aea fetch open_aea/http_echo:0.1.0 --local cd http_echo aea generate-key ethereum ; aea add-key ethereum aea run --aev Adding protocol 'open_aea/signing:1.0.0' ... Successfully added protocol 'open_aea/signing:1.0.0' . Adding protocol 'fetchai/http:1.0.0' ... Successfully added protocol 'fetchai/http:1.0.0' . Adding protocol 'fetchai/default:1.0.0' ... Successfully added protocol 'fetchai/default:1.0.0' . Adding connection 'fetchai/http_server:0.22.0' ... Successfully added connection 'fetchai/http_server:0.22.0' . Adding skill 'fetchai/http_echo:0.20.0' ... Successfully added skill 'fetchai/http_echo:0.20.0' . Agent http_echo successfully fetched. _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.4.0 Starting AEA 'http_echo' in 'async' mode... info: [ http_echo ] HTTP Server has connected to port: 5000 . info: [ http_echo ] Start processing messages... in a second terminal curl 0 .0.0.0:5000 { \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }} Congratulations! You have just used an AEA successfully as a web server!","title":"HTTP Echo Demo"},{"location":"http-echo-demo/#tear-down","text":"aea delete http_echo","title":"Tear Down"},{"location":"identity/","text":"Note This section is incomplete and will soon be updated. The AEAs currently use the addresses associated with their private-public key pairs to identify themselves. To learn how to generate a private-public key pair check out the relevant CLI commands . To learn more about public-key cryptography check out Wikipedia .","title":"Identity"},{"location":"interaction-protocol/","text":"Although one can imagine scenarios where single AEAs pursue their goals in isolation without interacting with other AEAs, there is no doubt that by working together, AEAs have the potential of achieving much more, especially when taking into account agents' heterogeneity, specialisations, and differing and often complimentary local views of the environment. Interactions in the AEA world are in the form of communication. This is influenced by established practices in the field of multi-agent systems and the prominent speech-act theory which suggests that a communicative expression is not only about transferring information from the speaker to the hearer, but that there may be meanings and commitments beyond the statement's appearance. Therefore, speech may more suitably be considered as action. For example, \"I hereby appoint you as chairman\" is not just a sequence of words, but an action done by the speaker with wide-ranging consequences for the hearer and any other audience to that sentence. Interaction protocols are thus possible communication scenarios between agents or agent components (specifically, skills and connections). There are multiple types of interactions an AEA can have: AEA-to-AEA interactions. You can find some examples in the demo section . Interactions between an AEA's internal components. Usually, an interaction involves three types of framework packages: skills , protocols and connections . Example 1: AEA <> web client In the http connection guide we demonstrate how an AEA with an http server connection (e.g. fetchai/http_server ) receives http payloads from web clients, translates them to messages conforming with the fetchai/http protocol and passes it to a skill (e.g. fetchai/http_echo ) to process. The fetchai/http protocol in this case is used for communication between the connection and the skill. Example 2 : AEA <> 3rd party server The fetchai/http_client connection can be used to make requests to third party servers. In this case, a skill containing the logic for the production of http requests would create messages conforming with the fetchai/http protocol and sends it to the fetchai/http_client connection which in turn translates it into http payload and sends it to the destination server. Note that in general, third party SDKs can be wrapped in a connection and shared with other developers as a package. Often this also involves creating a custom protocol to enforce the type of interactions permitted between skills and the connection wrapping the SDK. Next steps Recommended We recommend you continue with the : Development Setup Relevant deep-dives Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives and implement interaction protocols. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"How AEAs talk to each other - interaction protocols"},{"location":"interaction-protocol/#example-1-aea-web-client","text":"In the http connection guide we demonstrate how an AEA with an http server connection (e.g. fetchai/http_server ) receives http payloads from web clients, translates them to messages conforming with the fetchai/http protocol and passes it to a skill (e.g. fetchai/http_echo ) to process. The fetchai/http protocol in this case is used for communication between the connection and the skill.","title":"Example 1: AEA &lt;&gt; web client"},{"location":"interaction-protocol/#example-2-aea-3rd-party-server","text":"The fetchai/http_client connection can be used to make requests to third party servers. In this case, a skill containing the logic for the production of http requests would create messages conforming with the fetchai/http protocol and sends it to the fetchai/http_client connection which in turn translates it into http payload and sends it to the destination server. Note that in general, third party SDKs can be wrapped in a connection and shared with other developers as a package. Often this also involves creating a custom protocol to enforce the type of interactions permitted between skills and the connection wrapping the SDK.","title":"Example 2 : AEA &lt;&gt; 3rd party server"},{"location":"interaction-protocol/#next-steps","text":"","title":"Next steps"},{"location":"interaction-protocol/#recommended","text":"We recommend you continue with the : Development Setup","title":"Recommended"},{"location":"interaction-protocol/#relevant-deep-dives","text":"Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives and implement interaction protocols. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Relevant deep-dives"},{"location":"known-limits/","text":"The AEA framework makes a multitude of tradeoffs. Here we present an incomplete list of known limitations: The AEABuilder checks the consistency of packages at the add stage. However, it does not currently check the consistency again at the load stage. This means, if a package is tampered with after it is added to the AEABuilder then these inconsistencies might not be detected by the AEABuilder . The AEABuilder assumes that packages with public ids of identical author and package name have a matching version. As a result, if a developer uses a package with matching author and package name but different version in the public id, then the AEABuilder will not detect this and simply use the last loaded package. The order in which setup and teardown are called on the skills, and act is called on the behaviours, is not guaranteed. Skills should be designed to work independently. Where skills use the shared_context to exchange information they must do so safely.","title":"Known limitations"},{"location":"language-agnostic-definition/","text":"Currently, there is an implementation of the AEA framework in Python which enables the development of AEAs in Python, and allows AEAs which are built with it to run. However, AEAs can be developed in different programming languages. This is further backed by the idea that agent-based solutions are suited for multi-stakeholder environments where the different AEAs may be developed independently of one another, resulting in heterogeneous systems. This means that in principle, there could be different implementations of the AEA framework, in various programming languages and for different platforms. However, to ensure that AEAs under any implementation are compatible with one another and able to interact, they must satisfy specific definitions. In this page, we compile a set of definitions which any AEA independent of its implementation must satisfy in order to be able to interact with other AEAs. An AEA, in technical terms, must satisfy the following requirements: It MUST be capable of receiving and sending Envelopes which satisfy the following protobuf schema: syntax = \"proto3\" ; package aea . base.v0_1_0 ; message Envelope { string to = 1 ; string sender = 2 ; string protocol_id = 3 ; bytes message = 4 ; string uri = 5 ; } The format for the above fields are as follows: to and sender : an address derived from the private key of a secp256k1 -compatible elliptic curve protocol_id : this must match a defined regular expression (see below) message : a bytes string representing a serialized message in the specified protocol URI : follows this syntax It MUST implement each protocol's message with the required meta-fields: syntax = \"proto3\" ; package aea . base.v0_1_0 ; import \"google/protobuf/struct.proto\" ; message DialogueMessage { int32 message_id = 1 ; string dialogue_starter_reference = 2 ; string dialogue_responder_reference = 3 ; int32 target = 4 ; bytes content = 5 ; } message Message { oneof message { google.protobuf.Struct body = 1 ; DialogueMessage dialogue_message = 2 ; } } message Envelope { string to = 1 ; string sender = 2 ; string protocol_id = 3 ; bytes message = 4 ; string uri = 5 ; } where content is replaced with the protocol specific content (see here for details). It MUST implement protocols according to their specification (see here for details). It SHOULD implement the fetchai/default:1.0.0 protocol which satisfies the following protobuf schema: syntax = \"proto3\" ; package aea . fetchai.default.v1_0_0 ; message DefaultMessage { // Custom Types message ErrorCode { enum ErrorCodeEnum { UNSUPPORTED_PROTOCOL = 0 ; DECODING_ERROR = 1 ; INVALID_MESSAGE = 2 ; UNSUPPORTED_SKILL = 3 ; INVALID_DIALOGUE = 4 ; } ErrorCodeEnum error_code = 1 ; } // Performatives and contents message Bytes_Performative { bytes content = 1 ; } message Error_Performative { ErrorCode error_code = 1 ; string error_msg = 2 ; map < string , bytes > error_data = 3 ; } message End_Performative { } oneof performative { Bytes_Performative bytes = 5 ; End_Performative end = 6 ; Error_Performative error = 7 ; } } The protocol id MUST match the following regular expression: ^([a-zA-Z_][a-zA-Z0-9_]{0,127})/([a-zA-Z_][a-zA-Z0-9_]{0,127})(:(any|latest|((0|[1-9]\\d*))\\.((0|[1-9]\\d*))\\.((0|[1-9]\\d*))(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?))?(:[a-zA-Z_][a-zA-Z0-9]{45})?$ It is recommended that it processes Envelopes asynchronously. Note, the specification regarding the processing of messages does not impose any particular implementation, and the AEA can be designed to process envelopes either synchronously and asynchronously. However, asynchronous message handling enables the agent to be more responsive and scalable in maintaining many concurrent dialogues with its peers. It MUST have an identity in the form of, at a minimum, an address derived from a public key and its associated private key (where the elliptic curve must be of type SECP256k1 ). It SHOULD implement handling of errors using the fetchai/default:1.0.0 protocol. The protobuf schema is given above. It MUST implement the following principles when handling messages: It MUST ALWAYS handle incoming envelopes/messages and NEVER raise an exception when decoding and validating the message. This ensures another AEA cannot cause the agent to fail by sending a malicious envelope/message. It MUST NEVER handle outgoing messages and ALWAYS raise an exception when validating the message. An exception implies that the handler is resolving a bug in the implementation. Note Additional constraints will be added soon!","title":"Language Agnostic Definition"},{"location":"ledger-integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.ai and third-party ledgers. Ledger support For a ledger to be considered supported in the framework, three abstract base classes need to be implemented: the LedgerApi class wraps the API to talk to the ledger and its helper methods the Crypto class wraps the API to perform cryptographic operations for the relevant ledger the FaucetApi class wraps the API to talk to a faucet on a testnet These three classes have their own registries, which allow the developer to import the relevant object where needed. Ledger plug-in architecture The AEA framework provides a plug-in mechanism to support ledger functionalities in an easily extendible way. At import time, the framework will load all the crypto plug-ins available in the current Python environment. A crypto plug-in is a Python package which declares some specific setuptools \"entry points\" in its setup.py script. In particular, there are three types of entry points the framework looks up: aea.ledger_apis , which points to instantiable classes implementing the LedgerApi interface; aea.cryptos , which points to instantiable classes implementing the Crypto interface; aea.faucet_apis , which points to instantiable classes implementing the FaucetApi interface. This is an example of setup.py script for a ledger plug-in open-aea-ledger-myledger : # sample ./setup.py file from setuptools import setup setup ( name = \"open-aea-ledger-myledger\" , packages = [ \"aea_ledger_myledger\" ], # plugins must depend on 'aea' install_requires = [ \"aea\" ], # add other dependencies... # the following makes a plugin available to aea entry_points = { \"aea.cryptos\" : [ \"myledger = aea_ledger_myledger:MyLedgerCrypto\" ], \"aea.ledger_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerApi\" ], \"aea.faucet_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerFaucetApi\" ], }, # PyPI classifier for AEA plugins classifiers = [ \"Framework :: AEA\" ], ) By convention, such plug-in packages should be named open-aea-ledger-${LEDGER_ID} , and the importable package name aea_ledger_${LEDGER_ID} . In the example above, the package name is open-aea-ledger-myledger , and the importable package name is aea_ledger_myledger . You can search for AEA ledger plug-ins on PyPI: https://pypi.org/search/?q=aea-ledger Maintained plug-ins At the moment, the framework natively supports the following three ledgers: Fetch.ai: PyPI package: open-aea-ledger-fetchai , and source code . Ethereum: PyPI package: open-aea-ledger-ethereum , and source code . Cosmos: PyPI package: open-aea-ledger-cosmos , and source code . However, support for additional ledgers can be added to the framework at runtime. Examples Examples of how to interact with the crypto registry: from aea.crypto.registries import crypto_registry , make_crypto , register_crypto # by default we can use the native cryptos fetchai_crypto = make_crypto ( \"fetchai\" ) # we can check what cryptos are registered crypto_registry . supported_ids # we can also add a new crypto to the registry register_crypto ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerCrypto\" ) # and then make it anywhere my_ledger_crypto = make_crypto ( \"my_ledger_id\" ) Examples of how to interact with the ledger API registry: from aea.crypto.registries import ledger_apis_registry , make_ledger_api , register_ledger_api # by default we can use the native ledger apis CONFIG = { \"network\" : \"testnet\" } fetchai_ledger_api = make_ledger_api ( \"fetchai\" , ** CONFIG ) # we can check what ledger apis are registered ledger_apis_registry . supported_ids # we can also add a new ledger api to the registry register_ledger_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerApi\" ) # and then make it anywhere my_ledger_api = make_ledger_api ( \"my_ledger_id\" ) Examples of how to interact with the faucet API registry: from aea.crypto.registries import faucet_apis_registry , make_faucet_api , register_faucet_api # by default we can use the native faucet apis CONFIG = dict ( poll_interval = 1.0 ) fetchai_faucet_api = make_faucet_api ( \"fetchai\" , ** CONFIG ) # we can check what faucet apis are registered faucet_apis_registry . supported_ids # we can also add a new faucet api to the registry register_faucet_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerFaucetApi\" ) # and then make it anywhere my_faucet_api = make_faucet_api ( \"my_ledger_id\" ) The framework wraps all LedgerApi classes and exposes them in the LedgerApis classes. The framework also wraps the crypto APIs to create identities on both ledgers and exposes them in the Wallet . The separation between the Crypto and LedgerApi is fundamental to the framework design. In particular, the object which holds the private key is separated from the object which interacts with the ledger. This design pattern is repeated throughout the framework: the decision maker is the only entity with access to the AEA's Wallet whilst LedgerApis are accessible by all skills. Capricorn - Fetch.ai testnet for agents Capricorn is our stable, public testnet for the Fetch Ledger v2. As such, most developers will be interacting with this testnet. This is specifically designed and supported for AEA development. Parameter Value Chain ID capricorn-1 Denomination atestfet Decimals 18 Version v0.8.x RPC Endpoint https://rpc-capricorn.fetch.ai:443 REST Endpoint https://rest-capricorn.fetch.ai:443 Block Explorer https://explore-capricorn.fetch.ai Token Faucet Use block explorer The configurations can be specified for the fetchai/ledger:0.19.0 connection. CosmWasm supporting chains The Fetch.ai networks use CosmWasm for smart contract support.","title":"Ledger & Crypto APIs"},{"location":"ledger-integration/#ledger-support","text":"For a ledger to be considered supported in the framework, three abstract base classes need to be implemented: the LedgerApi class wraps the API to talk to the ledger and its helper methods the Crypto class wraps the API to perform cryptographic operations for the relevant ledger the FaucetApi class wraps the API to talk to a faucet on a testnet These three classes have their own registries, which allow the developer to import the relevant object where needed.","title":"Ledger support"},{"location":"ledger-integration/#ledger-plug-in-architecture","text":"The AEA framework provides a plug-in mechanism to support ledger functionalities in an easily extendible way. At import time, the framework will load all the crypto plug-ins available in the current Python environment. A crypto plug-in is a Python package which declares some specific setuptools \"entry points\" in its setup.py script. In particular, there are three types of entry points the framework looks up: aea.ledger_apis , which points to instantiable classes implementing the LedgerApi interface; aea.cryptos , which points to instantiable classes implementing the Crypto interface; aea.faucet_apis , which points to instantiable classes implementing the FaucetApi interface. This is an example of setup.py script for a ledger plug-in open-aea-ledger-myledger : # sample ./setup.py file from setuptools import setup setup ( name = \"open-aea-ledger-myledger\" , packages = [ \"aea_ledger_myledger\" ], # plugins must depend on 'aea' install_requires = [ \"aea\" ], # add other dependencies... # the following makes a plugin available to aea entry_points = { \"aea.cryptos\" : [ \"myledger = aea_ledger_myledger:MyLedgerCrypto\" ], \"aea.ledger_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerApi\" ], \"aea.faucet_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerFaucetApi\" ], }, # PyPI classifier for AEA plugins classifiers = [ \"Framework :: AEA\" ], ) By convention, such plug-in packages should be named open-aea-ledger-${LEDGER_ID} , and the importable package name aea_ledger_${LEDGER_ID} . In the example above, the package name is open-aea-ledger-myledger , and the importable package name is aea_ledger_myledger . You can search for AEA ledger plug-ins on PyPI: https://pypi.org/search/?q=aea-ledger","title":"Ledger plug-in architecture"},{"location":"ledger-integration/#maintained-plug-ins","text":"At the moment, the framework natively supports the following three ledgers: Fetch.ai: PyPI package: open-aea-ledger-fetchai , and source code . Ethereum: PyPI package: open-aea-ledger-ethereum , and source code . Cosmos: PyPI package: open-aea-ledger-cosmos , and source code . However, support for additional ledgers can be added to the framework at runtime.","title":"Maintained plug-ins"},{"location":"ledger-integration/#examples","text":"Examples of how to interact with the crypto registry: from aea.crypto.registries import crypto_registry , make_crypto , register_crypto # by default we can use the native cryptos fetchai_crypto = make_crypto ( \"fetchai\" ) # we can check what cryptos are registered crypto_registry . supported_ids # we can also add a new crypto to the registry register_crypto ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerCrypto\" ) # and then make it anywhere my_ledger_crypto = make_crypto ( \"my_ledger_id\" ) Examples of how to interact with the ledger API registry: from aea.crypto.registries import ledger_apis_registry , make_ledger_api , register_ledger_api # by default we can use the native ledger apis CONFIG = { \"network\" : \"testnet\" } fetchai_ledger_api = make_ledger_api ( \"fetchai\" , ** CONFIG ) # we can check what ledger apis are registered ledger_apis_registry . supported_ids # we can also add a new ledger api to the registry register_ledger_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerApi\" ) # and then make it anywhere my_ledger_api = make_ledger_api ( \"my_ledger_id\" ) Examples of how to interact with the faucet API registry: from aea.crypto.registries import faucet_apis_registry , make_faucet_api , register_faucet_api # by default we can use the native faucet apis CONFIG = dict ( poll_interval = 1.0 ) fetchai_faucet_api = make_faucet_api ( \"fetchai\" , ** CONFIG ) # we can check what faucet apis are registered faucet_apis_registry . supported_ids # we can also add a new faucet api to the registry register_faucet_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerFaucetApi\" ) # and then make it anywhere my_faucet_api = make_faucet_api ( \"my_ledger_id\" ) The framework wraps all LedgerApi classes and exposes them in the LedgerApis classes. The framework also wraps the crypto APIs to create identities on both ledgers and exposes them in the Wallet . The separation between the Crypto and LedgerApi is fundamental to the framework design. In particular, the object which holds the private key is separated from the object which interacts with the ledger. This design pattern is repeated throughout the framework: the decision maker is the only entity with access to the AEA's Wallet whilst LedgerApis are accessible by all skills.","title":"Examples"},{"location":"ledger-integration/#capricorn-fetchai-testnet-for-agents","text":"Capricorn is our stable, public testnet for the Fetch Ledger v2. As such, most developers will be interacting with this testnet. This is specifically designed and supported for AEA development. Parameter Value Chain ID capricorn-1 Denomination atestfet Decimals 18 Version v0.8.x RPC Endpoint https://rpc-capricorn.fetch.ai:443 REST Endpoint https://rest-capricorn.fetch.ai:443 Block Explorer https://explore-capricorn.fetch.ai Token Faucet Use block explorer The configurations can be specified for the fetchai/ledger:0.19.0 connection.","title":"Capricorn - Fetch.ai testnet for agents"},{"location":"ledger-integration/#cosmwasm-supporting-chains","text":"The Fetch.ai networks use CosmWasm for smart contract support.","title":"CosmWasm supporting chains"},{"location":"limits/","text":"This document describes some of the limitations of v1 of the AEA framework and tradeoffs made in its design. Rejected ideas: Handlers implemented as behaviours: Handlers can be considered a special cases of a \"behaviour that listens for specific events to happen\". One could implement Handler classes in terms of Behaviours , after having implemented the feature that behaviours can be activated after an event happens (e.g. receiving a message of a certain protocol). This was rejected in favour of a clear separation of concerns, and to avoid purely reactive (handlers) and proactive (behaviours) components to be conflated into one concept. The proposal would also add complexity to behaviour development. Multiple versions of the same package The framework does not allow for the usage of multiple versions of the same package in a given project. Although one could re-engineer the project to allow for this, it does introduce significant additional complexities. Furthermore, Python modules are by design only allowed to exist as one version in a given process. Hence, it seems sensible to maintain this approach in the AEA. Potential extensions, considered yet not decided: Alternative skill design For very simple skills, the splitting of skills into Behaviour , Handler , Model and Task classes can add unnecessary complexity to the framework and a counter-intuitive responsibility split. The splitting also implies the framework needs to introduce the SkillContext object to allow for access to data across the skill. Furthermore, the framework requires implementing all functionality in SkillComponent classes Handler , Behaviour or Model . This approach is consistent and transparent, however it creates a lot of boiler plate code for simple skills. Hence, for some use cases it would be useful to have a single Skill class with abstract methods setup , act , handle and teardown . Then the developer can decide how to split up their code. class SkillTemplate(SimpleSkill): protocol_ids: Optional[List[PublicId]] = None def setup(): # setup skill def handle(message: Message): # handle messages def act(): for b in behaviours: b.act() def teardown(): # teardown skill Alternatively, we could use decorators to let a developer define whether a function is part of a handler or behaviour. That way, a single file with a number of functions could implement a skill. (Behind the scenes this would utilise a number of virtual Behaviour and Handler classes provided by the framework). The downside of this approach is that it does not advocate for much modularity on the skill level. Part of the role of a framework is to propose a common way to do things. The above approach can cause for a larger degree of heterogeneity in the skill design which makes it harder for developers to understand each others' code. The separation between all four base classes does exist both in convention and at the code level. Handlers deal with skill-external events (messages), behaviours deal with scheduled events (ticks), models represent data and tasks are used to manage long-running business logic. By adopting strong convention around skill development we allow for the framework to take a more active role in providing guarantees. E.g. handlers' and behaviours' execution can be limited to avoid them being blocking, models can be persisted and recreated, tasks can be executed with different task backends. The opinionated approach is thought to allow for better scaling. Further modularity for skill level code Currently we have three levels of modularity: PyPI packages framework packages: protocols, contracts, connections and skills framework plugins: CLI, ledger We could consider having a fourth level: common behaviours, handlers, models exposed as modules which can then speed up skill development. \"promise\" pattern: Given the asynchronous nature of the framework, it is often hard to implement reactions to specific messages, without making a \"fat\" handler. Take the example of a handler for a certain type of message A for a certain protocol p . The handler for protocol p would look something like this: class PHandler: ... def handle(msg): if message type is A: self._handle_a(msg) However, it could be helpful to overwrite this handler reaction with another callback (e.g. consider this in context ): # callable that handles the reply def my_callback(msg): # handle reply self.context.outbox.put_message(message, handler_func=my_callback, failure_func=...) This feature would introduce additional complexity for the framework to correctly wire up the callbacks and messages with the dialogues. CLI using standard lib Removing the click dependency from the CLI would further reduce the dependencies in the AEA framework which is overall desirable. Meta data vs configurations The current approach uses yaml files to specify both meta data and component configuration. It would be desirable to introduce the following separation: package metadata package default developer configuration package default user configuration A user can only configure a subset of the configuration. The developer should be able to define these constraints for the user. Similarly, a developer cannot modify all fields in a package, some of them are determined by the framework. Configuring agent goal setup By default, the agent's goals are implicitly defined by its skills and the configurations thereof. This is because the default decision maker signs every message and transaction presented to it. It is already possible to design a custom decision maker. However, more work needs to be done to understand how to improve the usability and configuration of the decision maker. In this context different types of decision makers can be implemented for the developer/user. Connection status monitoring Currently, connections are responsible for managing their own status after they have been \"connected\" by the Multiplexer . Developers writing connections must take care to properly set its connection status at all times and manage any disconnection. It would potentially be desirable to offer different policies to deal with connection problems on the multiplexer level: disconnect one, keep others alive disconnect all try reconnect indefinitely Agent snapshots on teardown or error Currently, the developer must implement snapshots on the component level. It would be desirable if the framework offered more help to persist the agent state on teardown or error. Dialogues management The current implementation of Dialogues is verbose. Developers often need to subclass Dialogues and Dialogue classes. More effort can be made to simplify and streamline dialogues management. Instantiate multiple instances of the same class of SkillComponent Currently, configuration and metadata of a package are conflated making it not straightforward to run one package component with multiple sets of configuration. It could be desirable to configure an agent to run a given package with multiple different configurations. This feature could be problematic with respect to component to component messaging which currently relies on component ids, which are bound to the package and not its instance. Containerized Agents Agent management, especially when many of them live on the same host, can be cumbersome. The framework should provide more utilities for these large-scale use cases. But a proper isolation of the agent environment is something that helps also simple use cases. A new software architecture, somehow inspired to the Docker system. The CLI only involves the initialization of the building of the agent (think of it as the specification of the Dockerfile : the Agentfile ), but the actual build and run are done by the AEA engine, a daemon process analogous of the Docker Engine, which exposes APIs for these operations. Users and developers would potentially like to run many AEAs of different versions and with differences in the versions of their dependencies. It is not possible to import different versions of the same Python (PyPI) package in the same process in a clean way. However, in different processes this is trivial with virtual environments. It would be desirable to consider this in the context of a container solution for agents. Dependency light version of the AEA framework The v1 of the Python AEA implementation makes every effort to minimise the amount of third-party dependencies. However, some dependencies remain to lower development time. It would be desirable to further reduce the dependencies, and potentially have an implementation that only relies on the Python standard library. This could be taken further, and a reduced spec version for micropython could be designed. Compiled AEA Python is not a compiled language. However, various projects attempt this, e.g. Nuitka and it would be desirable to explore how useful and practical this would be in the context of AEA. DID integration It would be great to integrate DID in the framework design, specifically identification of packages (most urgently protocols). Other projects and standards worth reviewing in the context (in particular with respect to identity): ERC 725: Ethereum Identity Standard and here . ERC 735: Claim Holder Optimise protocol schemas and messages The focus of protocol development was on extensibility and compatibility, not on optimisation. For instance, the dialogue references use inefficient string representations. Constraints on primitive types in protocols The protocol generator currently does not support custom constraints. The framework could add support for custom constraints for the protocol generator and specification. There are many types of constraints that could be supported in specification and generator. One could perhaps add support based on the popularity of specific constraints from users/developers. Example constraints: strings following specific regular expression format (e.g. all lower case, any arbitrary regex format) max number of elements on lists/sets keys in one dict type be equal to keys in another dict type other logical constraints, e.g. as supported in ontological languages support for bounds (i.e. min, max) for numerical types (i.e. int and float ) in protocol specification. Example syntax: pt:int[0, ] pt:float[1.0, 10.0] pt:int[-1000, 1000] pt:float[, 0] This would automatically enable support for signed/unsigned int and float . This syntax would allow for unbounded positive/negative/both, or arbitrary bounds to be placed on numerical types. Currently, the developer has to specify a custom type to implement any constraints on primitive types. Subprotocols & multi-party interactions Protocols can be allowed to depend on each other. Similarly, protocols might have multiple parties. Furthermore, a turn-taking function that specifies who's turn it is at any given point in the dialogue could be added. Then the current fipa setup is a specific case of turn-taking where the turn shifts after a player sends a single move (unique-reply). But generally, it does not have to be like this. Players could be allowed to send multiple messages until the turn shifts, or until they send specific speech-acts (multiple-replies). Timeouts in protocols Protocols currently do not implement the concept of timeouts. We leave it to the skill developer to implement any time-specific protocol rules. Framework internal messages The activation/deactivation of skills and addition/removal of components is implemented in a \"passive\" way - the skill posts a request in its skill context queue (in the case of new behaviours), or it just sets a flag (in case of activation/deactivation of skills). One could consider that a skill can send requests to the framework, via the internal protocol, to modify its resources or its status. The DecisionMaker or the Filter can be the components that take such actions. This is a further small but meaningful step toward an actor-based model for agent internals. Ledger transaction management Currently, the framework does not manage any aspect of submitting multiple transactions to the ledgers. This responsibility is left to skills. Additionally, the ledger APIs/contract APIs take the ledger as a reference to determine the nonce for a transaction. If a new transaction is sent before a previous transaction has been processed then the nonce will not be incremented correctly for the second transaction. This can lead to submissions of multiple transactions with the same nonce, and therefore failure of subsequent transactions. A naive approach would involve manually incrementing the nonce and then submitting transactions into the pool with the correct nonce for eventual inclusion. The problem with this approach is that any failure of a transaction will cause non of the subsequent transactions to be processed for some ledgers (https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high). To recover from a transaction failure not only the failed transaction would need to be handled, but potentially also all subsequent transactions. It is easy to see that logic required to recover from a transaction failure early in a sequence can be arbitrarily complex (involving potentially new negotiations between agents, new signatures having to be generated etc.). A further problem with the naive approach is that it (imperfectly) replicates the ledger state (with respect to (subset of state of) a specific account). A simple solution looks as follows: each time a transaction is constructed (requiring a new nonce) the transaction construction is queued until all previous transactions have been included in the ledger or failed. This way, at any one time the agent has only at most one transaction pending with the ledger. Benefits: simple to understand and maintain, transaction only enter the mempool when they are ready for inclusion which has privacy benefits over submitting a whole sequence of transaction at once. Downside: at most one transaction per block. This approach is currently used and implemented across all the reference skills. Related, the topic of latency in transactions. State channels provide a solution. E.g. Perun . There could also be an interesting overlap with our protocols here. Unsolved problems in Multiplexer - AgentLoop interplay Problem 1: connection generates too many messages in a short amount of time, that are not consumed by the multiplexer Solution: Can be solved by slowing down connections receive method called, controlled by the inbox messages amount Side effects: Most of the connections should have an internal queue because there is no synchronization between internal logic and multiplexer connection receive calls. Problem 2: the send method can take a long time (because send retries logic in connection) Solution: Currently, we apply timeouts on send. Other solutions could be considered, like parallelisation. Problem 3: too many messages are produced by a skill. Solution: Raise an exception on outbox is full or slow down agent loop? ACN Agent mobility on ACN If a peer-client or full client switches peer, then the DHT is not updated properly at the moment under certain conditions. Mailbox connection The two available connections p2p_libp2p and p2p_libp2p_client imply that the agent is continuously connected and therefore must have uninterrupted network access and the resources to maintain a connection. For more lightweight implementations, a mailbox connection is desirable, as outlined in the ACN documentation.","title":"Limitations of v1"},{"location":"limits/#rejected-ideas","text":"","title":"Rejected ideas:"},{"location":"limits/#handlers-implemented-as-behaviours","text":"Handlers can be considered a special cases of a \"behaviour that listens for specific events to happen\". One could implement Handler classes in terms of Behaviours , after having implemented the feature that behaviours can be activated after an event happens (e.g. receiving a message of a certain protocol). This was rejected in favour of a clear separation of concerns, and to avoid purely reactive (handlers) and proactive (behaviours) components to be conflated into one concept. The proposal would also add complexity to behaviour development.","title":"Handlers implemented as behaviours:"},{"location":"limits/#multiple-versions-of-the-same-package","text":"The framework does not allow for the usage of multiple versions of the same package in a given project. Although one could re-engineer the project to allow for this, it does introduce significant additional complexities. Furthermore, Python modules are by design only allowed to exist as one version in a given process. Hence, it seems sensible to maintain this approach in the AEA.","title":"Multiple versions of the same package"},{"location":"limits/#potential-extensions-considered-yet-not-decided","text":"","title":"Potential extensions, considered yet not decided:"},{"location":"limits/#alternative-skill-design","text":"For very simple skills, the splitting of skills into Behaviour , Handler , Model and Task classes can add unnecessary complexity to the framework and a counter-intuitive responsibility split. The splitting also implies the framework needs to introduce the SkillContext object to allow for access to data across the skill. Furthermore, the framework requires implementing all functionality in SkillComponent classes Handler , Behaviour or Model . This approach is consistent and transparent, however it creates a lot of boiler plate code for simple skills. Hence, for some use cases it would be useful to have a single Skill class with abstract methods setup , act , handle and teardown . Then the developer can decide how to split up their code. class SkillTemplate(SimpleSkill): protocol_ids: Optional[List[PublicId]] = None def setup(): # setup skill def handle(message: Message): # handle messages def act(): for b in behaviours: b.act() def teardown(): # teardown skill Alternatively, we could use decorators to let a developer define whether a function is part of a handler or behaviour. That way, a single file with a number of functions could implement a skill. (Behind the scenes this would utilise a number of virtual Behaviour and Handler classes provided by the framework). The downside of this approach is that it does not advocate for much modularity on the skill level. Part of the role of a framework is to propose a common way to do things. The above approach can cause for a larger degree of heterogeneity in the skill design which makes it harder for developers to understand each others' code. The separation between all four base classes does exist both in convention and at the code level. Handlers deal with skill-external events (messages), behaviours deal with scheduled events (ticks), models represent data and tasks are used to manage long-running business logic. By adopting strong convention around skill development we allow for the framework to take a more active role in providing guarantees. E.g. handlers' and behaviours' execution can be limited to avoid them being blocking, models can be persisted and recreated, tasks can be executed with different task backends. The opinionated approach is thought to allow for better scaling.","title":"Alternative skill design"},{"location":"limits/#further-modularity-for-skill-level-code","text":"Currently we have three levels of modularity: PyPI packages framework packages: protocols, contracts, connections and skills framework plugins: CLI, ledger We could consider having a fourth level: common behaviours, handlers, models exposed as modules which can then speed up skill development.","title":"Further modularity for skill level code"},{"location":"limits/#promise-pattern","text":"Given the asynchronous nature of the framework, it is often hard to implement reactions to specific messages, without making a \"fat\" handler. Take the example of a handler for a certain type of message A for a certain protocol p . The handler for protocol p would look something like this: class PHandler: ... def handle(msg): if message type is A: self._handle_a(msg) However, it could be helpful to overwrite this handler reaction with another callback (e.g. consider this in context ): # callable that handles the reply def my_callback(msg): # handle reply self.context.outbox.put_message(message, handler_func=my_callback, failure_func=...) This feature would introduce additional complexity for the framework to correctly wire up the callbacks and messages with the dialogues.","title":"\"promise\" pattern:"},{"location":"limits/#cli-using-standard-lib","text":"Removing the click dependency from the CLI would further reduce the dependencies in the AEA framework which is overall desirable.","title":"CLI using standard lib"},{"location":"limits/#meta-data-vs-configurations","text":"The current approach uses yaml files to specify both meta data and component configuration. It would be desirable to introduce the following separation: package metadata package default developer configuration package default user configuration A user can only configure a subset of the configuration. The developer should be able to define these constraints for the user. Similarly, a developer cannot modify all fields in a package, some of them are determined by the framework.","title":"Meta data vs configurations"},{"location":"limits/#configuring-agent-goal-setup","text":"By default, the agent's goals are implicitly defined by its skills and the configurations thereof. This is because the default decision maker signs every message and transaction presented to it. It is already possible to design a custom decision maker. However, more work needs to be done to understand how to improve the usability and configuration of the decision maker. In this context different types of decision makers can be implemented for the developer/user.","title":"Configuring agent goal setup"},{"location":"limits/#connection-status-monitoring","text":"Currently, connections are responsible for managing their own status after they have been \"connected\" by the Multiplexer . Developers writing connections must take care to properly set its connection status at all times and manage any disconnection. It would potentially be desirable to offer different policies to deal with connection problems on the multiplexer level: disconnect one, keep others alive disconnect all try reconnect indefinitely","title":"Connection status monitoring"},{"location":"limits/#agent-snapshots-on-teardown-or-error","text":"Currently, the developer must implement snapshots on the component level. It would be desirable if the framework offered more help to persist the agent state on teardown or error.","title":"Agent snapshots on teardown or error"},{"location":"limits/#dialogues-management","text":"The current implementation of Dialogues is verbose. Developers often need to subclass Dialogues and Dialogue classes. More effort can be made to simplify and streamline dialogues management.","title":"Dialogues management"},{"location":"limits/#instantiate-multiple-instances-of-the-same-class-of-skillcomponent","text":"Currently, configuration and metadata of a package are conflated making it not straightforward to run one package component with multiple sets of configuration. It could be desirable to configure an agent to run a given package with multiple different configurations. This feature could be problematic with respect to component to component messaging which currently relies on component ids, which are bound to the package and not its instance.","title":"Instantiate multiple instances of the same class of SkillComponent"},{"location":"limits/#containerized-agents","text":"Agent management, especially when many of them live on the same host, can be cumbersome. The framework should provide more utilities for these large-scale use cases. But a proper isolation of the agent environment is something that helps also simple use cases. A new software architecture, somehow inspired to the Docker system. The CLI only involves the initialization of the building of the agent (think of it as the specification of the Dockerfile : the Agentfile ), but the actual build and run are done by the AEA engine, a daemon process analogous of the Docker Engine, which exposes APIs for these operations. Users and developers would potentially like to run many AEAs of different versions and with differences in the versions of their dependencies. It is not possible to import different versions of the same Python (PyPI) package in the same process in a clean way. However, in different processes this is trivial with virtual environments. It would be desirable to consider this in the context of a container solution for agents.","title":"Containerized Agents"},{"location":"limits/#dependency-light-version-of-the-aea-framework","text":"The v1 of the Python AEA implementation makes every effort to minimise the amount of third-party dependencies. However, some dependencies remain to lower development time. It would be desirable to further reduce the dependencies, and potentially have an implementation that only relies on the Python standard library. This could be taken further, and a reduced spec version for micropython could be designed.","title":"Dependency light version of the AEA framework"},{"location":"limits/#compiled-aea","text":"Python is not a compiled language. However, various projects attempt this, e.g. Nuitka and it would be desirable to explore how useful and practical this would be in the context of AEA.","title":"Compiled AEA"},{"location":"limits/#did-integration","text":"It would be great to integrate DID in the framework design, specifically identification of packages (most urgently protocols). Other projects and standards worth reviewing in the context (in particular with respect to identity): ERC 725: Ethereum Identity Standard and here . ERC 735: Claim Holder","title":"DID integration"},{"location":"limits/#optimise-protocol-schemas-and-messages","text":"The focus of protocol development was on extensibility and compatibility, not on optimisation. For instance, the dialogue references use inefficient string representations.","title":"Optimise protocol schemas and messages"},{"location":"limits/#constraints-on-primitive-types-in-protocols","text":"The protocol generator currently does not support custom constraints. The framework could add support for custom constraints for the protocol generator and specification. There are many types of constraints that could be supported in specification and generator. One could perhaps add support based on the popularity of specific constraints from users/developers. Example constraints: strings following specific regular expression format (e.g. all lower case, any arbitrary regex format) max number of elements on lists/sets keys in one dict type be equal to keys in another dict type other logical constraints, e.g. as supported in ontological languages support for bounds (i.e. min, max) for numerical types (i.e. int and float ) in protocol specification. Example syntax: pt:int[0, ] pt:float[1.0, 10.0] pt:int[-1000, 1000] pt:float[, 0] This would automatically enable support for signed/unsigned int and float . This syntax would allow for unbounded positive/negative/both, or arbitrary bounds to be placed on numerical types. Currently, the developer has to specify a custom type to implement any constraints on primitive types.","title":"Constraints on primitive types in protocols"},{"location":"limits/#subprotocols-multi-party-interactions","text":"Protocols can be allowed to depend on each other. Similarly, protocols might have multiple parties. Furthermore, a turn-taking function that specifies who's turn it is at any given point in the dialogue could be added. Then the current fipa setup is a specific case of turn-taking where the turn shifts after a player sends a single move (unique-reply). But generally, it does not have to be like this. Players could be allowed to send multiple messages until the turn shifts, or until they send specific speech-acts (multiple-replies).","title":"Subprotocols &amp; multi-party interactions"},{"location":"limits/#timeouts-in-protocols","text":"Protocols currently do not implement the concept of timeouts. We leave it to the skill developer to implement any time-specific protocol rules.","title":"Timeouts in protocols"},{"location":"limits/#framework-internal-messages","text":"The activation/deactivation of skills and addition/removal of components is implemented in a \"passive\" way - the skill posts a request in its skill context queue (in the case of new behaviours), or it just sets a flag (in case of activation/deactivation of skills). One could consider that a skill can send requests to the framework, via the internal protocol, to modify its resources or its status. The DecisionMaker or the Filter can be the components that take such actions. This is a further small but meaningful step toward an actor-based model for agent internals.","title":"Framework internal messages"},{"location":"limits/#ledger-transaction-management","text":"Currently, the framework does not manage any aspect of submitting multiple transactions to the ledgers. This responsibility is left to skills. Additionally, the ledger APIs/contract APIs take the ledger as a reference to determine the nonce for a transaction. If a new transaction is sent before a previous transaction has been processed then the nonce will not be incremented correctly for the second transaction. This can lead to submissions of multiple transactions with the same nonce, and therefore failure of subsequent transactions. A naive approach would involve manually incrementing the nonce and then submitting transactions into the pool with the correct nonce for eventual inclusion. The problem with this approach is that any failure of a transaction will cause non of the subsequent transactions to be processed for some ledgers (https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high). To recover from a transaction failure not only the failed transaction would need to be handled, but potentially also all subsequent transactions. It is easy to see that logic required to recover from a transaction failure early in a sequence can be arbitrarily complex (involving potentially new negotiations between agents, new signatures having to be generated etc.). A further problem with the naive approach is that it (imperfectly) replicates the ledger state (with respect to (subset of state of) a specific account). A simple solution looks as follows: each time a transaction is constructed (requiring a new nonce) the transaction construction is queued until all previous transactions have been included in the ledger or failed. This way, at any one time the agent has only at most one transaction pending with the ledger. Benefits: simple to understand and maintain, transaction only enter the mempool when they are ready for inclusion which has privacy benefits over submitting a whole sequence of transaction at once. Downside: at most one transaction per block. This approach is currently used and implemented across all the reference skills. Related, the topic of latency in transactions. State channels provide a solution. E.g. Perun . There could also be an interesting overlap with our protocols here.","title":"Ledger transaction management"},{"location":"limits/#unsolved-problems-in-multiplexer-agentloop-interplay","text":"Problem 1: connection generates too many messages in a short amount of time, that are not consumed by the multiplexer Solution: Can be solved by slowing down connections receive method called, controlled by the inbox messages amount Side effects: Most of the connections should have an internal queue because there is no synchronization between internal logic and multiplexer connection receive calls. Problem 2: the send method can take a long time (because send retries logic in connection) Solution: Currently, we apply timeouts on send. Other solutions could be considered, like parallelisation. Problem 3: too many messages are produced by a skill. Solution: Raise an exception on outbox is full or slow down agent loop?","title":"Unsolved problems in Multiplexer - AgentLoop interplay"},{"location":"limits/#acn","text":"","title":"ACN"},{"location":"limits/#agent-mobility-on-acn","text":"If a peer-client or full client switches peer, then the DHT is not updated properly at the moment under certain conditions.","title":"Agent mobility on ACN"},{"location":"limits/#mailbox-connection","text":"The two available connections p2p_libp2p and p2p_libp2p_client imply that the agent is continuously connected and therefore must have uninterrupted network access and the resources to maintain a connection. For more lightweight implementations, a mailbox connection is desirable, as outlined in the ACN documentation.","title":"Mailbox connection"},{"location":"logging/","text":"The AEA framework supports flexible logging capabilities with the standard Python logging library . In this tutorial, we configure logging for an AEA. First of all, create your AEA. aea create my_aea cd my_aea The aea-config.yaml file should look like this. agent_name : my_aea author : fetchai version : 0.1.0 description : '' license : Apache-2.0 aea_version : 0.6.0 fingerprint : {} fingerprint_ignore_patterns : [] connections : - fetchai/stub:0.21.0 contracts : [] protocols : - fetchai/default:1.0.0 skills : - fetchai/error:0.17.0 default_connection : fetchai/stub:0.21.0 default_ledger : fetchai required_ledgers : - fetchai logging_config : disable_existing_loggers : false version : 1 private_key_paths : {} By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. Below is an example of the logging_config value. logging_config : version : 1 disable_existing_loggers : False formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : False This configuration will set up a logger with name aea . It prints both on console and on file with a format specified by the standard formatter. Streaming to browser It is possible to configure the AEA to stream logs to a browser. First, add the following configuration to your AEA: logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : http : class : logging.handlers.HTTPHandler formatter : standard level : INFO host : localhost:5000 url : /stream method : POST loggers : aea : handlers : - http level : INFO propagate : false Second, create a log server: # -*- coding: utf-8 -*- \"\"\"A simple flask server to serve logs.\"\"\" import datetime import itertools import queue from flask import Flask , Response , request , stream_with_context def format_log ( log_dict ): \"\"\"Format a log record.\"\"\" date = datetime . datetime . fromtimestamp ( float ( log_dict [ \"created\" ])) formatted_log = f \"[ { date . isoformat () } ] [ { log_dict [ 'levelname' ] } ] { log_dict [ 'name' ] } : { log_dict [ 'msg' ] } \" return formatted_log def create_app (): \"\"\"Create Flask app for streaming logs.\"\"\" all_logs = [] unread_logs = queue . Queue () app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): \"\"\"Stream logs to client.\"\"\" def generate (): # stream old logs div = \"<div> {} </div>\" for old_row in all_logs : yield div . format ( old_row ) # stream unread logs while True : row = unread_logs . get () all_logs . append ( row ) yield f \"<div> { row } </div>\" rows = generate () title = \"<p>Waiting for logs...</p>\" return Response ( stream_with_context ( itertools . chain ([ title ], rows ))) @app . route ( \"/stream\" , methods = [ \"POST\" ]) def stream (): \"\"\"Save log record from AEA.\"\"\" log_record_formatted = format_log ( dict ( request . form )) unread_logs . put ( log_record_formatted ) return {}, 200 app . run () if __name__ == \"__main__\" : create_app () Save the script in a file called server.py , install flask with pip install flask and run the server with python server.py . Third, run your AEA and visit localhost:5000 in your browser.","title":"Logging"},{"location":"logging/#streaming-to-browser","text":"It is possible to configure the AEA to stream logs to a browser. First, add the following configuration to your AEA: logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : http : class : logging.handlers.HTTPHandler formatter : standard level : INFO host : localhost:5000 url : /stream method : POST loggers : aea : handlers : - http level : INFO propagate : false Second, create a log server: # -*- coding: utf-8 -*- \"\"\"A simple flask server to serve logs.\"\"\" import datetime import itertools import queue from flask import Flask , Response , request , stream_with_context def format_log ( log_dict ): \"\"\"Format a log record.\"\"\" date = datetime . datetime . fromtimestamp ( float ( log_dict [ \"created\" ])) formatted_log = f \"[ { date . isoformat () } ] [ { log_dict [ 'levelname' ] } ] { log_dict [ 'name' ] } : { log_dict [ 'msg' ] } \" return formatted_log def create_app (): \"\"\"Create Flask app for streaming logs.\"\"\" all_logs = [] unread_logs = queue . Queue () app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): \"\"\"Stream logs to client.\"\"\" def generate (): # stream old logs div = \"<div> {} </div>\" for old_row in all_logs : yield div . format ( old_row ) # stream unread logs while True : row = unread_logs . get () all_logs . append ( row ) yield f \"<div> { row } </div>\" rows = generate () title = \"<p>Waiting for logs...</p>\" return Response ( stream_with_context ( itertools . chain ([ title ], rows ))) @app . route ( \"/stream\" , methods = [ \"POST\" ]) def stream (): \"\"\"Save log record from AEA.\"\"\" log_record_formatted = format_log ( dict ( request . form )) unread_logs . put ( log_record_formatted ) return {}, 200 app . run () if __name__ == \"__main__\" : create_app () Save the script in a file called server.py , install flask with pip install flask and run the server with python server.py . Third, run your AEA and visit localhost:5000 in your browser.","title":"Streaming to browser"},{"location":"message-routing/","text":"Message routing can be split up into the routing of incoming and outgoing Messages . It is important to keep in mind that interaction protocols can be maintained between agents (agent to agent) and between components of the AEA (component to component). In the former case, the to / sender fields of the Envelope are agent addresses which must follow the address standard of agents, in the latter case they are component public ids. Crucially, both addresses must reference the same type: agent or component. Incoming Messages Connections receive or create Envelopes which they deposit in the InBox for agent-to-agent communication only, the Multiplexer keeps track of the connection_id via which the Envelope was received. the AgentLoop picks Envelopes off the InBox the AEA tries to decode the message; errors are handled by the ErrorHandler Messages are dispatched based on two rules: checks if to field can be interpreted as skill_id , if so uses that together with the protocol_id to dispatch to the protocol's Handler in the specified Skill , else uses the protocol_id to dispatch to the protocol's Handler in all skills supporting the protocol. Note For agent-to-agent communication it is advisable to have a single skill implement a given protocol. Skills can then forward the messages via skill-to-skill communication to other skills where required. Otherwise, received agent-to-agent messages will be forwarded to all skills implementing a handler for the specified protocol and the developer needs to take care to handle them appropriately (e.g. avoid multiple replies to a single message). Outgoing Messages Skills deposit Messages in OutBox OutBox constructs an Envelope from the Message Multiplexer assigns messages to relevant Connection based on the following rules: Component to component messages are routed by their component_id Agent to agent messages are routed following four rules: checks if EnvelopeContext exists and specifies a Connection , if so uses that else checks which connection handled the last message from sender , if present uses that else checks if default routing is specified for the protocol_id referenced in the Envelope , if so uses that else sends to default Connection . Connections can process Envelopes directly or encode them for transport to another agent. Usage of the EnvelopeContext The EnvelopeContext is used to maintain agent-to-agent communication only and is managed almost entirely by the framework. The developer can set the EnvelopeContext explicitly for the first message in a dialogue to achieve targeted routing to connections (see 2. for outgoing messages). This is relevant when the same agent can be reached via multiple connections. The EnvelopeContext is not sent to another agent.","title":"Message routing"},{"location":"message-routing/#incoming-messages","text":"Connections receive or create Envelopes which they deposit in the InBox for agent-to-agent communication only, the Multiplexer keeps track of the connection_id via which the Envelope was received. the AgentLoop picks Envelopes off the InBox the AEA tries to decode the message; errors are handled by the ErrorHandler Messages are dispatched based on two rules: checks if to field can be interpreted as skill_id , if so uses that together with the protocol_id to dispatch to the protocol's Handler in the specified Skill , else uses the protocol_id to dispatch to the protocol's Handler in all skills supporting the protocol. Note For agent-to-agent communication it is advisable to have a single skill implement a given protocol. Skills can then forward the messages via skill-to-skill communication to other skills where required. Otherwise, received agent-to-agent messages will be forwarded to all skills implementing a handler for the specified protocol and the developer needs to take care to handle them appropriately (e.g. avoid multiple replies to a single message).","title":"Incoming Messages"},{"location":"message-routing/#outgoing-messages","text":"Skills deposit Messages in OutBox OutBox constructs an Envelope from the Message Multiplexer assigns messages to relevant Connection based on the following rules: Component to component messages are routed by their component_id Agent to agent messages are routed following four rules: checks if EnvelopeContext exists and specifies a Connection , if so uses that else checks which connection handled the last message from sender , if present uses that else checks if default routing is specified for the protocol_id referenced in the Envelope , if so uses that else sends to default Connection . Connections can process Envelopes directly or encode them for transport to another agent.","title":"Outgoing Messages"},{"location":"message-routing/#usage-of-the-envelopecontext","text":"The EnvelopeContext is used to maintain agent-to-agent communication only and is managed almost entirely by the framework. The developer can set the EnvelopeContext explicitly for the first message in a dialogue to achieve targeted routing to connections (see 2. for outgoing messages). This is relevant when the same agent can be reached via multiple connections. The EnvelopeContext is not sent to another agent.","title":"Usage of the EnvelopeContext"},{"location":"modes/","text":"We can run an AEA in multiple modes thanks to the configurable design of the framework. The AEA contains two runnable parts, the AgentLoop , which operates the skills, and the Multiplexer, which operates the connections. The AgentLoop can be configured to run in async or sync mode. The Multiplexer by default runs in async mode. The AEA itself, can be configured to run in async mode, if both the Multiplexer and AgentLoop have the same mode, or in threaded mode. The latter ensures that AgentLoop and Multiplexer are run in separate threads.","title":"Modes of running an AEA"},{"location":"multi-agent-manager/","text":"The MultiAgentManager allows managing multiple agent projects programmatically. Setup We instantiate the manager by providing it with the working directory in which to operate and starting it: import os from pathlib import Path from aea.manager import MultiAgentManager WORKING_DIR = \"mam\" manager = MultiAgentManager ( WORKING_DIR ) manager . start_manager () Adding projects We first add a couple of finished AEA project: from aea.configurations.base import PublicId weather_station_id = PublicId . from_str ( \"fetchai/weather_station:0.31.0\" ) weather_client_id = PublicId . from_str ( \"fetchai/weather_client:0.32.0\" ) manager . add_project ( weather_station_id ) manager . add_project ( weather_client_id ) weather_station_name = weather_station_id . name weather_client_name = weather_client_id . name Adding agent instances Add the agent instances agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } p2p_public_id = PublicId . from_str ( \"fetchai/p2p_libp2p:0.25.0\" ) soef_public_id = PublicId . from_str ( \"fetchai/soef:0.26.0\" ) component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_station_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"config\" : { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ '/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAkzgZYyk25XjAhmgXcdMbahrHYi18uuAzHuxPn1KkdmLRw' ], \"local_uri\" : \"127.0.0.1:9001\" , \"public_uri\" : \"127.0.0.1:9001\" , }, \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_client_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) Save the following private keys in the respective files. FET_PRIVATE_KEY_STATION = b \"72d3149f5689f0749eaec5ebf6dba5deeb1e89b93ae1c58c71fd43dfaa231e87\" FET_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_PRIVATE_KEY_STATION ) FET_CONNECTION_PRIVATE_KEY_STATION = b \"bf529acb2546e13615ef6004c48e393f0638a5dc0c4979631a9a4bc554079f6f\" FET_CONNECTION_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_CONNECTION_PRIVATE_KEY_STATION ) FET_PRIVATE_KEY_CLIENT = b \"589839ae54b71b8754a7fe96b52045364077c28705a1806b74441debcae16e0a\" FET_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_PRIVATE_KEY_CLIENT ) FET_CONNECTION_PRIVATE_KEY_CLIENT = b \"c9b38eff57f678f5ab5304447997351edb08eceb883267fa4ad849074bec07e4\" FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_CONNECTION_PRIVATE_KEY_CLIENT ) Running the agents: import time manager . start_agent ( weather_station_id . name ) # wait for ~10 seconds for peer node to go live time . sleep ( 10.0 ) manager . start_agent ( weather_client_id . name ) time . sleep ( 5.0 ) Stopping the agents: manager . stop_all_agents () Cleaning up manager . stop_manager () Limitations The MultiAgentManager can only be used with compatible package versions, in particular the same package (with respect to author and name) cannot be used in different versions. If you want to run multiple agents with differing versions of the same package then use the aea launch command in the multi-processing mode, or simply launch each agent individually with aea run .","title":"Multi agent manager"},{"location":"multi-agent-manager/#setup","text":"We instantiate the manager by providing it with the working directory in which to operate and starting it: import os from pathlib import Path from aea.manager import MultiAgentManager WORKING_DIR = \"mam\" manager = MultiAgentManager ( WORKING_DIR ) manager . start_manager ()","title":"Setup"},{"location":"multi-agent-manager/#adding-projects","text":"We first add a couple of finished AEA project: from aea.configurations.base import PublicId weather_station_id = PublicId . from_str ( \"fetchai/weather_station:0.31.0\" ) weather_client_id = PublicId . from_str ( \"fetchai/weather_client:0.32.0\" ) manager . add_project ( weather_station_id ) manager . add_project ( weather_client_id ) weather_station_name = weather_station_id . name weather_client_name = weather_client_id . name","title":"Adding projects"},{"location":"multi-agent-manager/#adding-agent-instances","text":"Add the agent instances agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } p2p_public_id = PublicId . from_str ( \"fetchai/p2p_libp2p:0.25.0\" ) soef_public_id = PublicId . from_str ( \"fetchai/soef:0.26.0\" ) component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_station_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"config\" : { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ '/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAkzgZYyk25XjAhmgXcdMbahrHYi18uuAzHuxPn1KkdmLRw' ], \"local_uri\" : \"127.0.0.1:9001\" , \"public_uri\" : \"127.0.0.1:9001\" , }, \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_client_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) Save the following private keys in the respective files. FET_PRIVATE_KEY_STATION = b \"72d3149f5689f0749eaec5ebf6dba5deeb1e89b93ae1c58c71fd43dfaa231e87\" FET_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_PRIVATE_KEY_STATION ) FET_CONNECTION_PRIVATE_KEY_STATION = b \"bf529acb2546e13615ef6004c48e393f0638a5dc0c4979631a9a4bc554079f6f\" FET_CONNECTION_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_CONNECTION_PRIVATE_KEY_STATION ) FET_PRIVATE_KEY_CLIENT = b \"589839ae54b71b8754a7fe96b52045364077c28705a1806b74441debcae16e0a\" FET_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_PRIVATE_KEY_CLIENT ) FET_CONNECTION_PRIVATE_KEY_CLIENT = b \"c9b38eff57f678f5ab5304447997351edb08eceb883267fa4ad849074bec07e4\" FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_CONNECTION_PRIVATE_KEY_CLIENT )","title":"Adding agent instances"},{"location":"multi-agent-manager/#running-the-agents","text":"import time manager . start_agent ( weather_station_id . name ) # wait for ~10 seconds for peer node to go live time . sleep ( 10.0 ) manager . start_agent ( weather_client_id . name ) time . sleep ( 5.0 )","title":"Running the agents:"},{"location":"multi-agent-manager/#stopping-the-agents","text":"manager . stop_all_agents ()","title":"Stopping the agents:"},{"location":"multi-agent-manager/#cleaning-up","text":"manager . stop_manager ()","title":"Cleaning up"},{"location":"multi-agent-manager/#limitations","text":"The MultiAgentManager can only be used with compatible package versions, in particular the same package (with respect to author and name) cannot be used in different versions. If you want to run multiple agents with differing versions of the same package then use the aea launch command in the multi-processing mode, or simply launch each agent individually with aea run .","title":"Limitations"},{"location":"multiplexer-standalone/","text":"The Multiplexer can be used stand-alone. This way a developer can utilise the protocols and connections independent of the Agent or AEA classes. First, import the Python and application specific libraries and set the static variables. (Get the packages directory from the AEA repository svn export https://github.com/valory-xyz/open-aea.git/trunk/packages .) import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" Instantiate a Multiplexer A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ]) Start the Multiplexer We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) Shutdown Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join () Your turn Now it is your turn to develop a simple use case which utilises the Multiplexer to send and receive Envelopes. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Use multiplexer stand-alone"},{"location":"multiplexer-standalone/#instantiate-a-multiplexer","text":"A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ])","title":"Instantiate a Multiplexer"},{"location":"multiplexer-standalone/#start-the-multiplexer","text":"We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" )","title":"Start the Multiplexer"},{"location":"multiplexer-standalone/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"multiplexer-standalone/#shutdown","text":"Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join ()","title":"Shutdown"},{"location":"multiplexer-standalone/#your-turn","text":"Now it is your turn to develop a simple use case which utilises the Multiplexer to send and receive Envelopes.","title":"Your turn"},{"location":"multiplexer-standalone/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"p2p-connection/","text":"The valory/p2p_libp2p:0.26.0 connection allows AEAs to create a peer-to-peer communication network. In particular, the connection creates an overlay network which maps agents' public keys to IP addresses. Local demo Note Currently p2p_libp2p does not support the ethereum keys generated by open-aea-ledger-ethereum yet. This does not affect the agents' ability to interact with the ethereum ledger and solely necessitates a separate set of cosmos keys for establishing the libp2p connection. First, make sure you have installed the crypto plugin of the target test-net. pip install open-aea-ledger-cosmos pip install open-aea-ledger-ethereum Create and run the genesis AEA Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection valory/p2p_libp2p:0.1.0 aea config set agent.default_connection valory/p2p_libp2p:0.1.0 aea install aea build Establish the proof of representation : aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea generate-key cosmos cosmos_connection_private_key.txt aea add-key cosmos cosmos_connection_private_key.txt --connection aea issue-certificates Run the AEA: aea run --connections valory/p2p_libp2p:0.1.0 Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress open-aea -c -i valory/p2p_libp2p:0.1.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the genesis AEA. Create and run another AEA Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection valory/p2p_libp2p:0.1.0 aea config set agent.default_connection valory/p2p_libp2p:0.1.0 aea install aea build Establish the proof of representation : aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea generate-key cosmos cosmos_connection_private_key.txt aea add-key cosmos cosmos_connection_private_key.txt --connection aea issue-certificates Provide the AEA with the information it needs to find the genesis: aea config set --type dict vendor.valory.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [<AEA_P2P_ENTRY_URI_1>, <AEA_P2P_ENTRY_URI_2>], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Here [<AEA_P2P_ENTRY_URI_1>, <AEA_P2P_ENTRY_URI_2>] represents a list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections valory/p2p_libp2p:0.1.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other. Note Currently p2p_libp2p connection limits the total message size to 3 MB. Deployed agent communication network You can connect to the deployed public test network by adding one or multiple of the following addresses as the p2p_libp2p connection's entry_peers : /dns4/staging.acn.autonolas.tech/tcp/9003/p2p/16Uiu2HAkzqwxz5HdbnXS6mB4nTwJ3WysQa6udvbZ3te2sCHZ6ih2 /dns4/staging.acn.autonolas.tech/tcp/9004/p2p/16Uiu2HAmCQqXLFWaqqUv8hFdFPDwwNQf9qEQox8Kcf78heb33e7x Specifically, in an AEAs configuration aea-config.yaml add the above addresses for entry_peers as follows: --- public_id : valory/p2p_libp2p:0.1.0 type : connection config : delegate_uri : null entry_peers : [ /dns4/staging.acn.autonolas.tech/tcp/9003/p2p/16Uiu2HAkzqwxz5HdbnXS6mB4nTwJ3WysQa6udvbZ3te2sCHZ6ih2 , /dns4/staging.acn.autonolas.tech/tcp/9004/p2p/16Uiu2HAmCQqXLFWaqqUv8hFdFPDwwNQf9qEQox8Kcf78heb33e7x ] public_uri : null local_uri : 127.0.0.1:9001 Note, this configuration change must be made for all agents attempting to communicate with each other via the Agent Communication Network. For example, in demos involving two agents, both agents will need the above modifications to their respective aea-config.yaml file. However, remember to use different ports in local_uri. This will allow both agents to default to this communication network without the added overhead of opening ports and specifying hosts on the individual host machines running each agent. Configuring the connection.yaml entries: To learn more about how to configure your valory/p2p_libp2p:0.1.0 connection consult the README.md file supplied with the connection package. Running Go peer standalone You can run a peer node in standalone mode ; that is, as a Go process with no dependency on the AEA framework. To facilitate such a deployment, we provide a script run_acn_node_standalone.py and a corresponding Dockerfile . First, you need to build the node's binary ( libp2p_node ) either: locally git clone https://github.com/valory-xyz/open-acn/ cd open-acn go build chmod +x libp2p_node Make sure you satisfy the system requirements . or within a docker image using the provided Dockerfile: docker build -t acn_node_standalone -f scripts/acn/Dockerfile . Next, to run the node binary in standalone mode, it requires values for the following entries: AEA_P2P_ID : the node's private key, will be used as its identity AEA_P2P_URI : the local host and port to use by node AEA_P2P_URI_PUBLIC : the URI under which the peer is publicly reachable AEA_P2P_DELEGATE_URI : the URI under which the peer receives delegate connections AEA_P2P_ENTRY_URIS : an optionally supplied list of comma-separated ( , ) entry Multiaddrs for the peer to bootstrap The script allows different methods to pass these values to the node: As environment variables exported in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> for each entry. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-env Using an environment file containing the entries and their values in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> , one entry per line. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-file <env-file-path> or docker run -v <acn_config_file>:/acn/acn_config -it acn_node_standalone --config-from-file /acn/acn_config Using command line arguments: python3 run_acn_node_standalone.py libp2p_node --key-file <node_private_key.txt> \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... or docker run -v <node_private_key.txt>:/acn/key.txt -it acn_node_standalone --key-file /acn/key.txt \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... Note that the script will always save the configuration of the running node as a file under the name .acn_config in the current working directory. This can be handy when you want the exact same configuration for future runs of the node.","title":"ACN Connections"},{"location":"p2p-connection/#local-demo","text":"Note Currently p2p_libp2p does not support the ethereum keys generated by open-aea-ledger-ethereum yet. This does not affect the agents' ability to interact with the ethereum ledger and solely necessitates a separate set of cosmos keys for establishing the libp2p connection. First, make sure you have installed the crypto plugin of the target test-net. pip install open-aea-ledger-cosmos pip install open-aea-ledger-ethereum","title":"Local demo"},{"location":"p2p-connection/#create-and-run-the-genesis-aea","text":"Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection valory/p2p_libp2p:0.1.0 aea config set agent.default_connection valory/p2p_libp2p:0.1.0 aea install aea build Establish the proof of representation : aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea generate-key cosmos cosmos_connection_private_key.txt aea add-key cosmos cosmos_connection_private_key.txt --connection aea issue-certificates Run the AEA: aea run --connections valory/p2p_libp2p:0.1.0 Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress open-aea -c -i valory/p2p_libp2p:0.1.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the genesis AEA.","title":"Create and run the genesis AEA"},{"location":"p2p-connection/#create-and-run-another-aea","text":"Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection valory/p2p_libp2p:0.1.0 aea config set agent.default_connection valory/p2p_libp2p:0.1.0 aea install aea build Establish the proof of representation : aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt aea generate-key cosmos cosmos_connection_private_key.txt aea add-key cosmos cosmos_connection_private_key.txt --connection aea issue-certificates Provide the AEA with the information it needs to find the genesis: aea config set --type dict vendor.valory.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [<AEA_P2P_ENTRY_URI_1>, <AEA_P2P_ENTRY_URI_2>], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Here [<AEA_P2P_ENTRY_URI_1>, <AEA_P2P_ENTRY_URI_2>] represents a list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections valory/p2p_libp2p:0.1.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other. Note Currently p2p_libp2p connection limits the total message size to 3 MB.","title":"Create and run another AEA"},{"location":"p2p-connection/#deployed-agent-communication-network","text":"You can connect to the deployed public test network by adding one or multiple of the following addresses as the p2p_libp2p connection's entry_peers : /dns4/staging.acn.autonolas.tech/tcp/9003/p2p/16Uiu2HAkzqwxz5HdbnXS6mB4nTwJ3WysQa6udvbZ3te2sCHZ6ih2 /dns4/staging.acn.autonolas.tech/tcp/9004/p2p/16Uiu2HAmCQqXLFWaqqUv8hFdFPDwwNQf9qEQox8Kcf78heb33e7x Specifically, in an AEAs configuration aea-config.yaml add the above addresses for entry_peers as follows: --- public_id : valory/p2p_libp2p:0.1.0 type : connection config : delegate_uri : null entry_peers : [ /dns4/staging.acn.autonolas.tech/tcp/9003/p2p/16Uiu2HAkzqwxz5HdbnXS6mB4nTwJ3WysQa6udvbZ3te2sCHZ6ih2 , /dns4/staging.acn.autonolas.tech/tcp/9004/p2p/16Uiu2HAmCQqXLFWaqqUv8hFdFPDwwNQf9qEQox8Kcf78heb33e7x ] public_uri : null local_uri : 127.0.0.1:9001 Note, this configuration change must be made for all agents attempting to communicate with each other via the Agent Communication Network. For example, in demos involving two agents, both agents will need the above modifications to their respective aea-config.yaml file. However, remember to use different ports in local_uri. This will allow both agents to default to this communication network without the added overhead of opening ports and specifying hosts on the individual host machines running each agent.","title":"Deployed agent communication network"},{"location":"p2p-connection/#configuring-the-connectionyaml-entries","text":"To learn more about how to configure your valory/p2p_libp2p:0.1.0 connection consult the README.md file supplied with the connection package.","title":"Configuring the connection.yaml entries:"},{"location":"p2p-connection/#running-go-peer-standalone","text":"You can run a peer node in standalone mode ; that is, as a Go process with no dependency on the AEA framework. To facilitate such a deployment, we provide a script run_acn_node_standalone.py and a corresponding Dockerfile . First, you need to build the node's binary ( libp2p_node ) either: locally git clone https://github.com/valory-xyz/open-acn/ cd open-acn go build chmod +x libp2p_node Make sure you satisfy the system requirements . or within a docker image using the provided Dockerfile: docker build -t acn_node_standalone -f scripts/acn/Dockerfile . Next, to run the node binary in standalone mode, it requires values for the following entries: AEA_P2P_ID : the node's private key, will be used as its identity AEA_P2P_URI : the local host and port to use by node AEA_P2P_URI_PUBLIC : the URI under which the peer is publicly reachable AEA_P2P_DELEGATE_URI : the URI under which the peer receives delegate connections AEA_P2P_ENTRY_URIS : an optionally supplied list of comma-separated ( , ) entry Multiaddrs for the peer to bootstrap The script allows different methods to pass these values to the node: As environment variables exported in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> for each entry. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-env Using an environment file containing the entries and their values in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> , one entry per line. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-file <env-file-path> or docker run -v <acn_config_file>:/acn/acn_config -it acn_node_standalone --config-from-file /acn/acn_config Using command line arguments: python3 run_acn_node_standalone.py libp2p_node --key-file <node_private_key.txt> \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... or docker run -v <node_private_key.txt>:/acn/key.txt -it acn_node_standalone --key-file /acn/key.txt \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... Note that the script will always save the configuration of the running node as a file under the name .acn_config in the current working directory. This can be handy when you want the exact same configuration for future runs of the node.","title":"Running Go peer standalone"},{"location":"package-imports/","text":"An agent that is generated using the AEA framework is a modular system with different connections, contracts, protocols and skills. File structure The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry (local or remote - added via aea fetch or aea add ) are located in vendor and sorted by author. Build artefacts are placed in the .build/ directory and certificates are placed in the .certs/ directory. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fetchai_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same. AEA Configuration YAML The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.21.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package. Vendor and package directories The vendor folder contains the packages from the registry (local or remote) which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder. Importing modules from packages The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem. Python dependencies of packages Python dependencies of packages are specified in their respective configuration files under dependencies . They will be installed when aea install is run on an agent project. Create a package If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ). Use published packages from the registry If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local . Package versioning By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 . If two AEA packages with the same author and name but different versions are used in the same Python process, then only the code from one of the packages (generally not deterministic) will be available in sys.modules . This can lead to inconsistencies and exceptions at runtime.","title":"File structure"},{"location":"package-imports/#file-structure","text":"The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry (local or remote - added via aea fetch or aea add ) are located in vendor and sorted by author. Build artefacts are placed in the .build/ directory and certificates are placed in the .certs/ directory. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fetchai_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same.","title":"File structure"},{"location":"package-imports/#aea-configuration-yaml","text":"The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.21.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package.","title":"AEA Configuration YAML"},{"location":"package-imports/#vendor-and-package-directories","text":"The vendor folder contains the packages from the registry (local or remote) which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder.","title":"Vendor and package directories"},{"location":"package-imports/#importing-modules-from-packages","text":"The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem.","title":"Importing modules from packages"},{"location":"package-imports/#python-dependencies-of-packages","text":"Python dependencies of packages are specified in their respective configuration files under dependencies . They will be installed when aea install is run on an agent project.","title":"Python dependencies of packages"},{"location":"package-imports/#create-a-package","text":"If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ).","title":"Create a package"},{"location":"package-imports/#use-published-packages-from-the-registry","text":"If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local .","title":"Use published packages from the registry"},{"location":"package-imports/#package-versioning","text":"By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 . If two AEA packages with the same author and name but different versions are used in the same Python process, then only the code from one of the packages (generally not deterministic) will be available in sys.modules . This can lead to inconsistencies and exceptions at runtime.","title":"Package versioning"},{"location":"performance-benchmark/","text":"Test AEA framework performance. What is it? The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results. How does it work? The framework: spawns a dedicated process for each test run to execute the function to test. measures CPU and RAM usage periodically. waits for function exits or terminates them by timeout. repeats test execution multiple times to get more accurate results. How to use Steps to run a test: Write a function you would like to test with all arguments you would like to parametrise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results. Simple example cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution. Requirements for tested function The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while. Execution options To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by white space 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values. Limitations Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually. Testing AEA: handlers example Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () Create AEA wrapper with specified handler: skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) Populate inbox with dummy messages: for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) Set timeout 0 , for maximum messages processing speed: aea_test_wrapper.set_loop_timeout(0.0) Start benchmark: benchmark.start() Start/stop AEA: aea_test_wrapper . start () ... aea_test_wrapper . stop () Wait till messages present in inbox: while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Performance benchmark"},{"location":"performance-benchmark/#what-is-it","text":"The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results.","title":"What is it?"},{"location":"performance-benchmark/#how-does-it-work","text":"The framework: spawns a dedicated process for each test run to execute the function to test. measures CPU and RAM usage periodically. waits for function exits or terminates them by timeout. repeats test execution multiple times to get more accurate results.","title":"How does it work?"},{"location":"performance-benchmark/#how-to-use","text":"Steps to run a test: Write a function you would like to test with all arguments you would like to parametrise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results.","title":"How to use"},{"location":"performance-benchmark/#simple-example","text":"cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution.","title":"Simple example"},{"location":"performance-benchmark/#requirements-for-tested-function","text":"The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while.","title":"Requirements for tested function"},{"location":"performance-benchmark/#execution-options","text":"To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by white space 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values.","title":"Execution options"},{"location":"performance-benchmark/#limitations","text":"Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually.","title":"Limitations"},{"location":"performance-benchmark/#testing-aea-handlers-example","text":"Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () Create AEA wrapper with specified handler: skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) Populate inbox with dummy messages: for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) Set timeout 0 , for maximum messages processing speed: aea_test_wrapper.set_loop_timeout(0.0) Start benchmark: benchmark.start() Start/stop AEA: aea_test_wrapper . start () ... aea_test_wrapper . stop () Wait till messages present in inbox: while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Testing AEA: handlers example"},{"location":"por/","text":"An AEA can use several key pairs. In particular, it can use different keys for securing its communication and for engaging in exchange. In the ACN we make use of this fact. To be able to signal to other agents that the address derived from one key pair is allowed to represent the agent controlling the other key pair, the key pair which is being represented must sign a message to prove that the other key pair is allowed to represent it. The aea issue-certificates command allows to create this association. The proof of representation feature is used in the context of the fetchai/p2p_libp2p and fetchai/p2p_libp2p_client connection. In the former connection, the configuration YAML specifies a cert_requests field: cert_requests : - identifier : acn ledger_id : fetchai not_after : '2022-01-01' not_before : '2021-01-01' public_key : fetchai message_format : '{public_key}' save_path : .certs/conn_cert.txt The identifier refers to the environment for which the signature is generated, here acn . The ledger_id refers to the key pair to be used from the private_key_paths specified in aea-config.yaml for signing. The not_after and not_before fields specify constraints on the validity of the signature. The public_key can specify either the identifier of the key pair in connection_private_key_paths of which the public key is signed or it can contain the to be signed public key in plain text. The save_path specifies the path where the certificate is to be saved at. In the above example, the connection requests a certificate which is a signature of the fetchai public key in connection_private_key_paths with the fetchai key pair in private_key_paths . The validity of the signature will be constrained to the year 2021 for the environment acn .","title":"Proof of Representation"},{"location":"protocol-generator/","text":"Note This is currently an experimental feature. To try it follow this guide. How to run First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. The author will match the registered author in the CLI. The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains package information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types) Full mode vs Protobuf Only mode Currently, the generator can operate in full mode for Python, creating a complete protocol package (files 1 to 7 above) from a protocol specification. The generator also has a protobuf only mode which only creates the protocol buffer schema and implementation files (files 5 and 6 above). The languages supported in the protobuf only mode and their respective ids are below: go: go c++: cpp java: java c#: csharp ruby: ruby objective-c: objc javascript: js To use the generator in protobuf only mode for any of the above languages: aea generate protocol --l <language> <path-to-protocol-specification> where <language> is a language id. The protocol buffer compiler requires a plugin to generate Go code. Install it with: Note Note the protocol buffer compiler protoc that the generator uses requires a plugin to produce go code. Follow this instruction . Protocol Specification A protocol can be described in a YAML file. This is called a protocol specification . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 description : An example of a protocol specification that describes a protocol for bilateral negotiation. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' speech_acts : cfp : query : ct:Query propose : price : pt:float proposal : pt:dict[pt:str, pt:str] conditions : pt:optional[pt:union[pt:str, pt:dict[pt:str,pt:str], pt:set[pt:str]]] resources : pt:list[pt:bytes] accept : {} decline : {} ... --- ct:Query : | bytes query_bytes = 1; ... --- initiation : [ cfp ] reply : cfp : [ propose , decline ] propose : [ propose , accept , decline ] accept : [] decline : [] termination : [ accept , decline ] roles : { buyer , seller } end_states : [ agreement_reached , agreement_unreached ] keep_terminal_state_dialogues : true ... Each protocol specification must follow the YAML format , and have a minimum of one and a maximum of three YAML documents (each YAML document is enclosed within --- and ...). Basic Protocol Detail and Messages Syntax The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol protocol_specification_id : The id which identifies the protocol for over-the-wire transport. This id is decoupled from the protocol_id ( {author}/{name}:{version} ) which is tied to the Python implementation. All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings. Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory speech-acts field which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (YAML string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, for instance accept and decline in the specification above. A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its type (YAML string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:Query . Types The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types. For example, <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or <MT> . A multi type denotes an \"or\" separated set of sub-types. For example, a content whose type is specified as pt:union[pt:str, pt:int] should either be pt:int or pt:float . An optional type pt:optional[...] assigned to a content means the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here . Protocol Buffer Schema Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually. Therefore, if any of the contents declared in speech-acts is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type. You can see an example of the second YAML document in the above protocol specification. Dialogues You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification. The allowed fields and what they represent are: initiation : The list of initial performatives reply : The reply structure of speech-acts termination : The list of terminal performatives roles : The roles of players participating in a dialogue end_states : The possible outcomes a terminated dialogue. keep_terminal_state_dialogues : whether to keep or drop a terminated dialogue. When a storage backend is configured, the dialogues will be persisted in storage when kept. All of the above fields are mandatory. initiation is a YAML list, containing the performatives which can be used to start a dialogue. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a YAML dictionary, where the keys are the performatives (YAML string) defined in speech-acts . For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . termination is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it. roles is a YAML set, containing the roles players participating in dialogues can take. roles may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role. end_states lists the final states a terminated dialogue may have. end_states is a YAML list of strings. keep_terminal_state_dialogues has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded. Design Guidelines initiation and termination cannot be empty. Make sure that when defining reply , you include every speech-act you specified under speech_acts . If any of the speech-acts does not have a reply, indicate that with an empty list [] similar to accept and decline in the specification above. If a speech-act is listed in termination , it must not have any replies in reply . The reason is simple: a terminal speech-act terminates a dialogue and so its reply can never be used. If a speech-act replies to no other speech-acts, it should be listed in initiation otherwise it could never be used in a dialogue (neither to a start a dialogue with, nor as a reply to another speech-act). Notes Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents. Demo instructions First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Generating protocols"},{"location":"protocol-generator/#how-to-run","text":"First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. The author will match the registered author in the CLI. The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains package information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types)","title":"How to run"},{"location":"protocol-generator/#full-mode-vs-protobuf-only-mode","text":"Currently, the generator can operate in full mode for Python, creating a complete protocol package (files 1 to 7 above) from a protocol specification. The generator also has a protobuf only mode which only creates the protocol buffer schema and implementation files (files 5 and 6 above). The languages supported in the protobuf only mode and their respective ids are below: go: go c++: cpp java: java c#: csharp ruby: ruby objective-c: objc javascript: js To use the generator in protobuf only mode for any of the above languages: aea generate protocol --l <language> <path-to-protocol-specification> where <language> is a language id. The protocol buffer compiler requires a plugin to generate Go code. Install it with: Note Note the protocol buffer compiler protoc that the generator uses requires a plugin to produce go code. Follow this instruction .","title":"Full mode vs Protobuf Only mode"},{"location":"protocol-generator/#protocol-specification","text":"A protocol can be described in a YAML file. This is called a protocol specification . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 description : An example of a protocol specification that describes a protocol for bilateral negotiation. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' speech_acts : cfp : query : ct:Query propose : price : pt:float proposal : pt:dict[pt:str, pt:str] conditions : pt:optional[pt:union[pt:str, pt:dict[pt:str,pt:str], pt:set[pt:str]]] resources : pt:list[pt:bytes] accept : {} decline : {} ... --- ct:Query : | bytes query_bytes = 1; ... --- initiation : [ cfp ] reply : cfp : [ propose , decline ] propose : [ propose , accept , decline ] accept : [] decline : [] termination : [ accept , decline ] roles : { buyer , seller } end_states : [ agreement_reached , agreement_unreached ] keep_terminal_state_dialogues : true ... Each protocol specification must follow the YAML format , and have a minimum of one and a maximum of three YAML documents (each YAML document is enclosed within --- and ...).","title":"Protocol Specification"},{"location":"protocol-generator/#basic-protocol-detail-and-messages-syntax","text":"The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol protocol_specification_id : The id which identifies the protocol for over-the-wire transport. This id is decoupled from the protocol_id ( {author}/{name}:{version} ) which is tied to the Python implementation. All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings. Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory speech-acts field which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (YAML string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, for instance accept and decline in the specification above. A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its type (YAML string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:Query .","title":"Basic Protocol Detail and Messages Syntax"},{"location":"protocol-generator/#types","text":"The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types. For example, <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or <MT> . A multi type denotes an \"or\" separated set of sub-types. For example, a content whose type is specified as pt:union[pt:str, pt:int] should either be pt:int or pt:float . An optional type pt:optional[...] assigned to a content means the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here .","title":"Types"},{"location":"protocol-generator/#protocol-buffer-schema","text":"Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually. Therefore, if any of the contents declared in speech-acts is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type. You can see an example of the second YAML document in the above protocol specification.","title":"Protocol Buffer Schema"},{"location":"protocol-generator/#dialogues","text":"You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification. The allowed fields and what they represent are: initiation : The list of initial performatives reply : The reply structure of speech-acts termination : The list of terminal performatives roles : The roles of players participating in a dialogue end_states : The possible outcomes a terminated dialogue. keep_terminal_state_dialogues : whether to keep or drop a terminated dialogue. When a storage backend is configured, the dialogues will be persisted in storage when kept. All of the above fields are mandatory. initiation is a YAML list, containing the performatives which can be used to start a dialogue. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a YAML dictionary, where the keys are the performatives (YAML string) defined in speech-acts . For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . termination is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it. roles is a YAML set, containing the roles players participating in dialogues can take. roles may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role. end_states lists the final states a terminated dialogue may have. end_states is a YAML list of strings. keep_terminal_state_dialogues has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded.","title":"Dialogues"},{"location":"protocol-generator/#design-guidelines","text":"initiation and termination cannot be empty. Make sure that when defining reply , you include every speech-act you specified under speech_acts . If any of the speech-acts does not have a reply, indicate that with an empty list [] similar to accept and decline in the specification above. If a speech-act is listed in termination , it must not have any replies in reply . The reason is simple: a terminal speech-act terminates a dialogue and so its reply can never be used. If a speech-act replies to no other speech-acts, it should be listed in initiation otherwise it could never be used in a dialogue (neither to a start a dialogue with, nor as a reply to another speech-act).","title":"Design Guidelines"},{"location":"protocol-generator/#notes","text":"Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents.","title":"Notes"},{"location":"protocol-generator/#demo-instructions","text":"First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Demo instructions"},{"location":"protocol/","text":"Protocols define the structure of agent-to-agent and component-to-component interactions, which in the AEA world, are in the form of communication. To learn more about interactions and interaction protocols, see here . Protocols in the AEA world provide definitions for: messages defining the structure and syntax of messages; serialization defining how a message is encoded/decoded for transport; and optionally dialogues defining the structure of dialogues formed from exchanging series of messages. The framework provides a base protocol. This protocol provides a bare-bones implementation for an AEA protocol which includes a DefaultMessage class and associated DefaultSerializer and DefaultDialogue classes. Additional protocols - i.e. a new type of interaction - can be added as packages or generated with the protocol generator . We highly recommend you to not attempt writing your protocol manually as they tend to have involved logic; always use existing packages or the protocol generator! Components of a protocol A protocol package contains the following files: __init__.py message.py , which defines message representation serialization.py , which defines the encoding and decoding logic two protobuf related files It optionally also contains dialogues.py , which defines the structure of dialogues formed from the exchange of a series of messages custom_types.py , which defines custom types All protocols are for point to point interactions between two agents or agent-like services. Metadata Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . performative: Enum , the purpose/intention of the message. sender: Address , the address of the sender of this message. to: Address , the address of the receiver of this message. The default values for message_id and target assume the message is the first message in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue and target is 0 since the first message is the only message that does not reply to any other. By default, the values of dialogue_reference , message_id , target are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one. Contents Each message may optionally have any number of contents of varying types. Dialogue rules Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single, respectively, all dialogues associated with a protocol. The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the Dialogue and Dialogues base classes. Custom protocol The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue). We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator!","title":"Protocols"},{"location":"protocol/#components-of-a-protocol","text":"A protocol package contains the following files: __init__.py message.py , which defines message representation serialization.py , which defines the encoding and decoding logic two protobuf related files It optionally also contains dialogues.py , which defines the structure of dialogues formed from the exchange of a series of messages custom_types.py , which defines custom types All protocols are for point to point interactions between two agents or agent-like services.","title":"Components of a protocol"},{"location":"protocol/#metadata","text":"Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . performative: Enum , the purpose/intention of the message. sender: Address , the address of the sender of this message. to: Address , the address of the receiver of this message. The default values for message_id and target assume the message is the first message in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue and target is 0 since the first message is the only message that does not reply to any other. By default, the values of dialogue_reference , message_id , target are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one.","title":"Metadata"},{"location":"protocol/#contents","text":"Each message may optionally have any number of contents of varying types.","title":"Contents"},{"location":"protocol/#dialogue-rules","text":"Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single, respectively, all dialogues associated with a protocol. The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the Dialogue and Dialogues base classes.","title":"Dialogue rules"},{"location":"protocol/#custom-protocol","text":"The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue). We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator!","title":"Custom protocol"},{"location":"questions-and-answers/","text":"What is an AEA? AEA stands for \"Autonomous Economic Agent\". An AEA can represent an individual, organisation or object and looks after its owner's interests. AEAs act independently of constant user input and autonomously execute actions to achieve their prescribed goals. Their purpose is to create economic value for their owners. How do AEAs talk to each other when they do not know each other? For an Autonomous Economic Agent (AEA) to talk to other AEAs, it first needs to find them. Once it does, it should ensure that they both use the same protocol for communication, and if so, they then have to send messages to each other. The AEA framework provides the necessary services to address all three problems. You can read more about the agent communication network here , protocols here , and the Agent Communication Network (ACN) here . How does an AEA use blockchain? The AEA framework enables agents to interact with blockchains to settle transactions. Currently, the framework has native support for three different networks: Fetch.ai , Ethereum and Cosmos . You can read more about the framework's integration with the different blockchains here . How does one install third party libraries? The framework supports the use of third-party libraries hosted on PyPI . You can directly reference the external dependencies of an AEA package (e.g. skill) in its configuration file. From inside an AEA's project directory, the install command can be used to install all the dependencies of the AEA listed in the configuration files of any of it's packages. How does one connect to a database? You have two options to connect to a database: using the built-in storage solution or using a custom ORM (object-relational mapping) library and backend. The use of the built-in storage is explained here . How does one connect a frontend? There are multiple options. The most obvious is using an HTTP server connection and creating a client that communicates with this connection. You can find a more detailed discussion here . Is the AEA framework ideal for agent-based modelling? The goal of agent-based modelling (ABM) is to study complex behaviour that emerges as a result of interactions between agents that express well-defined and often simple rule-based behaviour. ABM is a popular technique for studying biological and social systems. Despite some similarities between ABM and the AEA framework, the two serve fundamentally different purposes. ABMs are typically used to study pattern formation at meso and macro scale that result from local agent interactions, whereas in contrast AEAs pursue the owners economic goals. Although possible, the AEA framework offers more complexity than typically is required to address the types of questions ABM is commonly used for. You can find more details on the application areas of the AEA framework here . When a new AEA is created, is the vendor folder populated with some default packages? All AEA projects by default hold the open_aea/signing:1.0.0 protocols. These (as all other packages installed from the registry) are placed in the vendor folder. You can find more details about the file structure here . Is there a standard for private key files? Currently, the private keys are stored in .txt files. This is temporary and will be improved soon. How to use the same protocol in different skills? The details of envelope/message routing by the AEA framework are discussed in this guide . Why does the AEA framework use its own package registry? AEA packages could be described as personalized plugins for the AEA runtime. They are not like a library - they have no direct use outside the context of the framework - and therefore are not suitable for distribution via PyPI .","title":"Q&A"},{"location":"quickstart/","text":"Dependencies & System Requirements The AEA framework can be used on Windows , Ubuntu/Debian and MacOS . There are a number of base requirements to be installed prior to usage. You need Python 3.6 or higher as well as Go 1.14.2 or higher installed. \u200bGCC installation is required: * Ubuntu: apt-get install gcc * Windows (with choco installed): choco install mingw * MacOS X (with home brew): brew install gcc Option 1: Manual system preparation Install a compatible Python and Go version on your system (see this external resource for a comprehensive guide). Manual approach The following hints can help: To install Go, follow the official guide, depending on your platform here Python is already included by default on many Linux distributions (e.g. Ubuntu), as well as MacOS. To check you have the right version, open a terminal and run: python3 --version To install Python on Windows machines, you can download a specific release here . Ubuntu/Debian systems only: install Python headers, depending on the Python version you have installed on your machine. E.g. for Python 3.8: sudo apt-get install python3.8-dev Windows users: install tools for Visual Studio . Option 2: Using an automated install script We provide a script to automatically install all framework dependencies and the framework itself. This means that if you follow this option, you can skip the installation step that comes later on this page. Automated install script approach On MacOS or Ubuntu run the following commands to download and install: curl https://raw.githubusercontent.com/valory-xyz/open-aea/main/scripts/install.sh --output install.sh chmod +x install.sh ./install.sh On Windows: download https://raw.githubusercontent.com/valory-xyz/open-aea/main/scripts/install.ps1 , then run install.ps1 with the PowerShell terminal. Option 3: Using Docker \u200b We also provide a Docker image with all the needed dependencies. Docker approach To use the image you will first have to pull it and than run it with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container. To pull: docker pull fetchai/aea-user:latest To run the image on Linux and MacOs: docker run -it -v $( pwd ) :/agents --workdir = /agents fetchai/aea-user:latest And on Windows: docker run -it -v %cd%:/agents --workdir = /agents fetchai/aea-user:latest Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker. \u200b Getting Started Ensure, you are in a clean working directory: Create it manually mkdir my_aea_projects/ && cd my_aea_projects/ , then add an empty directory called packages with the following command mkdir packages/ , At this point, when typing ls you should see a single folder called packages in your working environment. This will act as your local registry for AEA components. Unless you are using the docker image, we highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.8 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .8 && pipenv shell Installation of Open-AEA The following installs the entire AEA package which also includes a command-line interface (CLI) . (You can skip this step if you used the install script above: Option 2 .) pip install open-aea [ all ] If you are using zsh rather than bash type pip install 'open-aea[all]' pip install 'open-aea-ledger-ethereum' If the installation steps fail, it might be a dependency issue. Make sure you have followed all the relevant system specific steps above under System Requirements . Setup Open-AEA Author To configure the aea with an author. aea init --local Setup Open-AEA Components AEAs are composed of components. AEAs and AEA components can be developed by anyone and pushed to an IPFS registry for others to use. To load Valory packages please use SVN to checkout the specific folders; svn checkout https://github.com/valory-xyz/open-aea/tags/v1.8.0/packages packages Echo skill demo This is a simple demo that introduces you to the main components of an AEA. The fastest way to have your first AEA is to fetch one that already exists! aea fetch open_aea/my_first_aea:0.1.0 --local cd my_first_aea Install AEA dependencies aea install Add and create a private key All AEAs need a private key to run. Add one now: aea generate-key ethereum aea add-key ethereum Run the AEA Run the AEA. aea run You will see the echo skill running in the terminal window (an output similar to the one below). _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.7.0 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... Interact with the AEA From a different terminal and same directory (i.e. the my_first_aea project), you can send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the aea interact command. Stop the AEA You can stop an AEA by pressing CTRL C . Once you do, you should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called. To learn more about the folder structure of an AEA project read on here . Alternatively: step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the stub connection Second, add the stub connection to the project. aea add connection fetchai/stub:0.21.0 Add the echo skill Third, add the echo skill to the project. aea add skill fetchai/echo:0.19.0 This copies the fetchai/echo:0.19.0 skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill fetchai/echo:0.19.0 consists of the name of the author of the skill, followed by the skill name and its version. How Does This AEA work? Echo skill Just like humans, AEAs can have skills to achieve their tasks. As an agent developer, you can create skills to add to your own AEAs. You can also choose to publish your skills so others add them to their AEAs. More details on skills can be found on this page . The above agent has an echo skill , fetched from the registry , which simply echoes any messages it receives back to its sender. Communication via envelopes and messages AEAs use envelopes containing messages for communication. To learn more, check out the next section . Stub connection Besides skills, AEAs may have one or more connections enabling them to interface with entities in the outside world. For example, an HTTP client connection allows an AEA to communicate with HTTP servers. To read more about connections see this page . In this demo, we use the stub connection ( fetchai/stub0.15.0 ) to send envelopes to and receive envelopes from the AEA. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:1.0.0, \\x 08 \\x 01 \\x 12 \\x 011 * \\x 07 \\n\\x 05hello, The framework first calls the setup methods in the skill's Handler and Behaviour classes in that order; after which it repeatedly calls the act method of Behaviour class. This is the main agent loop in action. Test Quickstart Write a simple test for the AEA We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Writing tests The following test class replicates the preceding demo and tests it's correct behaviour. The AEATestCase classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. First, get the packages directory from the AEA repository (execute from the working directory which contains the my_first_aea folder): svn export https://github.com/valory-xyz/open-aea.git/trunk/packages Then write the test: import signal import time from aea.common import Address from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue from packages.fetchai.protocols.default.dialogues import DefaultDialogue , DefaultDialogues from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files sender_aea = \"sender_aea\" def role_from_first_message ( message : Message , receiver_address : Address ) -> Dialogue . Role : return DefaultDialogue . Role . AGENT dialogues = DefaultDialogues ( sender_aea , role_from_first_message ) message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = sender_aea , protocol_specification_id = message . protocol_specification_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_specification_id == received_envelope . protocol_specification_id received_message = DefaultMessage . serializer . decode ( received_envelope . message ) assert message . content == received_message . content check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file test.py in your AEA project directory (the same level as the aea-config.yaml file). To run, execute the following: pipenv run pytest test.py Delete the AEA Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea Next steps To gain an understanding of the core components of the framework, please continue to the next page: Core components - Part 1","title":"AEA quick start"},{"location":"quickstart/#dependencies-system-requirements","text":"The AEA framework can be used on Windows , Ubuntu/Debian and MacOS . There are a number of base requirements to be installed prior to usage. You need Python 3.6 or higher as well as Go 1.14.2 or higher installed. \u200bGCC installation is required: * Ubuntu: apt-get install gcc * Windows (with choco installed): choco install mingw * MacOS X (with home brew): brew install gcc","title":"Dependencies &amp; System Requirements"},{"location":"quickstart/#option-1-manual-system-preparation","text":"Install a compatible Python and Go version on your system (see this external resource for a comprehensive guide). Manual approach The following hints can help: To install Go, follow the official guide, depending on your platform here Python is already included by default on many Linux distributions (e.g. Ubuntu), as well as MacOS. To check you have the right version, open a terminal and run: python3 --version To install Python on Windows machines, you can download a specific release here . Ubuntu/Debian systems only: install Python headers, depending on the Python version you have installed on your machine. E.g. for Python 3.8: sudo apt-get install python3.8-dev Windows users: install tools for Visual Studio .","title":"Option 1: Manual system preparation"},{"location":"quickstart/#option-2-using-an-automated-install-script","text":"We provide a script to automatically install all framework dependencies and the framework itself. This means that if you follow this option, you can skip the installation step that comes later on this page. Automated install script approach On MacOS or Ubuntu run the following commands to download and install: curl https://raw.githubusercontent.com/valory-xyz/open-aea/main/scripts/install.sh --output install.sh chmod +x install.sh ./install.sh On Windows: download https://raw.githubusercontent.com/valory-xyz/open-aea/main/scripts/install.ps1 , then run install.ps1 with the PowerShell terminal.","title":"Option 2: Using an automated install script"},{"location":"quickstart/#option-3-using-docker","text":"\u200b We also provide a Docker image with all the needed dependencies. Docker approach To use the image you will first have to pull it and than run it with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container. To pull: docker pull fetchai/aea-user:latest To run the image on Linux and MacOs: docker run -it -v $( pwd ) :/agents --workdir = /agents fetchai/aea-user:latest And on Windows: docker run -it -v %cd%:/agents --workdir = /agents fetchai/aea-user:latest Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker. \u200b","title":"Option 3: Using Docker"},{"location":"quickstart/#getting-started","text":"Ensure, you are in a clean working directory: Create it manually mkdir my_aea_projects/ && cd my_aea_projects/ , then add an empty directory called packages with the following command mkdir packages/ , At this point, when typing ls you should see a single folder called packages in your working environment. This will act as your local registry for AEA components. Unless you are using the docker image, we highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.8 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .8 && pipenv shell","title":"Getting Started"},{"location":"quickstart/#installation-of-open-aea","text":"The following installs the entire AEA package which also includes a command-line interface (CLI) . (You can skip this step if you used the install script above: Option 2 .) pip install open-aea [ all ] If you are using zsh rather than bash type pip install 'open-aea[all]' pip install 'open-aea-ledger-ethereum' If the installation steps fail, it might be a dependency issue. Make sure you have followed all the relevant system specific steps above under System Requirements .","title":"Installation of Open-AEA"},{"location":"quickstart/#setup-open-aea-author","text":"To configure the aea with an author. aea init --local","title":"Setup Open-AEA Author"},{"location":"quickstart/#setup-open-aea-components","text":"AEAs are composed of components. AEAs and AEA components can be developed by anyone and pushed to an IPFS registry for others to use. To load Valory packages please use SVN to checkout the specific folders; svn checkout https://github.com/valory-xyz/open-aea/tags/v1.8.0/packages packages","title":"Setup Open-AEA Components"},{"location":"quickstart/#echo-skill-demo","text":"This is a simple demo that introduces you to the main components of an AEA. The fastest way to have your first AEA is to fetch one that already exists! aea fetch open_aea/my_first_aea:0.1.0 --local cd my_first_aea","title":"Echo skill demo"},{"location":"quickstart/#install-aea-dependencies","text":"aea install","title":"Install AEA dependencies"},{"location":"quickstart/#add-and-create-a-private-key","text":"All AEAs need a private key to run. Add one now: aea generate-key ethereum aea add-key ethereum","title":"Add and create a private key"},{"location":"quickstart/#run-the-aea","text":"Run the AEA. aea run You will see the echo skill running in the terminal window (an output similar to the one below). _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.7.0 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ...","title":"Run the AEA"},{"location":"quickstart/#interact-with-the-aea","text":"From a different terminal and same directory (i.e. the my_first_aea project), you can send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the aea interact command.","title":"Interact with the AEA"},{"location":"quickstart/#stop-the-aea","text":"You can stop an AEA by pressing CTRL C . Once you do, you should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called. To learn more about the folder structure of an AEA project read on here . Alternatively: step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the stub connection Second, add the stub connection to the project. aea add connection fetchai/stub:0.21.0 Add the echo skill Third, add the echo skill to the project. aea add skill fetchai/echo:0.19.0 This copies the fetchai/echo:0.19.0 skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill fetchai/echo:0.19.0 consists of the name of the author of the skill, followed by the skill name and its version.","title":"Stop the AEA"},{"location":"quickstart/#how-does-this-aea-work","text":"","title":"How Does This AEA work?"},{"location":"quickstart/#echo-skill","text":"Just like humans, AEAs can have skills to achieve their tasks. As an agent developer, you can create skills to add to your own AEAs. You can also choose to publish your skills so others add them to their AEAs. More details on skills can be found on this page . The above agent has an echo skill , fetched from the registry , which simply echoes any messages it receives back to its sender.","title":"Echo skill"},{"location":"quickstart/#communication-via-envelopes-and-messages","text":"AEAs use envelopes containing messages for communication. To learn more, check out the next section .","title":"Communication via envelopes and messages"},{"location":"quickstart/#stub-connection","text":"Besides skills, AEAs may have one or more connections enabling them to interface with entities in the outside world. For example, an HTTP client connection allows an AEA to communicate with HTTP servers. To read more about connections see this page . In this demo, we use the stub connection ( fetchai/stub0.15.0 ) to send envelopes to and receive envelopes from the AEA. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:1.0.0, \\x 08 \\x 01 \\x 12 \\x 011 * \\x 07 \\n\\x 05hello, The framework first calls the setup methods in the skill's Handler and Behaviour classes in that order; after which it repeatedly calls the act method of Behaviour class. This is the main agent loop in action.","title":"Stub connection"},{"location":"quickstart/#test-quickstart","text":"","title":"Test Quickstart"},{"location":"quickstart/#write-a-simple-test-for-the-aea","text":"We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Writing tests The following test class replicates the preceding demo and tests it's correct behaviour. The AEATestCase classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. First, get the packages directory from the AEA repository (execute from the working directory which contains the my_first_aea folder): svn export https://github.com/valory-xyz/open-aea.git/trunk/packages Then write the test: import signal import time from aea.common import Address from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue from packages.fetchai.protocols.default.dialogues import DefaultDialogue , DefaultDialogues from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files sender_aea = \"sender_aea\" def role_from_first_message ( message : Message , receiver_address : Address ) -> Dialogue . Role : return DefaultDialogue . Role . AGENT dialogues = DefaultDialogues ( sender_aea , role_from_first_message ) message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = sender_aea , protocol_specification_id = message . protocol_specification_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_specification_id == received_envelope . protocol_specification_id received_message = DefaultMessage . serializer . decode ( received_envelope . message ) assert message . content == received_message . content check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file test.py in your AEA project directory (the same level as the aea-config.yaml file). To run, execute the following: pipenv run pytest test.py","title":"Write a simple test for the AEA"},{"location":"quickstart/#delete-the-aea","text":"Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea","title":"Delete the AEA"},{"location":"quickstart/#next-steps","text":"To gain an understanding of the core components of the framework, please continue to the next page: Core components - Part 1","title":"Next steps"},{"location":"raspberry-set-up/","text":"This guide explains how to run an AEA inside a Raspberry Pi. Prerequisites Raspberry Pi 4 (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) Internet connection (preferably wireless to minimise the number of wires connecting into your device) Preparing the Raspberry Pi If you have a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Raspberry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below. NOOBS NOOBS is a way to create an SD card for easy operating system installation on a Raspberry Pi. First download noobs from this link . Then follow this guide to set up your SD card. Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and boot up. When prompted, select the Raspbian operating system and click \"Install\". Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry Pi and your WiFi password so the device can access the internet. You may also be given the option to update the operating system and software. We recommend that you let the system update. Once finished you will be prompted to restart. Even if your Raspberry Pi updated itself, we recommend that you make sure it is completely up to date using the terminal. Open a Terminal window (your Raspberry Pi might restart a few times during this process): sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade Install the AEA Framework First, install pipenv: sudo apt-get install pipenv Once installed, create and launch a clean virtual environment with Python 3.7: pipenv --python 3 .7 && pipenv shell Finally, install the AEA framework from PyPI: pip install aea [ all ]","title":"Build an AEA on a Raspberry Pi"},{"location":"raspberry-set-up/#prerequisites","text":"Raspberry Pi 4 (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) Internet connection (preferably wireless to minimise the number of wires connecting into your device)","title":"Prerequisites"},{"location":"raspberry-set-up/#preparing-the-raspberry-pi","text":"If you have a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Raspberry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below.","title":"Preparing the Raspberry Pi"},{"location":"raspberry-set-up/#noobs","text":"NOOBS is a way to create an SD card for easy operating system installation on a Raspberry Pi. First download noobs from this link . Then follow this guide to set up your SD card. Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and boot up. When prompted, select the Raspbian operating system and click \"Install\".","title":"NOOBS"},{"location":"raspberry-set-up/#booting-up-and-updating-the-os","text":"When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry Pi and your WiFi password so the device can access the internet. You may also be given the option to update the operating system and software. We recommend that you let the system update. Once finished you will be prompted to restart. Even if your Raspberry Pi updated itself, we recommend that you make sure it is completely up to date using the terminal. Open a Terminal window (your Raspberry Pi might restart a few times during this process): sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade","title":"Booting up and updating the OS"},{"location":"raspberry-set-up/#install-the-aea-framework","text":"First, install pipenv: sudo apt-get install pipenv Once installed, create and launch a clean virtual environment with Python 3.7: pipenv --python 3 .7 && pipenv shell Finally, install the AEA framework from PyPI: pip install aea [ all ]","title":"Install the AEA Framework"},{"location":"registry/","text":"Component Registry Individual components are stored on the IPFS registry . This registry allows other developer to reuse these components. Anyone case register a new component which is uniquely identifiable by a hash of the contents of the component. Creating a Project We can create a new agent with the bare minimal components as so; aea create agent Initializing AEA project 'agent' Creating project directory './agent' Creating config file aea-config.yaml Adding default packages ... Adding protocol 'open_aea/signing:latest'... Using registry: ipfs Downloading open_aea/signing:latest from IPFS. Successfully added protocol 'open_aea/signing:1.0.0'. Adding Individual Components Once we have an agent, we can add individual components to the agent as so; aea add skill fetchai/echo:0.19.0 Registry path not provided and local registry `packages` not found in current (.) and parent directory. Trying remote registry (`--remote`). Adding skill 'fetchai/echo:latest'... Using registry: ipfs Downloading fetchai/echo:latest from IPFS. Adding protocol 'fetchai/default:1.0.0'... Using registry: ipfs Downloading fetchai/default:1.0.0 from IPFS. Successfully added protocol 'fetchai/default:1.0.0'. Successfully added skill 'fetchai/echo:0.19.0'. Adding a Package to Local IPFS Node To generate the hash of a component, we use a local IPFS node which allows use to create the same hash as generated upon deployment of the component to main net IPFS. aea ipfs add packages/fetchai/connections/gym/ Starting processing: /root/open-aea/packages/fetchai/connections/gym Registered item with: public id : fetchai/gym:0.19.0 hash : QmVLvrU8w8nJB57ncPfoYwB5niA3RWeeKpqyRi3ug2hkY8","title":"Agent & component registry"},{"location":"registry/#component-registry","text":"Individual components are stored on the IPFS registry . This registry allows other developer to reuse these components. Anyone case register a new component which is uniquely identifiable by a hash of the contents of the component.","title":"Component Registry"},{"location":"registry/#creating-a-project","text":"We can create a new agent with the bare minimal components as so; aea create agent Initializing AEA project 'agent' Creating project directory './agent' Creating config file aea-config.yaml Adding default packages ... Adding protocol 'open_aea/signing:latest'... Using registry: ipfs Downloading open_aea/signing:latest from IPFS. Successfully added protocol 'open_aea/signing:1.0.0'.","title":"Creating a Project"},{"location":"registry/#adding-individual-components","text":"Once we have an agent, we can add individual components to the agent as so; aea add skill fetchai/echo:0.19.0 Registry path not provided and local registry `packages` not found in current (.) and parent directory. Trying remote registry (`--remote`). Adding skill 'fetchai/echo:latest'... Using registry: ipfs Downloading fetchai/echo:latest from IPFS. Adding protocol 'fetchai/default:1.0.0'... Using registry: ipfs Downloading fetchai/default:1.0.0 from IPFS. Successfully added protocol 'fetchai/default:1.0.0'. Successfully added skill 'fetchai/echo:0.19.0'.","title":"Adding Individual Components"},{"location":"registry/#adding-a-package-to-local-ipfs-node","text":"To generate the hash of a component, we use a local IPFS node which allows use to create the same hash as generated upon deployment of the component to main net IPFS. aea ipfs add packages/fetchai/connections/gym/ Starting processing: /root/open-aea/packages/fetchai/connections/gym Registered item with: public id : fetchai/gym:0.19.0 hash : QmVLvrU8w8nJB57ncPfoYwB5niA3RWeeKpqyRi3ug2hkY8","title":"Adding a Package to Local IPFS Node"},{"location":"runtime-cost/","text":"Measuring runtime cost It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components. These observations can provide guidance on what to report as part of the cost of running an AEA. Here is a list of suggestion on how to measure the cost of running an AEA: - the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline. - the cost of interconnecting components: by running an a agent with a basic skill (e.g. fetchai/echo ) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth. - the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage The aea run --profiling SECONDS command can be used to report measures in all of the above scenarios. Running and profiling a locally modified framework instance In order to run a locally modified version of the framework, you will need to build the container using the Dockerfile_local in develop_image/ and tag it. From the open-aea root, run: docker build . -t valory/open-aea-user:<tag> --file ./develop-image/Dockerfile_local It's time to build the image for the agent or service, that will build on top of the open-aea one. First, enable profiling by adding the corresponding flag in your start script. The run line should look like this: aea run --aev --profiling 15 # This runs profiling every 15 seconds Now build the image. If you have local changes to open-aea, you'll need to comment out any lines corresponding to the installation of open-aea and its plugins in your Dockerfile to avoid the pypi versions being used instead of the local ones: docker build . -t <agent_image>:<tag> --file ./Dockerfile --no-cache Please double-check your tags to be sure that you are using the correct images with local modifications. Once the build has finished, run a Hardhat node before using it: docker run -p 8545 :8545 -it valory/consensus-algorithms-hardhat:0.1.0 Run the deployment. You can check the logs using docker logs <container> -f or even copy them from the container like this: sudo cp $( docker inspect --format = '{{.LogPath}}' <container> ) /tmp/docker_log && sudo chown <user> /tmp/docker_log If you used the profiling flag, the logs will contain information about the memory used and object count for certain predefined classes. You can even plot that information using the script in open-aea's repository at scripts/profile-log-parser.py . If you need further information, just log it directly if all you need is insight about the code execution or modify open-aea/aea/helpers/profiling.py if your code needs to run with the profiling. After this, some updates to the plot script open-aea/scripts/profile-log-parser.py should be enough to account for the new data.","title":"Profiling"},{"location":"runtime-cost/#measuring-runtime-cost","text":"It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components. These observations can provide guidance on what to report as part of the cost of running an AEA. Here is a list of suggestion on how to measure the cost of running an AEA: - the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline. - the cost of interconnecting components: by running an a agent with a basic skill (e.g. fetchai/echo ) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth. - the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage The aea run --profiling SECONDS command can be used to report measures in all of the above scenarios.","title":"Measuring runtime cost"},{"location":"runtime-cost/#running-and-profiling-a-locally-modified-framework-instance","text":"In order to run a locally modified version of the framework, you will need to build the container using the Dockerfile_local in develop_image/ and tag it. From the open-aea root, run: docker build . -t valory/open-aea-user:<tag> --file ./develop-image/Dockerfile_local It's time to build the image for the agent or service, that will build on top of the open-aea one. First, enable profiling by adding the corresponding flag in your start script. The run line should look like this: aea run --aev --profiling 15 # This runs profiling every 15 seconds Now build the image. If you have local changes to open-aea, you'll need to comment out any lines corresponding to the installation of open-aea and its plugins in your Dockerfile to avoid the pypi versions being used instead of the local ones: docker build . -t <agent_image>:<tag> --file ./Dockerfile --no-cache Please double-check your tags to be sure that you are using the correct images with local modifications. Once the build has finished, run a Hardhat node before using it: docker run -p 8545 :8545 -it valory/consensus-algorithms-hardhat:0.1.0 Run the deployment. You can check the logs using docker logs <container> -f or even copy them from the container like this: sudo cp $( docker inspect --format = '{{.LogPath}}' <container> ) /tmp/docker_log && sudo chown <user> /tmp/docker_log If you used the profiling flag, the logs will contain information about the memory used and object count for certain predefined classes. You can even plot that information using the script in open-aea's repository at scripts/profile-log-parser.py . If you need further information, just log it directly if all you need is insight about the code execution or modify open-aea/aea/helpers/profiling.py if your code needs to run with the profiling. After this, some updates to the plot script open-aea/scripts/profile-log-parser.py should be enough to account for the new data.","title":"Running and profiling a locally modified framework instance"},{"location":"scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, contracts and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, enter into your project directory and scaffold your project skill, protocol, or connection. Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a contract aea scaffold contract my_contract Scaffold a connection aea scaffold connection my_connection After running the above commands, you are able to develop your own skill, protocol, contract and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] [ public_id ] Then you are ready to run the AEA.","title":"Scaffolding packages"},{"location":"scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, contracts and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, enter into your project directory and scaffold your project skill, protocol, or connection.","title":"Scaffold generator"},{"location":"scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"scaffolding/#scaffold-a-contract","text":"aea scaffold contract my_contract","title":"Scaffold a contract"},{"location":"scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you are able to develop your own skill, protocol, contract and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] [ public_id ] Then you are ready to run the AEA.","title":"Scaffold a connection"},{"location":"security/","text":"The AEA framework takes every care to follow best practice around security. The following advice will help you when writing your own code: Many potential common security vulnerabilities can be caught by static code analysis. We recommend you use safety , pylint and bandit to analyse your code. Don't use relative import paths, these can lead to malicious code being executed. Try to avoid using the subprocess module. If needed, make sure you sanitise commands passed to subprocess . Try to avoid using the pickle module. Pickle should never be used for agent-to-agent communication protocols. By design, the framework prevents skill code from accessing private keys directly, as they are not reachable from the skill execution context through attribute getters. However, if the flag -p or the option --password are not used when generating private keys for an AEA project via the aea CLI tool, the private keys will be stored in plaintext. This allows the skills to access them via interaction with the OS file system. We recommend to always specify a password to encrypt private keys by using the flag argument.","title":"Security"},{"location":"skill-testing/","text":"In this guide we describe some of the tools the framework offers for testing skills. The BaseSkillTestCase class The framework offers a BaseSkillTestCase class which you can subclass and write your test cases with. Let us assume you want to test the my_behaviour behaviour of a CustomSkill skill you have developed. You can create a TestMyBehaviour class which inherits BaseSkillTestCase as below: import asyncio from asyncio import Queue from pathlib import Path from types import SimpleNamespace from typing import cast from aea.configurations.constants import DEFAULT_LEDGER from aea.context.base import AgentContext from aea.crypto.ledger_apis import DEFAULT_CURRENCY_DENOMINATIONS from aea.identity.base import Identity from aea.multiplexer import AsyncMultiplexer , OutBox , Multiplexer from aea.skills.tasks import TaskManager from aea.test_tools.test_skill import BaseSkillTestCase class TestMyBehaviour ( BaseSkillTestCase ): \"\"\"Test my_behaviours of the custom skill.\"\"\" path_to_skill = Path ( \"path_to_this_skill\" ) Specifying Skill Path You must then specify the path to your skill directory via path_to_skill to allow the skill to be loaded and tested. This must be the directory in which skill.yaml of your skill resides. Setting up Each Test You can add a setup() class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the setup() method of the BaseSkillTestCase class via super().setup() . @classmethod def setup ( cls ): \"\"\"Setup the test class.\"\"\" super () . setup () cls . my_behaviour = cast ( MyBehaviour , cls . _skill . skill_context . behaviours . my_behaviour ) In the above, we make the my_behaviour behaviour object accessible for every test. Skill and Skill Context The skill object itself is exposed via a property. So you can access the skill object by self.skill and by extension all of its attributes. This crucially includes the complete skill_context . This means that for example, all of the components of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context. In the above code snippet, my_behavior is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via self.skill.skill_context.behaviours.my_behaviour . Dummy Agent Context The loaded skill is also fed a dummy agent_context complete with an identity , outbox , decision_maker_queue and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The agent_context object fed to the skill is shown below: _multiplexer = AsyncMultiplexer () _multiplexer . _out_queue = ( asyncio . Queue ()) agent_context = AgentContext ( identity = Identity ( \"test_agent_name\" , \"test_agent_address\" , \"test_agent_public_key\" ), connection_status = _multiplexer . connection_status , outbox = OutBox ( cast ( Multiplexer , cls . _multiplexer )), decision_maker_message_queue = Queue (), decision_maker_handler_context = SimpleNamespace (), task_manager = TaskManager (), default_ledger_id = DEFAULT_LEDGER , currency_denominations = {}, default_connection = None , default_routing = {}, search_service_address = \"dummy_search_service_address\" , decision_maker_address = \"dummy_decision_maker_address\" , data_dir = \".\" ) Some Useful Skill Attributes Some of the useful objects you can access in your test class for the loaded skill are below: self.skill.skill_context.agent_address : this is the agent identity the skill uses and is set to \"test_agent_address\" . self.skill.skill_context.search_service_address : this is the address of the search service and is set to \"dummy_search_service_address\" . self.skill.skill_context.skill_id : this is the id of the skill. self.skill.skill_context.decision_maker_address : this is the address of the decision maker and is set to \"dummy_decision_maker_address\" . Some Useful BaseSkillTestCase Methods There are a number of methods that BaseSkillTestCase offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for BaseSkillTestCase : self.get_quantity_in_outbox() : gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent. self.get_message_from_outbox() : gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message. self.message_has_attributes(actual_message: Message, message_type: Type[Message], **kwargs,) : you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using self.get_message_from_outbox() ), specify its expected type (e.g. FipaMessage ), and any other attribute you expect the message to have (e.g. message_id is 1) may be provided via keyword arguments. self.build_incoming_message : this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution. Checking Logger Output You can check the output of your skill's logger by mocking it using unittest.mock before executing a part of your skill as such: import logging from unittest import mock with mock . patch . object ( self . my_behaviour . context . logger , \"log\" ) as mock_logger : self . my_behaviour . act () mock_logger . assert_any_call ( logging . INFO , \"some_logger_message\" ) In the above, we mock the logger before running my_behaviour 's act() method and check that the string \"some_logger_message\" is indeed passed to the logger. Next steps You can consult the fetchai/generic_buyer and fetchai/generic_seller skills and their associated tests here to study how BaseSkillTestCase can help you in testing your skills. You can also refer to the API to study the different methods BaseSkillTestCase makes available to make testing your skills easier.","title":"Testing Skills"},{"location":"skill-testing/#the-baseskilltestcase-class","text":"The framework offers a BaseSkillTestCase class which you can subclass and write your test cases with. Let us assume you want to test the my_behaviour behaviour of a CustomSkill skill you have developed. You can create a TestMyBehaviour class which inherits BaseSkillTestCase as below: import asyncio from asyncio import Queue from pathlib import Path from types import SimpleNamespace from typing import cast from aea.configurations.constants import DEFAULT_LEDGER from aea.context.base import AgentContext from aea.crypto.ledger_apis import DEFAULT_CURRENCY_DENOMINATIONS from aea.identity.base import Identity from aea.multiplexer import AsyncMultiplexer , OutBox , Multiplexer from aea.skills.tasks import TaskManager from aea.test_tools.test_skill import BaseSkillTestCase class TestMyBehaviour ( BaseSkillTestCase ): \"\"\"Test my_behaviours of the custom skill.\"\"\" path_to_skill = Path ( \"path_to_this_skill\" )","title":"The BaseSkillTestCase class"},{"location":"skill-testing/#specifying-skill-path","text":"You must then specify the path to your skill directory via path_to_skill to allow the skill to be loaded and tested. This must be the directory in which skill.yaml of your skill resides.","title":"Specifying Skill Path"},{"location":"skill-testing/#setting-up-each-test","text":"You can add a setup() class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the setup() method of the BaseSkillTestCase class via super().setup() . @classmethod def setup ( cls ): \"\"\"Setup the test class.\"\"\" super () . setup () cls . my_behaviour = cast ( MyBehaviour , cls . _skill . skill_context . behaviours . my_behaviour ) In the above, we make the my_behaviour behaviour object accessible for every test.","title":"Setting up Each Test"},{"location":"skill-testing/#skill-and-skill-context","text":"The skill object itself is exposed via a property. So you can access the skill object by self.skill and by extension all of its attributes. This crucially includes the complete skill_context . This means that for example, all of the components of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context. In the above code snippet, my_behavior is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via self.skill.skill_context.behaviours.my_behaviour .","title":"Skill and Skill Context"},{"location":"skill-testing/#dummy-agent-context","text":"The loaded skill is also fed a dummy agent_context complete with an identity , outbox , decision_maker_queue and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The agent_context object fed to the skill is shown below: _multiplexer = AsyncMultiplexer () _multiplexer . _out_queue = ( asyncio . Queue ()) agent_context = AgentContext ( identity = Identity ( \"test_agent_name\" , \"test_agent_address\" , \"test_agent_public_key\" ), connection_status = _multiplexer . connection_status , outbox = OutBox ( cast ( Multiplexer , cls . _multiplexer )), decision_maker_message_queue = Queue (), decision_maker_handler_context = SimpleNamespace (), task_manager = TaskManager (), default_ledger_id = DEFAULT_LEDGER , currency_denominations = {}, default_connection = None , default_routing = {}, search_service_address = \"dummy_search_service_address\" , decision_maker_address = \"dummy_decision_maker_address\" , data_dir = \".\" )","title":"Dummy Agent Context"},{"location":"skill-testing/#some-useful-skill-attributes","text":"Some of the useful objects you can access in your test class for the loaded skill are below: self.skill.skill_context.agent_address : this is the agent identity the skill uses and is set to \"test_agent_address\" . self.skill.skill_context.search_service_address : this is the address of the search service and is set to \"dummy_search_service_address\" . self.skill.skill_context.skill_id : this is the id of the skill. self.skill.skill_context.decision_maker_address : this is the address of the decision maker and is set to \"dummy_decision_maker_address\" .","title":"Some Useful Skill Attributes"},{"location":"skill-testing/#some-useful-baseskilltestcase-methods","text":"There are a number of methods that BaseSkillTestCase offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for BaseSkillTestCase : self.get_quantity_in_outbox() : gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent. self.get_message_from_outbox() : gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message. self.message_has_attributes(actual_message: Message, message_type: Type[Message], **kwargs,) : you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using self.get_message_from_outbox() ), specify its expected type (e.g. FipaMessage ), and any other attribute you expect the message to have (e.g. message_id is 1) may be provided via keyword arguments. self.build_incoming_message : this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution.","title":"Some Useful BaseSkillTestCase Methods"},{"location":"skill-testing/#checking-logger-output","text":"You can check the output of your skill's logger by mocking it using unittest.mock before executing a part of your skill as such: import logging from unittest import mock with mock . patch . object ( self . my_behaviour . context . logger , \"log\" ) as mock_logger : self . my_behaviour . act () mock_logger . assert_any_call ( logging . INFO , \"some_logger_message\" ) In the above, we mock the logger before running my_behaviour 's act() method and check that the string \"some_logger_message\" is indeed passed to the logger.","title":"Checking Logger Output"},{"location":"skill-testing/#next-steps","text":"You can consult the fetchai/generic_buyer and fetchai/generic_seller skills and their associated tests here to study how BaseSkillTestCase can help you in testing your skills. You can also refer to the API to study the different methods BaseSkillTestCase makes available to make testing your skills easier.","title":"Next steps"},{"location":"skill/","text":"Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each skill has zero, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages (see next section). Behaviour : zero, one or more Behaviours encapsulate actions which further the AEAs goal and are initiated by internals of the AEA, rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of behaviours (e.g. cyclic/one-shot/finite-state-machine/etc.). Model : zero, one or more Models that inherit from the Model class. Models encapsulate custom objects which are made accessible to any part of a skill via the SkillContext . Task : zero, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of skills, but Task s are declared in or from skills if a packaging approach for AEA creation is used. A skill can read (parts of) the state of the the AEA (as summarised in the AgentContext ), and suggest actions to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. In technical terms this means skills are horizontally arranged. For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy. The skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions. The framework places no limits on the complexity of skills. They can implement simple (e.g. if-this-then-that ) or complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default skill, called error . Additional skills can be added as packages. Independence of skills Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker . Context The skill has a SkillContext object which is shared by all Handler , Behaviour , and Model objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( message = reply ) Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. A handler can be registered in one way: By declaring it in the skill configuration file skill.yaml (see below ). It is possible to register new handlers dynamically by enqueuing new Handler instances in the queue context.new_handlers , e.g. in a skill component we can write: self . context . new_handlers . put ( MyHandler ( name = \"my_handler\" , skill_context = self . context )) behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . In that case, setup is not called by the framework, as the behaviour will be added after the AEA setup is complete. The framework supports different types of behaviours: OneShotBehaviour : this behaviour is executed only once. TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour : SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution. tasks.py Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): \"\"\"Setup behaviour.\"\"\" my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): \"\"\"Act implementation.\"\"\" if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): \"\"\"Teardown behaviour.\"\"\" Models The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model Skill configuration Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:1.0.0 Error skill All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:1.0.0 protocol which provides error codes for the above. Custom Error handler The framework implements a default ErrorHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom ErrorHandler : aea scaffold error-handler Now you will see a file called error_handler.py in the AEA project root. You can then implement your own custom logic to process messages.","title":"Skills"},{"location":"skill/#independence-of-skills","text":"Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker .","title":"Independence of skills"},{"location":"skill/#context","text":"The skill has a SkillContext object which is shared by all Handler , Behaviour , and Model objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( message = reply ) Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. A handler can be registered in one way: By declaring it in the skill configuration file skill.yaml (see below ). It is possible to register new handlers dynamically by enqueuing new Handler instances in the queue context.new_handlers , e.g. in a skill component we can write: self . context . new_handlers . put ( MyHandler ( name = \"my_handler\" , skill_context = self . context ))","title":"handlers.py"},{"location":"skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . In that case, setup is not called by the framework, as the behaviour will be added after the AEA setup is complete. The framework supports different types of behaviours: OneShotBehaviour : this behaviour is executed only once. TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour : SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution.","title":"behaviours.py"},{"location":"skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): \"\"\"Setup behaviour.\"\"\" my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): \"\"\"Act implementation.\"\"\" if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): \"\"\"Teardown behaviour.\"\"\"","title":"tasks.py"},{"location":"skill/#models","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model","title":"Models"},{"location":"skill/#skill-configuration","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:1.0.0","title":"Skill configuration"},{"location":"skill/#error-skill","text":"All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:1.0.0 protocol which provides error codes for the above.","title":"Error skill"},{"location":"skill/#custom-error-handler","text":"The framework implements a default ErrorHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom ErrorHandler : aea scaffold error-handler Now you will see a file called error_handler.py in the AEA project root. You can then implement your own custom logic to process messages.","title":"Custom Error handler"},{"location":"standalone-transaction/","text":"In this guide, we will generate some wealth for the Fetch.ai testnet and create a standalone transaction. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer This guide requires the open-aea-ledger-fetchai plug-in installed in your Python environment: pip install open-aea-ledger-fetchai First, import the python and application specific libraries and set the static variables. import logging from aea_ledger_fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" Create the private keys # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) Create the wallets Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) Generate wealth Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) Send transaction Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) Stand-alone transaction full code import logging from aea_ledger_fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) if __name__ == \"__main__\" : run ()","title":"Create stand-alone transaction"},{"location":"standalone-transaction/#create-the-private-keys","text":"# Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 )","title":"Create the private keys"},{"location":"standalone-transaction/#create-the-wallets","text":"Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 })","title":"Create the wallets"},{"location":"standalone-transaction/#generate-wealth","text":"Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] )","title":"Generate wealth"},{"location":"standalone-transaction/#send-transaction","text":"Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) Stand-alone transaction full code import logging from aea_ledger_fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) if __name__ == \"__main__\" : run ()","title":"Send transaction"},{"location":"step-one/","text":"There are a number of ways to build an AEA: To start with, we recommended you build an AEA project step-by-step with the CLI tool as demonstrated in the quick start guide and described here . Using the CLI aea fetch command, pull in an already built project and run as is or extend it to your needs. The last option is to build an AEA programmatically as described here . Sometimes, an AEA is more than is required for the task at hand. In particular, an AEA is much more than just an agent. In those cases, we suggest you have a look at the following two guides: the AEA vs Agents guide shows the difference between an agent and an AEA in code, the Use multiplexer standalone guide shows how to use the multiplexer on its own to receive and send envelopes.","title":"Ways to build an AEA"},{"location":"trust/","text":"AEA applications have different requirements for trustlessness or trust minimisation . We can further minimise trust requirements by incorporating a third party as an arbitrator or escrow implemented in a smart contract to further reduce trust requirements.","title":"Trust minimisation"},{"location":"upgrading/","text":"This page provides some tips on how to upgrade AEA projects between different versions of the AEA framework. For full release notes check the AEA repo . The primary tool for upgrading AEA projects is the aea upgrade command in the CLI . Below we describe the additional manual steps required to upgrade between different versions: Open AEA v1.7.0 to 1.8.0 This release introduces a new format for PublicId parameter which allows users to use IPFS hashes as a part of the PublicId which may lead to some unexpected behaviours or bugs. Previous implementation of PublicId used author/package:version format, The new implementation uses author/package:version:hash This release also fixes the hash inconsistency by using wrapper hashes to represent packages. Plugins from previous versions are not compatible anymore. v1.6.0 to v1.7.0 No backwards incompatible changes. Plugins from previous versions are not compatible anymore. v1.5.0 to v1.6.0 No backwards incompatible changes. Plugins from previous versions are not compatible anymore. v1.4.0 to v1.5.0 No backwards incompatible changes. Plugins from previous versions are not compatible anymore. v1.3.0 to v1.4.0 No backwards incompatible changes. Plugins from previous versions are not compatible anymore. v1.2.0 to v1.3.0 No backwards incompatible changes. The open-aea-ledger-ethereum plugin now supports EIP1559 based gas estimation. v1.1.0 to v1.2.0 No backwards incompatible changes. The open-aea-ledger-ethereum plugin now supports EIP1159-style transactions. aea==v1.1.0 to open-aea==v1.1.0 Backwards incompatible changes: removal of the GOP decision maker handler. However, via the configuration option of the decision maker handler this can be simply added as a standalone file. conversion of plugins due to their dependency on aea . Simply replace aea-ledger-fetchai with open-aea-ledger-fetchai etc. Legacy packages can be used in open AEA too! Legacy AEA v1.0.2 to v1.1.0 No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes. v1.0.1 to v1.0.2 No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes. v1.0.0 to v1.0.1 No backwards incompatible changes. We advise everyone to upgrade their fetchai packages to get the latest fixes. v1.0.0rc2 to v1.0.0 No backwards incompatible changes to component development. We advise everyone to upgrade to v1 as soon as possible. When upgrading from versions below v1.0.0rc1 first upgrade to the first release candidate, then to v1 . v1.0.0rc1 to v1.0.0rc2 No backwards incompatible changes to component development. Various configuration changes introduced in v1.0.0rc1 are now enforced strictly. v0.11.1 to v1.0.0rc1 No backwards incompatible changes to component development. The aea-config.yaml now requires the field required_ledgers which must specify all ledgers for which private keys are required to run the agent. Please add it to your project. The registry_path field has been removed from the aea-config.yaml . Please remove it from your project. All packages provided by author fetchai must be upgraded. v0.11.0 to v0.11.1 No backwards incompatible changes. v0.10.1 to v0.11.0 Take special care when upgrading to v0.11.0 . We introduced several breaking changes in preparation for v1 ! CLI GUI We removed the CLI GUI. It was not used by anyone as far as we know and needs to be significantly improved. Soon we will release the AEA Manager App to make up for this. Message routing Routing has been completely revised and simplified. The new message routing logic is described here . When upgrading take the following steps: For agent-to-agent communication: ensure the default routing and default connection are correctly defined and that the dialogues used specify the agent's address as the self_address . This is most likely already the case. Only in some edge cases will you need to use an EnvelopeContext to target a connection different from the one specified in the default_routing map. For component-to-component communication: there is now only one single way to route component to component (skill to skill, skill to connection, connection to skill) messages, this is by specifying the component id in string form in the sender / to field. The EnvelopeContext can no longer be used, messages are routed based on their target ( to field). Ensure that dialogues in skills set the skill_id as the self_address (in connections they need to set the connection_id ). Agent configuration and ledger plugins Agent configuration files have a new optional field, dependencies , analogous to dependencies field in other AEA packages. The default value is the empty object {} . The field will be made mandatory in the next release. Crypto modules have been extracted and released as independent plug-ins, released on PyPI. In particular: Fetch.ai crypto classes have been released in the aea-ledger-fetchai package; Ethereum crypto classes have been released in the aea-ledger-ethereum package; Cosmos crypto classes have been released in the aea-ledger-cosmos package. If an AEA project, or an AEA package, makes use of crypto functionalities, it will be needed to add the above packages as PyPI dependencies with version specifiers ranging from the latest minor and the latest minor + 1 (excluded). E.g. if the latest version if 0.1.0 , the version specifier should be <0.2.0,>=0.1.0 : dependencies : aea-ledger-cosmos : version : <2.0.0,>=1.0.0 aea-ledger-ethereum : version : <2.0.0,>=1.0.0 aea-ledger-fetchai : version : <2.0.0,>=1.0.0 The version specifier sets are important, as these plug-ins, at version 0.1.0 , depend on a specific range of the aea package. Then, running aea install inside the AEA project should install them in the current Python environment. For more, read the guide on ledger plugins . v0.10.0 to v0.10.1 No backwards incompatible changes for skill and connection development. v0.9.2 to v0.10.0 Skill development sees no backward incompatible changes. Connection development requires updating the keyword arguments of the constructor: the new data_dir argument must be defined. Protocol specifications now need to contain a protocol_specification_id in addition to the public id. The protocol_specification_id is used for identifying Envelopes during transport. By being able to set the id independently of the protocol id, backwards compatibility in the specification (and therefore wire format) can be maintained even when the Python implementation changes. Please update to the latest packages by running aea upgrade and then re-generating your own protocols. v0.9.1 to v0.9.2 No backwards incompatible changes for skill and connection development. v0.9.0 to v0.9.1 No backwards incompatible changes for skill and connection development. v0.8.0 to v0.9.0 This release introduces proof of representation in the ACN. You will need to upgrade to the latest fetchai/p2p_libp2p or fetchai/p2p_libp2p_client connection and then use two key pairs, one for your AEA's decision maker and one for the connection. Please update to the latest packages by running aea upgrade . v0.7.5 to v0.8.0 Minimal backwards incompatible changes for skill and connection development: The semantics of the < , <= , > and >= relations in ConstraintTypes are simplified. Protocols now need to correctly define terminal states. Regenerate your protocol to identify if your protocol's dialogue rules are valid. Please update to the latest packages by running aea upgrade . v0.7.4 to v0.7.5 No backwards incompatible changes for skill and connection development. v0.7.3 to v0.7.4 No backwards incompatible changes for skill and connection development. v0.7.2 to v0.7.3 No backwards incompatible changes for skill and connection development. v0.7.1 to v0.7.2 No backwards incompatible changes for skill and connection development. v0.7.0 to v0.7.1 To improve performance, in particular optimize memory usage, we refactored the Message and Dialogue classes. This means all protocols need to be bumped to the latest version or regenerated using the aea generate protocol command in the CLI . v0.6.3 to v0.7.0 Multiple breaking changes require action in this order: Custom configuration overrides in aea-config.yaml are now identified via public_id rather than author , name and version individually. Please replace the three fields with the equivalent public_id . Run aea upgrade command to upgrade your project's dependencies. Note, you still do have to manually update the public ids under default_routing and default_connection in aea-config.yaml as well as the public ids in the non-vendor packages. Previously, connection fetchai/stub , skill fetchai/error and protocols fetchai/default , fetchai/signing and fetchai/state_update where part of the AEA distribution. Now they need to be fetched from registry. If you create a new project with aea create then this happens automatically. For existing projects, add the dependencies explicitly if not already present. You also must update the import paths as follows: aea.connections.stub > packages.fetchai.connections.stub aea.protocols.default > packages.fetchai.protocols.default aea.protocols.signing > packages.fetchai.protocols.signing aea.protocols.state_update > packages.fetchai.protocols.state_update aea.skills.error > packages.fetchai.skills.error If you use custom protocols, regenerate them. In your own skills' __init__.py files add the public id (updating the string as appropriate): from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"author/name:0.1.0\" ) - The fetchai/http protocol's bodyy field has been renamed to body . Skills can now specify connections as dependencies in the configuration YAML. v0.6.2 to v0.6.3 A new upgrade command is introduced to upgrade agent projects and components to their latest versions on the registry. To use the command first upgrade the AEA PyPI package to the latest version, then enter your project and run aea upgrade . The project's vendor dependencies will be updated where possible. v0.6.1 to v0.6.2 No public APIs have been changed. v0.6.0 to v0.6.1 The soef connection and oef_search protocol have backward incompatible changes. v0.5.4 to v0.6.0 Dialogue and Dialogues API updates The dialogue and dialogues APIs have changed significantly. The constructor is different for both classes and there are now four primary methods for the developer: Dialogues.create : this method is used to create a new dialogue and message: cfp_msg , fipa_dialogue = fipa_dialogues . create ( counterparty = opponent_address , performative = FipaMessage . Performative . CFP , query = query , ) The method will raise if the provided arguments are inconsistent. Dialogues.create_with_message : this method is used to create a new dialogue from a message: fipa_dialogue = fipa_dialogues . create_with_message ( counterparty = opponent_address , initial_message = cfp_msg ) The method will raise if the provided arguments are inconsistent. Dialogues.update : this method is used to handle messages passed by the framework: fipa_dialogue = fipa_dialogues . update ( message = cfp_msg ) The method will return a valid dialogue if it is a valid message, otherwise it will return None . Dialogue.reply : this method is used to reply within a dialogue: proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = cfp_msg , proposal = proposal , ) The method will raise if the provided arguments are inconsistent. The new methods significantly reduce the lines of code needed to maintain a dialogue. They also make it easier for the developer to construct valid dialogues and messages. FetchAICrypto - default crypto The FetchAICrypto has been upgraded to the default crypto. Update your default_ledger to fetchai . Private key file naming The private key files are now consistently named with the ledger_id followed by _private_key.txt (e.g. fetchai_private_key.txt ). Rename your existing files to match this pattern. Type in package YAML The package YAML files now contain a type field. This must be added for the loading mechanism to work properly. Moved address type The address type has moved to aea.common . The import paths must be updated. v0.5.3 to v0.5.4 The contract base class was slightly modified. If you have implemented your own contract package you need to update it accordingly. The dialogue reference nonce is now randomly generated. This can result in previously working but buggy implementations (which relied on the order of dialogue reference nonces) to now fail. v0.5.2 to v0.5.3 Connection states and logger usage in connections where updated. If you have implemented your own connection package you need to update it accordingly. Additional dialogue consistency checks where enabled. This can result in previously working but buggy implementations to now fail. v0.5.1 to 0.5.2 No public APIs have been changed. v0.5.0 to 0.5.1 No public APIs have been changed. v0.4.1 to 0.5.0 A number of breaking changes where introduced which make backwards compatibility of skills rare. Ledger APIs LedgerApis have been removed from the AEA constructor and skill context. LedgerApis are now exposed in the LedgerConnection ( fetchai/ledger ). To communicate with the LedgerApis use the fetchai/ledger_api protocol. This allows for more flexibility (anyone can add another LedgerAPI to the registry and execute it with the connection) and removes dependencies from the core framework. Skills can now depend on other skills. As a result, skills have a new required configuration field in skill.yaml files, by default empty: skills: [] . v0.4.0 to v0.4.1 There are no upgrade requirements if you use the CLI based approach to AEA development. Connections are now added via Resources to the AEA, not the AEA constructor directly. For programmatic usage remove the list of connections from the AEA constructor and instead add the connections to resources. v0.3.3 to v0.4.0 Message sending in the skills has been updated. In the past you had to construct messages, then serialize them and place them in an envelope: cfp_msg = FipaMessage ( ... ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) # or cfp_msg = FipaMessage ( ... ) envelope = Envelope ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) self . context . outbox . put ( envelope ) Now this has been simplified to: cfp_msg = FipaMessage ( ... ) cfp_msg . counterparty = opponent_addr self . context . outbox . put_message ( message = cfp_msg ) You must update your skills as the old implementation is no longer supported. Connection constructors have been simplified. In the past you had to implement both the `__init__` as well as the `from_config` methods of a Connection. Now you only have to implement the `__init__` method which by default at load time now receives the following keyword arguments: `configuration: ConnectionConfig, identity: Identity, crypto_store: CryptoStore`. See for example in the scaffold connection: class MyScaffoldConnection ( Connection ): \"\"\"Proxy to the functionality of the SDK or API.\"\"\" connection_id = PublicId . from_str ( \"fetchai/scaffold:0.1.0\" ) def __init__ ( self , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ): \"\"\" Initialize a connection to an SDK or API. :param configuration: the connection configuration. :param crypto_store: object to access the connection crypto objects. :param identity: the identity object. \"\"\" super () . __init__ ( configuration = configuration , crypto_store = crypto_store , identity = identity ) As a result of this feature, you are now able to pass key-pairs to your connections via the `CryptoStore`. You must update your connections as the old implementation is no longer supported.","title":"Upgrading"},{"location":"upgrading/#open-aea","text":"","title":"Open AEA"},{"location":"upgrading/#v170-to-180","text":"This release introduces a new format for PublicId parameter which allows users to use IPFS hashes as a part of the PublicId which may lead to some unexpected behaviours or bugs. Previous implementation of PublicId used author/package:version format, The new implementation uses author/package:version:hash This release also fixes the hash inconsistency by using wrapper hashes to represent packages. Plugins from previous versions are not compatible anymore.","title":"v1.7.0 to 1.8.0"},{"location":"upgrading/#v160-to-v170","text":"No backwards incompatible changes. Plugins from previous versions are not compatible anymore.","title":"v1.6.0 to v1.7.0"},{"location":"upgrading/#v150-to-v160","text":"No backwards incompatible changes. Plugins from previous versions are not compatible anymore.","title":"v1.5.0 to v1.6.0"},{"location":"upgrading/#v140-to-v150","text":"No backwards incompatible changes. Plugins from previous versions are not compatible anymore.","title":"v1.4.0 to v1.5.0"},{"location":"upgrading/#v130-to-v140","text":"No backwards incompatible changes. Plugins from previous versions are not compatible anymore.","title":"v1.3.0 to v1.4.0"},{"location":"upgrading/#v120-to-v130","text":"No backwards incompatible changes. The open-aea-ledger-ethereum plugin now supports EIP1559 based gas estimation.","title":"v1.2.0 to v1.3.0"},{"location":"upgrading/#v110-to-v120","text":"No backwards incompatible changes. The open-aea-ledger-ethereum plugin now supports EIP1159-style transactions.","title":"v1.1.0 to v1.2.0"},{"location":"upgrading/#aeav110-to-open-aeav110","text":"Backwards incompatible changes: removal of the GOP decision maker handler. However, via the configuration option of the decision maker handler this can be simply added as a standalone file. conversion of plugins due to their dependency on aea . Simply replace aea-ledger-fetchai with open-aea-ledger-fetchai etc. Legacy packages can be used in open AEA too!","title":"aea==v1.1.0 to open-aea==v1.1.0"},{"location":"upgrading/#legacy-aea","text":"","title":"Legacy AEA"},{"location":"upgrading/#v102-to-v110","text":"No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes.","title":"v1.0.2 to v1.1.0"},{"location":"upgrading/#v101-to-v102","text":"No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes.","title":"v1.0.1 to v1.0.2"},{"location":"upgrading/#v100-to-v101","text":"No backwards incompatible changes. We advise everyone to upgrade their fetchai packages to get the latest fixes.","title":"v1.0.0 to v1.0.1"},{"location":"upgrading/#v100rc2-to-v100","text":"No backwards incompatible changes to component development. We advise everyone to upgrade to v1 as soon as possible. When upgrading from versions below v1.0.0rc1 first upgrade to the first release candidate, then to v1 .","title":"v1.0.0rc2 to v1.0.0"},{"location":"upgrading/#v100rc1-to-v100rc2","text":"No backwards incompatible changes to component development. Various configuration changes introduced in v1.0.0rc1 are now enforced strictly.","title":"v1.0.0rc1 to v1.0.0rc2"},{"location":"upgrading/#v0111-to-v100rc1","text":"No backwards incompatible changes to component development. The aea-config.yaml now requires the field required_ledgers which must specify all ledgers for which private keys are required to run the agent. Please add it to your project. The registry_path field has been removed from the aea-config.yaml . Please remove it from your project. All packages provided by author fetchai must be upgraded.","title":"v0.11.1 to v1.0.0rc1"},{"location":"upgrading/#v0110-to-v0111","text":"No backwards incompatible changes.","title":"v0.11.0 to v0.11.1"},{"location":"upgrading/#v0101-to-v0110","text":"Take special care when upgrading to v0.11.0 . We introduced several breaking changes in preparation for v1 !","title":"v0.10.1 to v0.11.0"},{"location":"upgrading/#cli-gui","text":"We removed the CLI GUI. It was not used by anyone as far as we know and needs to be significantly improved. Soon we will release the AEA Manager App to make up for this.","title":"CLI GUI"},{"location":"upgrading/#message-routing","text":"Routing has been completely revised and simplified. The new message routing logic is described here . When upgrading take the following steps: For agent-to-agent communication: ensure the default routing and default connection are correctly defined and that the dialogues used specify the agent's address as the self_address . This is most likely already the case. Only in some edge cases will you need to use an EnvelopeContext to target a connection different from the one specified in the default_routing map. For component-to-component communication: there is now only one single way to route component to component (skill to skill, skill to connection, connection to skill) messages, this is by specifying the component id in string form in the sender / to field. The EnvelopeContext can no longer be used, messages are routed based on their target ( to field). Ensure that dialogues in skills set the skill_id as the self_address (in connections they need to set the connection_id ).","title":"Message routing"},{"location":"upgrading/#agent-configuration-and-ledger-plugins","text":"Agent configuration files have a new optional field, dependencies , analogous to dependencies field in other AEA packages. The default value is the empty object {} . The field will be made mandatory in the next release. Crypto modules have been extracted and released as independent plug-ins, released on PyPI. In particular: Fetch.ai crypto classes have been released in the aea-ledger-fetchai package; Ethereum crypto classes have been released in the aea-ledger-ethereum package; Cosmos crypto classes have been released in the aea-ledger-cosmos package. If an AEA project, or an AEA package, makes use of crypto functionalities, it will be needed to add the above packages as PyPI dependencies with version specifiers ranging from the latest minor and the latest minor + 1 (excluded). E.g. if the latest version if 0.1.0 , the version specifier should be <0.2.0,>=0.1.0 : dependencies : aea-ledger-cosmos : version : <2.0.0,>=1.0.0 aea-ledger-ethereum : version : <2.0.0,>=1.0.0 aea-ledger-fetchai : version : <2.0.0,>=1.0.0 The version specifier sets are important, as these plug-ins, at version 0.1.0 , depend on a specific range of the aea package. Then, running aea install inside the AEA project should install them in the current Python environment. For more, read the guide on ledger plugins .","title":"Agent configuration and ledger plugins"},{"location":"upgrading/#v0100-to-v0101","text":"No backwards incompatible changes for skill and connection development.","title":"v0.10.0 to v0.10.1"},{"location":"upgrading/#v092-to-v0100","text":"Skill development sees no backward incompatible changes. Connection development requires updating the keyword arguments of the constructor: the new data_dir argument must be defined. Protocol specifications now need to contain a protocol_specification_id in addition to the public id. The protocol_specification_id is used for identifying Envelopes during transport. By being able to set the id independently of the protocol id, backwards compatibility in the specification (and therefore wire format) can be maintained even when the Python implementation changes. Please update to the latest packages by running aea upgrade and then re-generating your own protocols.","title":"v0.9.2 to v0.10.0"},{"location":"upgrading/#v091-to-v092","text":"No backwards incompatible changes for skill and connection development.","title":"v0.9.1 to v0.9.2"},{"location":"upgrading/#v090-to-v091","text":"No backwards incompatible changes for skill and connection development.","title":"v0.9.0 to v0.9.1"},{"location":"upgrading/#v080-to-v090","text":"This release introduces proof of representation in the ACN. You will need to upgrade to the latest fetchai/p2p_libp2p or fetchai/p2p_libp2p_client connection and then use two key pairs, one for your AEA's decision maker and one for the connection. Please update to the latest packages by running aea upgrade .","title":"v0.8.0 to v0.9.0"},{"location":"upgrading/#v075-to-v080","text":"Minimal backwards incompatible changes for skill and connection development: The semantics of the < , <= , > and >= relations in ConstraintTypes are simplified. Protocols now need to correctly define terminal states. Regenerate your protocol to identify if your protocol's dialogue rules are valid. Please update to the latest packages by running aea upgrade .","title":"v0.7.5 to v0.8.0"},{"location":"upgrading/#v074-to-v075","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.4 to v0.7.5"},{"location":"upgrading/#v073-to-v074","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.3 to v0.7.4"},{"location":"upgrading/#v072-to-v073","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.2 to v0.7.3"},{"location":"upgrading/#v071-to-v072","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.1 to v0.7.2"},{"location":"upgrading/#v070-to-v071","text":"To improve performance, in particular optimize memory usage, we refactored the Message and Dialogue classes. This means all protocols need to be bumped to the latest version or regenerated using the aea generate protocol command in the CLI .","title":"v0.7.0 to v0.7.1"},{"location":"upgrading/#v063-to-v070","text":"Multiple breaking changes require action in this order: Custom configuration overrides in aea-config.yaml are now identified via public_id rather than author , name and version individually. Please replace the three fields with the equivalent public_id . Run aea upgrade command to upgrade your project's dependencies. Note, you still do have to manually update the public ids under default_routing and default_connection in aea-config.yaml as well as the public ids in the non-vendor packages. Previously, connection fetchai/stub , skill fetchai/error and protocols fetchai/default , fetchai/signing and fetchai/state_update where part of the AEA distribution. Now they need to be fetched from registry. If you create a new project with aea create then this happens automatically. For existing projects, add the dependencies explicitly if not already present. You also must update the import paths as follows: aea.connections.stub > packages.fetchai.connections.stub aea.protocols.default > packages.fetchai.protocols.default aea.protocols.signing > packages.fetchai.protocols.signing aea.protocols.state_update > packages.fetchai.protocols.state_update aea.skills.error > packages.fetchai.skills.error If you use custom protocols, regenerate them. In your own skills' __init__.py files add the public id (updating the string as appropriate): from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"author/name:0.1.0\" ) - The fetchai/http protocol's bodyy field has been renamed to body . Skills can now specify connections as dependencies in the configuration YAML.","title":"v0.6.3 to v0.7.0"},{"location":"upgrading/#v062-to-v063","text":"A new upgrade command is introduced to upgrade agent projects and components to their latest versions on the registry. To use the command first upgrade the AEA PyPI package to the latest version, then enter your project and run aea upgrade . The project's vendor dependencies will be updated where possible.","title":"v0.6.2 to v0.6.3"},{"location":"upgrading/#v061-to-v062","text":"No public APIs have been changed.","title":"v0.6.1 to v0.6.2"},{"location":"upgrading/#v060-to-v061","text":"The soef connection and oef_search protocol have backward incompatible changes.","title":"v0.6.0 to v0.6.1"},{"location":"upgrading/#v054-to-v060","text":"","title":"v0.5.4 to v0.6.0"},{"location":"upgrading/#dialogue-and-dialogues-api-updates","text":"The dialogue and dialogues APIs have changed significantly. The constructor is different for both classes and there are now four primary methods for the developer: Dialogues.create : this method is used to create a new dialogue and message: cfp_msg , fipa_dialogue = fipa_dialogues . create ( counterparty = opponent_address , performative = FipaMessage . Performative . CFP , query = query , ) The method will raise if the provided arguments are inconsistent. Dialogues.create_with_message : this method is used to create a new dialogue from a message: fipa_dialogue = fipa_dialogues . create_with_message ( counterparty = opponent_address , initial_message = cfp_msg ) The method will raise if the provided arguments are inconsistent. Dialogues.update : this method is used to handle messages passed by the framework: fipa_dialogue = fipa_dialogues . update ( message = cfp_msg ) The method will return a valid dialogue if it is a valid message, otherwise it will return None . Dialogue.reply : this method is used to reply within a dialogue: proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = cfp_msg , proposal = proposal , ) The method will raise if the provided arguments are inconsistent. The new methods significantly reduce the lines of code needed to maintain a dialogue. They also make it easier for the developer to construct valid dialogues and messages.","title":"Dialogue and Dialogues API updates"},{"location":"upgrading/#fetchaicrypto-default-crypto","text":"The FetchAICrypto has been upgraded to the default crypto. Update your default_ledger to fetchai .","title":"FetchAICrypto - default crypto"},{"location":"upgrading/#private-key-file-naming","text":"The private key files are now consistently named with the ledger_id followed by _private_key.txt (e.g. fetchai_private_key.txt ). Rename your existing files to match this pattern.","title":"Private key file naming"},{"location":"upgrading/#type-in-package-yaml","text":"The package YAML files now contain a type field. This must be added for the loading mechanism to work properly.","title":"Type in package YAML"},{"location":"upgrading/#moved-address-type","text":"The address type has moved to aea.common . The import paths must be updated.","title":"Moved address type"},{"location":"upgrading/#v053-to-v054","text":"The contract base class was slightly modified. If you have implemented your own contract package you need to update it accordingly. The dialogue reference nonce is now randomly generated. This can result in previously working but buggy implementations (which relied on the order of dialogue reference nonces) to now fail.","title":"v0.5.3 to v0.5.4"},{"location":"upgrading/#v052-to-v053","text":"Connection states and logger usage in connections where updated. If you have implemented your own connection package you need to update it accordingly. Additional dialogue consistency checks where enabled. This can result in previously working but buggy implementations to now fail.","title":"v0.5.2 to v0.5.3"},{"location":"upgrading/#v051-to-052","text":"No public APIs have been changed.","title":"v0.5.1 to 0.5.2"},{"location":"upgrading/#v050-to-051","text":"No public APIs have been changed.","title":"v0.5.0 to 0.5.1"},{"location":"upgrading/#v041-to-050","text":"A number of breaking changes where introduced which make backwards compatibility of skills rare. Ledger APIs LedgerApis have been removed from the AEA constructor and skill context. LedgerApis are now exposed in the LedgerConnection ( fetchai/ledger ). To communicate with the LedgerApis use the fetchai/ledger_api protocol. This allows for more flexibility (anyone can add another LedgerAPI to the registry and execute it with the connection) and removes dependencies from the core framework. Skills can now depend on other skills. As a result, skills have a new required configuration field in skill.yaml files, by default empty: skills: [] .","title":"v0.4.1 to 0.5.0"},{"location":"upgrading/#v040-to-v041","text":"There are no upgrade requirements if you use the CLI based approach to AEA development. Connections are now added via Resources to the AEA, not the AEA constructor directly. For programmatic usage remove the list of connections from the AEA constructor and instead add the connections to resources.","title":"v0.4.0 to v0.4.1"},{"location":"upgrading/#v033-to-v040","text":"Message sending in the skills has been updated. In the past you had to construct messages, then serialize them and place them in an envelope: cfp_msg = FipaMessage ( ... ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) # or cfp_msg = FipaMessage ( ... ) envelope = Envelope ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) self . context . outbox . put ( envelope ) Now this has been simplified to: cfp_msg = FipaMessage ( ... ) cfp_msg . counterparty = opponent_addr self . context . outbox . put_message ( message = cfp_msg ) You must update your skills as the old implementation is no longer supported. Connection constructors have been simplified. In the past you had to implement both the `__init__` as well as the `from_config` methods of a Connection. Now you only have to implement the `__init__` method which by default at load time now receives the following keyword arguments: `configuration: ConnectionConfig, identity: Identity, crypto_store: CryptoStore`. See for example in the scaffold connection: class MyScaffoldConnection ( Connection ): \"\"\"Proxy to the functionality of the SDK or API.\"\"\" connection_id = PublicId . from_str ( \"fetchai/scaffold:0.1.0\" ) def __init__ ( self , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ): \"\"\" Initialize a connection to an SDK or API. :param configuration: the connection configuration. :param crypto_store: object to access the connection crypto objects. :param identity: the identity object. \"\"\" super () . __init__ ( configuration = configuration , crypto_store = crypto_store , identity = identity ) As a result of this feature, you are now able to pass key-pairs to your connections via the `CryptoStore`. You must update your connections as the old implementation is no longer supported.","title":"v0.3.3 to v0.4.0"},{"location":"version/","text":"Note The (open) AEA framework provides the necessary tools for creating Autonomous Economic Agents (AEA). It is a fork of the legacy AEA framework that gives no priority to any package vendor. The latest version of the Python implementation of the AEA Framework on PyPI. If you are upgrading your AEA project from a previous version of the AEA framework, please check out the upgrading guide . The AEA framework's implementation in Python is in principle compatible with its implementation in any other language. The language agnostic definitions describe the aspects of the framework an implementation must adhere to in order for their AEAs to be able to interact with AEAs built with other implementations of the framework.","title":"Version"},{"location":"vision/","text":"Our vision is that the AEA framework enables businesses of all sizes, from single independent developers to large corporations and consortiums, to create and deploy agent-based solutions in different domains, thus contributing to and advancing a decentralized agent economy as envisaged by Valory. Open source technology for everyone We are creating infrastructure for developers to build their own agent-based solutions. AEA users include, amongst others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students and academics Crypto connoisseurs and enthusiasts Web developers","title":"Vision"},{"location":"vision/#open-source-technology-for-everyone","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users include, amongst others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students and academics Crypto connoisseurs and enthusiasts Web developers","title":"Open source technology for everyone"},{"location":"wealth/","text":"To fund an AEA for testing on a test-net you need to request some test tokens from a faucet. First, make sure you have installed the crypto plugin of the target test-net. E.g. for Ethereum: pip install open-aea-ledger-ethereum Add a private key to the agent aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Note If you already have keys in your project, the commands will prompt you for confirmation whether or not to replace the existing keys. Using a faucet website First, print the address: aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth ethereum Using the CLI Simply generate wealth via the CLI: aea generate-wealth ethereum","title":"Generating wealth"},{"location":"wealth/#using-a-faucet-website","text":"First, print the address: aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth ethereum","title":"Using a faucet website"},{"location":"wealth/#using-the-cli","text":"Simply generate wealth via the CLI: aea generate-wealth ethereum","title":"Using the CLI"},{"location":"api/abstract_agent/","text":"aea.abstract _ agent This module contains the interface definition of the abstract agent. AbstractAgent Objects class AbstractAgent ( ABC ) This class provides an abstract base interface for an agent. name @property @abstractmethod def name () -> str Get agent's name. storage _ uri @property @abstractmethod def storage_uri () -> Optional [ str ] Return storage uri. start @abstractmethod def start () -> None Start the agent. Returns : None stop @abstractmethod def stop () -> None Stop the agent. Returns : None setup @abstractmethod def setup () -> None Set up the agent. Returns : None act @abstractmethod def act () -> None Perform actions on period. Returns : None handle _ envelope @abstractmethod def handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None get _ periodic _ tasks @abstractmethod def get_periodic_tasks ( ) -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers @abstractmethod def get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message exception _ handler @abstractmethod def exception_handler ( exception : Exception , function : Callable ) -> Optional [ bool ] Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : skip exception if True, otherwise re-raise it teardown @abstractmethod def teardown () -> None Tear down the agent. Returns : None","title":"AbstractAgent"},{"location":"api/abstract_agent/#aeaabstract_agent","text":"This module contains the interface definition of the abstract agent.","title":"aea.abstract_agent"},{"location":"api/abstract_agent/#abstractagent-objects","text":"class AbstractAgent ( ABC ) This class provides an abstract base interface for an agent.","title":"AbstractAgent Objects"},{"location":"api/abstract_agent/#name","text":"@property @abstractmethod def name () -> str Get agent's name.","title":"name"},{"location":"api/abstract_agent/#storage_uri","text":"@property @abstractmethod def storage_uri () -> Optional [ str ] Return storage uri.","title":"storage_uri"},{"location":"api/abstract_agent/#start","text":"@abstractmethod def start () -> None Start the agent. Returns : None","title":"start"},{"location":"api/abstract_agent/#stop","text":"@abstractmethod def stop () -> None Stop the agent. Returns : None","title":"stop"},{"location":"api/abstract_agent/#setup","text":"@abstractmethod def setup () -> None Set up the agent. Returns : None","title":"setup"},{"location":"api/abstract_agent/#act","text":"@abstractmethod def act () -> None Perform actions on period. Returns : None","title":"act"},{"location":"api/abstract_agent/#handle_envelope","text":"@abstractmethod def handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None","title":"handle_envelope"},{"location":"api/abstract_agent/#get_periodic_tasks","text":"@abstractmethod def get_periodic_tasks ( ) -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"api/abstract_agent/#get_message_handlers","text":"@abstractmethod def get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"api/abstract_agent/#exception_handler","text":"@abstractmethod def exception_handler ( exception : Exception , function : Callable ) -> Optional [ bool ] Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : skip exception if True, otherwise re-raise it","title":"exception_handler"},{"location":"api/abstract_agent/#teardown","text":"@abstractmethod def teardown () -> None Tear down the agent. Returns : None","title":"teardown"},{"location":"api/aea/","text":"aea.aea This module contains the implementation of an autonomous economic agent (AEA). AEA Objects class AEA ( Agent ) This class implements an autonomous economic agent. __ init __","title":"AEA"},{"location":"api/aea/#aeaaea","text":"This module contains the implementation of an autonomous economic agent (AEA).","title":"aea.aea"},{"location":"api/aea/#aea-objects","text":"class AEA ( Agent ) This class implements an autonomous economic agent.","title":"AEA Objects"},{"location":"api/aea/#__init__","text":"","title":"__init__"},{"location":"api/aea_builder/","text":"aea.aea _ builder This module contains utilities for building an AEA. _ DependenciesManager Objects class _DependenciesManager () Class to manage dependencies of agent packages. __ init __ def __init__ () -> None Initialize the dependency graph. all _ dependencies @property def all_dependencies () -> Set [ ComponentId ] Get all dependencies. dependencies _ highest _ version @property def dependencies_highest_version () -> Set [ ComponentId ] Get the dependencies with highest version. get _ components _ by _ type def get_components_by_type ( component_type : ComponentType ) -> Dict [ ComponentId , ComponentConfiguration ] Get the components by type. protocols @property def protocols () -> Dict [ ComponentId , ProtocolConfig ] Get the protocols. connections @property def connections () -> Dict [ ComponentId , ConnectionConfig ] Get the connections. skills @property def skills () -> Dict [ ComponentId , SkillConfig ] Get the skills. contracts @property def contracts () -> Dict [ ComponentId , ContractConfig ] Get the contracts. add _ component def add_component ( configuration : ComponentConfiguration ) -> None Add a component to the dependency manager. Arguments : configuration : the component configuration to add. remove _ component def remove_component ( component_id : ComponentId ) -> None Remove a component. Arguments : component_id : the component id Raises : ValueError : if some component depends on this package. pypi _ dependencies @property def pypi_dependencies () -> Dependencies Get all the PyPI dependencies. We currently consider only dependency that have the default PyPI index url and that specify only the version field. Returns : the merged PyPI dependencies install _ dependencies def install_dependencies () -> None Install extra dependencies for components. AEABuilder Objects class AEABuilder ( WithLogger ) This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself. Note: the method 'build()' is guaranteed of being re-entrant with respect to the 'add_component(path)' method. That is, you can invoke the building method many times against the same builder instance, and the returned agent instance will not share the components with other agents, e.g.: builder = AEABuilder() builder.add_component(...) ... first call my_aea_1 = builder.build() following agents will have different components. my_aea_2 = builder.build() # all good However, if you manually loaded some of the components and added them with the method 'add_component_instance()', then calling build more than one time is prevented: builder = AEABuilder() builder.add_component_instance(...) ... # other initialization code first call my_aea_1 = builder.build() second call to build() would raise a Value Error. call reset builder.reset() re-add the component and private keys builder.add_component_instance(...) ... # add private keys second call my_aea_2 = builder.builder() __ init __ def __init__ ( with_default_packages : bool = True , registry_dir : str = DEFAULT_REGISTRY_NAME , build_dir_root : Optional [ str ] = None ) -> None Initialize the builder. Arguments : with_default_packages : add the default packages. registry_dir : the registry directory. build_dir_root : the root of the build directory. reset def reset ( is_full_reset : bool = False ) -> None Reset the builder. A full reset causes a reset of all data on the builder. A partial reset only resets: - name, - private keys, and - component instances Arguments : is_full_reset : whether it is a full reset or not. set _ period def set_period ( period : Optional [ float ]) -> \"AEABuilder\" Set agent act period. Arguments : period : period in seconds Returns : self set _ execution _ timeout def set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self set _ max _ reactions def set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self set _ decision _ maker _ handler _ details def set_decision_maker_handler_details ( decision_maker_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler config : the configuration passed to the decision maker handler on instantiation Returns : self set _ error _ handler _ details def set_error_handler_details ( error_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : error_handler_dotted_path : the dotted path to the error handler file_path : the file path to the file which contains the error handler config : the configuration passed to the error handler on instantiation Returns : self set _ skill _ exception _ policy def set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self set _ connection _ exception _ policy def set_connection_exception_policy ( connection_exception_policy : Optional [ ExceptionPolicyEnum ] ) -> \"AEABuilder\" Set connection exception policy. Arguments : connection_exception_policy : the policy Returns : self set _ default _ routing def set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self set _ loop _ mode def set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self set _ runtime _ mode def set_runtime_mode ( runtime_mode : Optional [ str ]) -> \"AEABuilder\" Set the runtime mode. Arguments : runtime_mode : the agent runtime mode Returns : self set _ task _ manager _ mode def set_task_manager_mode ( task_manager_mode : Optional [ str ]) -> \"AEABuilder\" Set the task_manager_mode. Arguments : task_manager_mode : the agent task_manager_mode Returns : self set _ storage _ uri def set_storage_uri ( storage_uri : Optional [ str ]) -> \"AEABuilder\" Set the storage uri. Arguments : storage_uri : storage uri Returns : self set _ data _ dir def set_data_dir ( data_dir : Optional [ str ]) -> \"AEABuilder\" Set the data directory. Arguments : data_dir : path to directory where to store data. Returns : self set _ logging _ config def set_logging_config ( logging_config : Dict ) -> \"AEABuilder\" Set the logging configurations. The dictionary must satisfy the following schema: https://docs.python.org/3/library/logging.config.html#logging-config-dictschema Arguments : logging_config : the logging configurations. Returns : self set _ search _ service _ address def set_search_service_address ( search_service_address : str ) -> \"AEABuilder\" Set the search service address. Arguments : search_service_address : the search service address Returns : self set _ name def set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder set _ default _ connection def set_default_connection ( public_id : Optional [ PublicId ] = None ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder add _ private _ key def add_private_key ( identifier : str , private_key_path : Optional [ PathLike ] = None , is_connection : bool = False ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : an (optional) path to the private key file. If None, the key will be created at build time. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder remove _ private _ key def remove_private_key ( identifier : str , is_connection : bool = False ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder private _ key _ paths @property def private_key_paths () -> Dict [ str , Optional [ str ]] Get the private key paths. connection _ private _ key _ paths @property def connection_private_key_paths () -> Dict [ str , Optional [ str ]] Get the connection private key paths. set _ default _ ledger def set_default_ledger ( identifier : Optional [ str ]) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder set _ required _ ledgers def set_required_ledgers ( required_ledgers : Optional [ List [ str ]]) -> \"AEABuilder\" Set the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Arguments : required_ledgers : the required ledgers. Returns : the AEABuilder. set _ build _ entrypoint def set_build_entrypoint ( build_entrypoint : Optional [ str ]) -> \"AEABuilder\" Set build entrypoint. Arguments : build_entrypoint : path to the builder script. Returns : the AEABuilder set _ currency _ denominations def set_currency_denominations ( currency_denominations : Dict [ str , str ]) -> \"AEABuilder\" Set the mapping from ledger ids to currency denominations. Arguments : currency_denominations : the mapping Returns : the AEABuilder add _ component def add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. # noqa: DAR402 | or if there's a missing dependency. # noqa: DAR402 Returns : the AEABuilder add _ component _ instance def add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. Notice also that this will make the call to 'build()' non re-entrant. You will have to reset() the builder before calling build() again. Arguments : component : Component instance already initialized. Returns : self set _ context _ namespace def set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace. set _ agent _ pypi _ dependencies def set_agent_pypi_dependencies ( dependencies : Dependencies ) -> \"AEABuilder\" Set agent PyPI dependencies. Arguments : dependencies : PyPI dependencies for the agent. Returns : the AEABuilder. remove _ component def remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder add _ protocol def add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder remove _ protocol def remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder add _ connection def add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder remove _ connection def remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder add _ skill def add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder remove _ skill def remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder add _ contract def add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder remove _ contract def remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder call _ all _ build _ entrypoints def call_all_build_entrypoints () -> None Call all the build entrypoints. get _ build _ root _ directory def get_build_root_directory () -> str Get build directory root. run _ build _ for _ component _ configuration @classmethod def run_build_for_component_configuration ( cls , config : ComponentConfiguration , logger : Optional [ logging . Logger ] = None ) -> None Run a build entrypoint script for component configuration. install _ pypi _ dependencies def install_pypi_dependencies () -> None Install components extra dependencies. build def build ( connection_ids : Optional [ Collection [ PublicId ]] = None , password : Optional [ str ] = None ) -> AEA Build the AEA. This method is re-entrant only if the components have been added through the method 'add_component'. If some of them have been loaded with 'add_component_instance', it can be called only once, and further calls are only possible after a call to 'reset' and re-loading of the components added via 'add_component_instance' and the private keys. Arguments : connection_ids : select only these connections to run the AEA. password : the password to encrypt/decrypt the private key. Returns : the AEA object. get _ default _ ledger def get_default_ledger () -> str Return default ledger. Returns : the default ledger identifier. get _ required _ ledgers def get_required_ledgers () -> List [ str ] Get the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Returns : the list of required ledgers. try _ to _ load _ agent _ configuration _ file @classmethod def try_to_load_agent_configuration_file ( cls , aea_project_path : Union [ str , Path ], apply_environment_variables : bool = True ) -> AgentConfig Try to load the agent configuration file.. set _ from _ configuration def set_from_configuration ( agent_configuration : AgentConfig , aea_project_path : Path , skip_consistency_check : bool = False ) -> None Set builder variables from AgentConfig. Arguments : agent_configuration : AgentConfig to get values from. aea_project_path : PathLike root directory of the agent project. skip_consistency_check : if True, the consistency check are skipped. from _ aea _ project @classmethod def from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False , apply_environment_variables : bool = False , password : Optional [ str ] = None ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. apply_environment_variables : if True, environment variables are loaded. password : the password to encrypt/decrypt private keys. Returns : an AEABuilder. get _ configuration _ file _ path @staticmethod def get_configuration_file_path ( aea_project_path : Union [ Path , str ]) -> Path Return path to aea-config file for the given aea project path. make _ component _ logger def make_component_logger ( configuration : ComponentConfiguration , agent_name : str ) -> Optional [ logging . Logger ] Make the logger for a component. Arguments : configuration : the component configuration agent_name : the agent name Returns : the logger.","title":"AEA Builder"},{"location":"api/aea_builder/#aeaaea_builder","text":"This module contains utilities for building an AEA.","title":"aea.aea_builder"},{"location":"api/aea_builder/#_dependenciesmanager-objects","text":"class _DependenciesManager () Class to manage dependencies of agent packages.","title":"_DependenciesManager Objects"},{"location":"api/aea_builder/#__init__","text":"def __init__ () -> None Initialize the dependency graph.","title":"__init__"},{"location":"api/aea_builder/#all_dependencies","text":"@property def all_dependencies () -> Set [ ComponentId ] Get all dependencies.","title":"all_dependencies"},{"location":"api/aea_builder/#dependencies_highest_version","text":"@property def dependencies_highest_version () -> Set [ ComponentId ] Get the dependencies with highest version.","title":"dependencies_highest_version"},{"location":"api/aea_builder/#get_components_by_type","text":"def get_components_by_type ( component_type : ComponentType ) -> Dict [ ComponentId , ComponentConfiguration ] Get the components by type.","title":"get_components_by_type"},{"location":"api/aea_builder/#protocols","text":"@property def protocols () -> Dict [ ComponentId , ProtocolConfig ] Get the protocols.","title":"protocols"},{"location":"api/aea_builder/#connections","text":"@property def connections () -> Dict [ ComponentId , ConnectionConfig ] Get the connections.","title":"connections"},{"location":"api/aea_builder/#skills","text":"@property def skills () -> Dict [ ComponentId , SkillConfig ] Get the skills.","title":"skills"},{"location":"api/aea_builder/#contracts","text":"@property def contracts () -> Dict [ ComponentId , ContractConfig ] Get the contracts.","title":"contracts"},{"location":"api/aea_builder/#add_component","text":"def add_component ( configuration : ComponentConfiguration ) -> None Add a component to the dependency manager. Arguments : configuration : the component configuration to add.","title":"add_component"},{"location":"api/aea_builder/#remove_component","text":"def remove_component ( component_id : ComponentId ) -> None Remove a component. Arguments : component_id : the component id Raises : ValueError : if some component depends on this package.","title":"remove_component"},{"location":"api/aea_builder/#pypi_dependencies","text":"@property def pypi_dependencies () -> Dependencies Get all the PyPI dependencies. We currently consider only dependency that have the default PyPI index url and that specify only the version field. Returns : the merged PyPI dependencies","title":"pypi_dependencies"},{"location":"api/aea_builder/#install_dependencies","text":"def install_dependencies () -> None Install extra dependencies for components.","title":"install_dependencies"},{"location":"api/aea_builder/#aeabuilder-objects","text":"class AEABuilder ( WithLogger ) This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself. Note: the method 'build()' is guaranteed of being re-entrant with respect to the 'add_component(path)' method. That is, you can invoke the building method many times against the same builder instance, and the returned agent instance will not share the components with other agents, e.g.: builder = AEABuilder() builder.add_component(...) ...","title":"AEABuilder Objects"},{"location":"api/aea_builder/#first-call","text":"my_aea_1 = builder.build()","title":"first call"},{"location":"api/aea_builder/#following-agents-will-have-different-components","text":"my_aea_2 = builder.build() # all good However, if you manually loaded some of the components and added them with the method 'add_component_instance()', then calling build more than one time is prevented: builder = AEABuilder() builder.add_component_instance(...) ... # other initialization code","title":"following agents will have different components."},{"location":"api/aea_builder/#first-call_1","text":"my_aea_1 = builder.build()","title":"first call"},{"location":"api/aea_builder/#second-call-to-build-would-raise-a-value-error","text":"","title":"second call to build() would raise a Value Error."},{"location":"api/aea_builder/#call-reset","text":"builder.reset()","title":"call reset"},{"location":"api/aea_builder/#re-add-the-component-and-private-keys","text":"builder.add_component_instance(...) ... # add private keys","title":"re-add the component and private keys"},{"location":"api/aea_builder/#second-call","text":"my_aea_2 = builder.builder()","title":"second call"},{"location":"api/aea_builder/#__init___1","text":"def __init__ ( with_default_packages : bool = True , registry_dir : str = DEFAULT_REGISTRY_NAME , build_dir_root : Optional [ str ] = None ) -> None Initialize the builder. Arguments : with_default_packages : add the default packages. registry_dir : the registry directory. build_dir_root : the root of the build directory.","title":"__init__"},{"location":"api/aea_builder/#reset","text":"def reset ( is_full_reset : bool = False ) -> None Reset the builder. A full reset causes a reset of all data on the builder. A partial reset only resets: - name, - private keys, and - component instances Arguments : is_full_reset : whether it is a full reset or not.","title":"reset"},{"location":"api/aea_builder/#set_period","text":"def set_period ( period : Optional [ float ]) -> \"AEABuilder\" Set agent act period. Arguments : period : period in seconds Returns : self","title":"set_period"},{"location":"api/aea_builder/#set_execution_timeout","text":"def set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self","title":"set_execution_timeout"},{"location":"api/aea_builder/#set_max_reactions","text":"def set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self","title":"set_max_reactions"},{"location":"api/aea_builder/#set_decision_maker_handler_details","text":"def set_decision_maker_handler_details ( decision_maker_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler config : the configuration passed to the decision maker handler on instantiation Returns : self","title":"set_decision_maker_handler_details"},{"location":"api/aea_builder/#set_error_handler_details","text":"def set_error_handler_details ( error_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : error_handler_dotted_path : the dotted path to the error handler file_path : the file path to the file which contains the error handler config : the configuration passed to the error handler on instantiation Returns : self","title":"set_error_handler_details"},{"location":"api/aea_builder/#set_skill_exception_policy","text":"def set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self","title":"set_skill_exception_policy"},{"location":"api/aea_builder/#set_connection_exception_policy","text":"def set_connection_exception_policy ( connection_exception_policy : Optional [ ExceptionPolicyEnum ] ) -> \"AEABuilder\" Set connection exception policy. Arguments : connection_exception_policy : the policy Returns : self","title":"set_connection_exception_policy"},{"location":"api/aea_builder/#set_default_routing","text":"def set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self","title":"set_default_routing"},{"location":"api/aea_builder/#set_loop_mode","text":"def set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self","title":"set_loop_mode"},{"location":"api/aea_builder/#set_runtime_mode","text":"def set_runtime_mode ( runtime_mode : Optional [ str ]) -> \"AEABuilder\" Set the runtime mode. Arguments : runtime_mode : the agent runtime mode Returns : self","title":"set_runtime_mode"},{"location":"api/aea_builder/#set_task_manager_mode","text":"def set_task_manager_mode ( task_manager_mode : Optional [ str ]) -> \"AEABuilder\" Set the task_manager_mode. Arguments : task_manager_mode : the agent task_manager_mode Returns : self","title":"set_task_manager_mode"},{"location":"api/aea_builder/#set_storage_uri","text":"def set_storage_uri ( storage_uri : Optional [ str ]) -> \"AEABuilder\" Set the storage uri. Arguments : storage_uri : storage uri Returns : self","title":"set_storage_uri"},{"location":"api/aea_builder/#set_data_dir","text":"def set_data_dir ( data_dir : Optional [ str ]) -> \"AEABuilder\" Set the data directory. Arguments : data_dir : path to directory where to store data. Returns : self","title":"set_data_dir"},{"location":"api/aea_builder/#set_logging_config","text":"def set_logging_config ( logging_config : Dict ) -> \"AEABuilder\" Set the logging configurations. The dictionary must satisfy the following schema: https://docs.python.org/3/library/logging.config.html#logging-config-dictschema Arguments : logging_config : the logging configurations. Returns : self","title":"set_logging_config"},{"location":"api/aea_builder/#set_search_service_address","text":"def set_search_service_address ( search_service_address : str ) -> \"AEABuilder\" Set the search service address. Arguments : search_service_address : the search service address Returns : self","title":"set_search_service_address"},{"location":"api/aea_builder/#set_name","text":"def set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder","title":"set_name"},{"location":"api/aea_builder/#set_default_connection","text":"def set_default_connection ( public_id : Optional [ PublicId ] = None ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder","title":"set_default_connection"},{"location":"api/aea_builder/#add_private_key","text":"def add_private_key ( identifier : str , private_key_path : Optional [ PathLike ] = None , is_connection : bool = False ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : an (optional) path to the private key file. If None, the key will be created at build time. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder","title":"add_private_key"},{"location":"api/aea_builder/#remove_private_key","text":"def remove_private_key ( identifier : str , is_connection : bool = False ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder","title":"remove_private_key"},{"location":"api/aea_builder/#private_key_paths","text":"@property def private_key_paths () -> Dict [ str , Optional [ str ]] Get the private key paths.","title":"private_key_paths"},{"location":"api/aea_builder/#connection_private_key_paths","text":"@property def connection_private_key_paths () -> Dict [ str , Optional [ str ]] Get the connection private key paths.","title":"connection_private_key_paths"},{"location":"api/aea_builder/#set_default_ledger","text":"def set_default_ledger ( identifier : Optional [ str ]) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder","title":"set_default_ledger"},{"location":"api/aea_builder/#set_required_ledgers","text":"def set_required_ledgers ( required_ledgers : Optional [ List [ str ]]) -> \"AEABuilder\" Set the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Arguments : required_ledgers : the required ledgers. Returns : the AEABuilder.","title":"set_required_ledgers"},{"location":"api/aea_builder/#set_build_entrypoint","text":"def set_build_entrypoint ( build_entrypoint : Optional [ str ]) -> \"AEABuilder\" Set build entrypoint. Arguments : build_entrypoint : path to the builder script. Returns : the AEABuilder","title":"set_build_entrypoint"},{"location":"api/aea_builder/#set_currency_denominations","text":"def set_currency_denominations ( currency_denominations : Dict [ str , str ]) -> \"AEABuilder\" Set the mapping from ledger ids to currency denominations. Arguments : currency_denominations : the mapping Returns : the AEABuilder","title":"set_currency_denominations"},{"location":"api/aea_builder/#add_component_1","text":"def add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. # noqa: DAR402 | or if there's a missing dependency. # noqa: DAR402 Returns : the AEABuilder","title":"add_component"},{"location":"api/aea_builder/#add_component_instance","text":"def add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. Notice also that this will make the call to 'build()' non re-entrant. You will have to reset() the builder before calling build() again. Arguments : component : Component instance already initialized. Returns : self","title":"add_component_instance"},{"location":"api/aea_builder/#set_context_namespace","text":"def set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace.","title":"set_context_namespace"},{"location":"api/aea_builder/#set_agent_pypi_dependencies","text":"def set_agent_pypi_dependencies ( dependencies : Dependencies ) -> \"AEABuilder\" Set agent PyPI dependencies. Arguments : dependencies : PyPI dependencies for the agent. Returns : the AEABuilder.","title":"set_agent_pypi_dependencies"},{"location":"api/aea_builder/#remove_component_1","text":"def remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder","title":"remove_component"},{"location":"api/aea_builder/#add_protocol","text":"def add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder","title":"add_protocol"},{"location":"api/aea_builder/#remove_protocol","text":"def remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder","title":"remove_protocol"},{"location":"api/aea_builder/#add_connection","text":"def add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder","title":"add_connection"},{"location":"api/aea_builder/#remove_connection","text":"def remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder","title":"remove_connection"},{"location":"api/aea_builder/#add_skill","text":"def add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder","title":"add_skill"},{"location":"api/aea_builder/#remove_skill","text":"def remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder","title":"remove_skill"},{"location":"api/aea_builder/#add_contract","text":"def add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder","title":"add_contract"},{"location":"api/aea_builder/#remove_contract","text":"def remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder","title":"remove_contract"},{"location":"api/aea_builder/#call_all_build_entrypoints","text":"def call_all_build_entrypoints () -> None Call all the build entrypoints.","title":"call_all_build_entrypoints"},{"location":"api/aea_builder/#get_build_root_directory","text":"def get_build_root_directory () -> str Get build directory root.","title":"get_build_root_directory"},{"location":"api/aea_builder/#run_build_for_component_configuration","text":"@classmethod def run_build_for_component_configuration ( cls , config : ComponentConfiguration , logger : Optional [ logging . Logger ] = None ) -> None Run a build entrypoint script for component configuration.","title":"run_build_for_component_configuration"},{"location":"api/aea_builder/#install_pypi_dependencies","text":"def install_pypi_dependencies () -> None Install components extra dependencies.","title":"install_pypi_dependencies"},{"location":"api/aea_builder/#build","text":"def build ( connection_ids : Optional [ Collection [ PublicId ]] = None , password : Optional [ str ] = None ) -> AEA Build the AEA. This method is re-entrant only if the components have been added through the method 'add_component'. If some of them have been loaded with 'add_component_instance', it can be called only once, and further calls are only possible after a call to 'reset' and re-loading of the components added via 'add_component_instance' and the private keys. Arguments : connection_ids : select only these connections to run the AEA. password : the password to encrypt/decrypt the private key. Returns : the AEA object.","title":"build"},{"location":"api/aea_builder/#get_default_ledger","text":"def get_default_ledger () -> str Return default ledger. Returns : the default ledger identifier.","title":"get_default_ledger"},{"location":"api/aea_builder/#get_required_ledgers","text":"def get_required_ledgers () -> List [ str ] Get the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Returns : the list of required ledgers.","title":"get_required_ledgers"},{"location":"api/aea_builder/#try_to_load_agent_configuration_file","text":"@classmethod def try_to_load_agent_configuration_file ( cls , aea_project_path : Union [ str , Path ], apply_environment_variables : bool = True ) -> AgentConfig Try to load the agent configuration file..","title":"try_to_load_agent_configuration_file"},{"location":"api/aea_builder/#set_from_configuration","text":"def set_from_configuration ( agent_configuration : AgentConfig , aea_project_path : Path , skip_consistency_check : bool = False ) -> None Set builder variables from AgentConfig. Arguments : agent_configuration : AgentConfig to get values from. aea_project_path : PathLike root directory of the agent project. skip_consistency_check : if True, the consistency check are skipped.","title":"set_from_configuration"},{"location":"api/aea_builder/#from_aea_project","text":"@classmethod def from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False , apply_environment_variables : bool = False , password : Optional [ str ] = None ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. apply_environment_variables : if True, environment variables are loaded. password : the password to encrypt/decrypt private keys. Returns : an AEABuilder.","title":"from_aea_project"},{"location":"api/aea_builder/#get_configuration_file_path","text":"@staticmethod def get_configuration_file_path ( aea_project_path : Union [ Path , str ]) -> Path Return path to aea-config file for the given aea project path.","title":"get_configuration_file_path"},{"location":"api/aea_builder/#make_component_logger","text":"def make_component_logger ( configuration : ComponentConfiguration , agent_name : str ) -> Optional [ logging . Logger ] Make the logger for a component. Arguments : configuration : the component configuration agent_name : the agent name Returns : the logger.","title":"make_component_logger"},{"location":"api/agent/","text":"aea.agent This module contains the implementation of a generic agent. Agent Objects class Agent ( AbstractAgent , WithLogger ) This class provides an abstract base class for a generic agent. __ init __ def __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , period : float = 1.0 , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , logger : Logger = _default_logger , task_manager_mode : Optional [ str ] = None ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. period : period to call agent's act loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode to up agent. storage_uri : optional uri to set generic storage task_manager_mode : task manager mode. logger : the logger. task_manager_mode : mode of the task manager. storage _ uri @property def storage_uri () -> Optional [ str ] Return storage uri. is _ running @property def is_running () -> bool Get running state of the runtime and agent. is _ stopped @property def is_stopped () -> bool Get running state of the runtime and agent. identity @property def identity () -> Identity Get the identity. inbox @property def inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing. Returns : InBox instance outbox @property def outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer. Returns : OutBox instance name @property def name () -> str Get the agent name. tick @property def tick () -> int Get the tick or agent loop count. Each agent loop (one call to each one of act(), react(), update()) increments the tick. Returns : tick count state @property def state () -> RuntimeStates Get state of the agent's runtime. Returns : RuntimeStates period @property def period () -> float Get a period to call act. runtime @property def runtime () -> BaseRuntime Get the runtime. setup def setup () -> None Set up the agent. start def start () -> None Start the agent. Performs the following: calls start() on runtime. waits for runtime to complete running (blocking) handle _ envelope def handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. act def act () -> None Perform actions on period. stop def stop () -> None Stop the agent. Performs the following: calls stop() on runtime waits for runtime to stop (blocking) teardown def teardown () -> None Tear down the agent. get _ periodic _ tasks def get_periodic_tasks ( ) -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers def get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message exception _ handler def exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"Agent"},{"location":"api/agent/#aeaagent","text":"This module contains the implementation of a generic agent.","title":"aea.agent"},{"location":"api/agent/#agent-objects","text":"class Agent ( AbstractAgent , WithLogger ) This class provides an abstract base class for a generic agent.","title":"Agent Objects"},{"location":"api/agent/#__init__","text":"def __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , period : float = 1.0 , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , logger : Logger = _default_logger , task_manager_mode : Optional [ str ] = None ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. period : period to call agent's act loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode to up agent. storage_uri : optional uri to set generic storage task_manager_mode : task manager mode. logger : the logger. task_manager_mode : mode of the task manager.","title":"__init__"},{"location":"api/agent/#storage_uri","text":"@property def storage_uri () -> Optional [ str ] Return storage uri.","title":"storage_uri"},{"location":"api/agent/#is_running","text":"@property def is_running () -> bool Get running state of the runtime and agent.","title":"is_running"},{"location":"api/agent/#is_stopped","text":"@property def is_stopped () -> bool Get running state of the runtime and agent.","title":"is_stopped"},{"location":"api/agent/#identity","text":"@property def identity () -> Identity Get the identity.","title":"identity"},{"location":"api/agent/#inbox","text":"@property def inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing. Returns : InBox instance","title":"inbox"},{"location":"api/agent/#outbox","text":"@property def outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer. Returns : OutBox instance","title":"outbox"},{"location":"api/agent/#name","text":"@property def name () -> str Get the agent name.","title":"name"},{"location":"api/agent/#tick","text":"@property def tick () -> int Get the tick or agent loop count. Each agent loop (one call to each one of act(), react(), update()) increments the tick. Returns : tick count","title":"tick"},{"location":"api/agent/#state","text":"@property def state () -> RuntimeStates Get state of the agent's runtime. Returns : RuntimeStates","title":"state"},{"location":"api/agent/#period","text":"@property def period () -> float Get a period to call act.","title":"period"},{"location":"api/agent/#runtime","text":"@property def runtime () -> BaseRuntime Get the runtime.","title":"runtime"},{"location":"api/agent/#setup","text":"def setup () -> None Set up the agent.","title":"setup"},{"location":"api/agent/#start","text":"def start () -> None Start the agent. Performs the following: calls start() on runtime. waits for runtime to complete running (blocking)","title":"start"},{"location":"api/agent/#handle_envelope","text":"def handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle.","title":"handle_envelope"},{"location":"api/agent/#act","text":"def act () -> None Perform actions on period.","title":"act"},{"location":"api/agent/#stop","text":"def stop () -> None Stop the agent. Performs the following: calls stop() on runtime waits for runtime to stop (blocking)","title":"stop"},{"location":"api/agent/#teardown","text":"def teardown () -> None Tear down the agent.","title":"teardown"},{"location":"api/agent/#get_periodic_tasks","text":"def get_periodic_tasks ( ) -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"api/agent/#get_message_handlers","text":"def get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"api/agent/#exception_handler","text":"def exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"exception_handler"},{"location":"api/agent_loop/","text":"aea.agent _ loop This module contains the implementation of an agent loop using asyncio. AgentLoopException Objects class AgentLoopException ( AEAException ) Exception for agent loop runtime errors. AgentLoopStates Objects class AgentLoopStates ( Enum ) Internal agent loop states. BaseAgentLoop Objects class BaseAgentLoop ( Runnable , WithLogger , ABC ) Base abstract agent loop class. __ init __ def __init__ ( agent : AbstractAgent , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False ) -> None Init loop. Arguments : agent : Agent or AEA to run. loop : optional asyncio event loop. if not specified a new loop will be created. threaded : if True, run in threaded mode, else async agent @property def agent () -> AbstractAgent Get agent. state @property def state () -> AgentLoopStates Get current main loop state. wait _ state async def wait_state ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state. is _ running @property def is_running () -> bool Get running state of the loop. set _ loop def set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. run async def run () -> None Run agent loop. send _ to _ skill @abstractmethod def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context skill2skill _ queue @property @abstractmethod def skill2skill_queue () -> Queue Get skill to skill message queue. AsyncAgentLoop Objects class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA. __ init __ def __init__ ( agent : AbstractAgent , loop : AbstractEventLoop = None , threaded : bool = False ) -> None Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional threaded : is a new thread to be started for the agent loop skill2skill _ queue @property def skill2skill_queue () -> Queue Get skill to skill message queue. send _ to _ skill def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context","title":"Agent Loop"},{"location":"api/agent_loop/#aeaagent_loop","text":"This module contains the implementation of an agent loop using asyncio.","title":"aea.agent_loop"},{"location":"api/agent_loop/#agentloopexception-objects","text":"class AgentLoopException ( AEAException ) Exception for agent loop runtime errors.","title":"AgentLoopException Objects"},{"location":"api/agent_loop/#agentloopstates-objects","text":"class AgentLoopStates ( Enum ) Internal agent loop states.","title":"AgentLoopStates Objects"},{"location":"api/agent_loop/#baseagentloop-objects","text":"class BaseAgentLoop ( Runnable , WithLogger , ABC ) Base abstract agent loop class.","title":"BaseAgentLoop Objects"},{"location":"api/agent_loop/#__init__","text":"def __init__ ( agent : AbstractAgent , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False ) -> None Init loop. Arguments : agent : Agent or AEA to run. loop : optional asyncio event loop. if not specified a new loop will be created. threaded : if True, run in threaded mode, else async","title":"__init__"},{"location":"api/agent_loop/#agent","text":"@property def agent () -> AbstractAgent Get agent.","title":"agent"},{"location":"api/agent_loop/#state","text":"@property def state () -> AgentLoopStates Get current main loop state.","title":"state"},{"location":"api/agent_loop/#wait_state","text":"async def wait_state ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state.","title":"wait_state"},{"location":"api/agent_loop/#is_running","text":"@property def is_running () -> bool Get running state of the loop.","title":"is_running"},{"location":"api/agent_loop/#set_loop","text":"def set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects.","title":"set_loop"},{"location":"api/agent_loop/#run","text":"async def run () -> None Run agent loop.","title":"run"},{"location":"api/agent_loop/#send_to_skill","text":"@abstractmethod def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context","title":"send_to_skill"},{"location":"api/agent_loop/#skill2skill_queue","text":"@property @abstractmethod def skill2skill_queue () -> Queue Get skill to skill message queue.","title":"skill2skill_queue"},{"location":"api/agent_loop/#asyncagentloop-objects","text":"class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA.","title":"AsyncAgentLoop Objects"},{"location":"api/agent_loop/#__init___1","text":"def __init__ ( agent : AbstractAgent , loop : AbstractEventLoop = None , threaded : bool = False ) -> None Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional threaded : is a new thread to be started for the agent loop","title":"__init__"},{"location":"api/agent_loop/#skill2skill_queue_1","text":"@property def skill2skill_queue () -> Queue Get skill to skill message queue.","title":"skill2skill_queue"},{"location":"api/agent_loop/#send_to_skill_1","text":"def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context","title":"send_to_skill"},{"location":"api/common/","text":"aea.common This module contains the common types and interfaces used in the aea framework.","title":"Common"},{"location":"api/common/#aeacommon","text":"This module contains the common types and interfaces used in the aea framework.","title":"aea.common"},{"location":"api/exceptions/","text":"aea.exceptions Exceptions for the AEA package. AEAException Objects class AEAException ( Exception ) User-defined exception for the AEA framework. AEAPackageLoadingError Objects class AEAPackageLoadingError ( AEAException ) Class for exceptions that are raised for loading errors of AEA packages. AEASetupError Objects class AEASetupError ( AEAException ) Class for exceptions that are raised for setup errors of AEA packages. AEATeardownError Objects class AEATeardownError ( AEAException ) Class for exceptions that are raised for teardown errors of AEA packages. AEAActException Objects class AEAActException ( AEAException ) Class for exceptions that are raised for act errors of AEA packages. AEAHandleException Objects class AEAHandleException ( AEAException ) Class for exceptions that are raised for handler errors of AEA packages. AEAInstantiationException Objects class AEAInstantiationException ( AEAException ) Class for exceptions that are raised for instantiation errors of AEA packages. AEAPluginError Objects class AEAPluginError ( AEAException ) Class for exceptions that are raised for wrong plugin setup of the working set. AEAEnforceError Objects class AEAEnforceError ( AEAException ) Class for enforcement errors. AEAValidationError Objects class AEAValidationError ( AEAException ) Class for validation errors of an AEA. AEAComponentLoadException Objects class AEAComponentLoadException ( AEAException ) Class for component loading errors of an AEA. AEAWalletNoAddressException Objects class AEAWalletNoAddressException ( AEAException ) Class for attempts to instantiate a wallet without addresses. _ StopRuntime Objects class _StopRuntime ( Exception ) Exception to stop runtime. For internal usage only! Used to perform asyncio call from sync callbacks. __ init __ def __init__ ( reraise : Optional [ Exception ] = None ) -> None Init _StopRuntime exception. Arguments : reraise : exception to reraise. enforce def enforce ( is_valid_condition : bool , exception_text : str , exception_class : Type [ Exception ] = AEAEnforceError ) -> None Evaluate a condition and raise an exception with the provided text if it is not satisfied. Arguments : is_valid_condition : the valid condition exception_text : the exception to be raised exception_class : the class of exception parse _ exception def parse_exception ( exception : Exception , limit : int = - 1 ) -> str Parse an exception to get the relevant lines. Arguments : exception : the exception to be parsed limit : the limit Returns : exception as string","title":"Exceptions"},{"location":"api/exceptions/#aeaexceptions","text":"Exceptions for the AEA package.","title":"aea.exceptions"},{"location":"api/exceptions/#aeaexception-objects","text":"class AEAException ( Exception ) User-defined exception for the AEA framework.","title":"AEAException Objects"},{"location":"api/exceptions/#aeapackageloadingerror-objects","text":"class AEAPackageLoadingError ( AEAException ) Class for exceptions that are raised for loading errors of AEA packages.","title":"AEAPackageLoadingError Objects"},{"location":"api/exceptions/#aeasetuperror-objects","text":"class AEASetupError ( AEAException ) Class for exceptions that are raised for setup errors of AEA packages.","title":"AEASetupError Objects"},{"location":"api/exceptions/#aeateardownerror-objects","text":"class AEATeardownError ( AEAException ) Class for exceptions that are raised for teardown errors of AEA packages.","title":"AEATeardownError Objects"},{"location":"api/exceptions/#aeaactexception-objects","text":"class AEAActException ( AEAException ) Class for exceptions that are raised for act errors of AEA packages.","title":"AEAActException Objects"},{"location":"api/exceptions/#aeahandleexception-objects","text":"class AEAHandleException ( AEAException ) Class for exceptions that are raised for handler errors of AEA packages.","title":"AEAHandleException Objects"},{"location":"api/exceptions/#aeainstantiationexception-objects","text":"class AEAInstantiationException ( AEAException ) Class for exceptions that are raised for instantiation errors of AEA packages.","title":"AEAInstantiationException Objects"},{"location":"api/exceptions/#aeapluginerror-objects","text":"class AEAPluginError ( AEAException ) Class for exceptions that are raised for wrong plugin setup of the working set.","title":"AEAPluginError Objects"},{"location":"api/exceptions/#aeaenforceerror-objects","text":"class AEAEnforceError ( AEAException ) Class for enforcement errors.","title":"AEAEnforceError Objects"},{"location":"api/exceptions/#aeavalidationerror-objects","text":"class AEAValidationError ( AEAException ) Class for validation errors of an AEA.","title":"AEAValidationError Objects"},{"location":"api/exceptions/#aeacomponentloadexception-objects","text":"class AEAComponentLoadException ( AEAException ) Class for component loading errors of an AEA.","title":"AEAComponentLoadException Objects"},{"location":"api/exceptions/#aeawalletnoaddressexception-objects","text":"class AEAWalletNoAddressException ( AEAException ) Class for attempts to instantiate a wallet without addresses.","title":"AEAWalletNoAddressException Objects"},{"location":"api/exceptions/#_stopruntime-objects","text":"class _StopRuntime ( Exception ) Exception to stop runtime. For internal usage only! Used to perform asyncio call from sync callbacks.","title":"_StopRuntime Objects"},{"location":"api/exceptions/#__init__","text":"def __init__ ( reraise : Optional [ Exception ] = None ) -> None Init _StopRuntime exception. Arguments : reraise : exception to reraise.","title":"__init__"},{"location":"api/exceptions/#enforce","text":"def enforce ( is_valid_condition : bool , exception_text : str , exception_class : Type [ Exception ] = AEAEnforceError ) -> None Evaluate a condition and raise an exception with the provided text if it is not satisfied. Arguments : is_valid_condition : the valid condition exception_text : the exception to be raised exception_class : the class of exception","title":"enforce"},{"location":"api/exceptions/#parse_exception","text":"def parse_exception ( exception : Exception , limit : int = - 1 ) -> str Parse an exception to get the relevant lines. Arguments : exception : the exception to be parsed limit : the limit Returns : exception as string","title":"parse_exception"},{"location":"api/launcher/","text":"aea.launcher This module contains the implementation of multiple AEA configs launcher. load _ agent def load_agent ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> AEA Load AEA from directory. Arguments : agent_dir : agent configuration directory password : the password to encrypt/decrypt the private key. Returns : AEA instance AEADirTask Objects class AEADirTask ( AbstractExecutorTask ) Task to run agent from agent configuration directory. __ init __ def __init__ ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. password : the password to encrypt/decrypt the private key. id @property def id () -> Union [ PathLike , str ] Return agent_dir. start def start () -> None Start task. stop def stop () -> None Stop task. create _ async _ task def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. AEADirMultiprocessTask Objects class AEADirMultiprocessTask ( AbstractMultiprocessExecutorTask ) Task to run agent from agent configuration directory. Version for multiprocess executor mode. __ init __ def __init__ ( agent_dir : Union [ PathLike , str ], log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. log_level : debug level applied for AEA in subprocess password : the password to encrypt/decrypt the private key. id @property def id () -> Union [ PathLike , str ] Return agent_dir. failed @property def failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool start def start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess. stop def stop () -> None Stop task. AEALauncher Objects class AEALauncher ( AbstractMultipleRunner ) Run multiple AEA instances. __ init __ def __init__ ( agent_dirs : Sequence [ Union [ PathLike , str ]], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate , log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init AEALauncher. Arguments : agent_dirs : sequence of AEA config directories. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor log_level : debug level applied for AEA in subprocesses password : the password to encrypt/decrypt the private key.","title":"Launcher"},{"location":"api/launcher/#aealauncher","text":"This module contains the implementation of multiple AEA configs launcher.","title":"aea.launcher"},{"location":"api/launcher/#load_agent","text":"def load_agent ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> AEA Load AEA from directory. Arguments : agent_dir : agent configuration directory password : the password to encrypt/decrypt the private key. Returns : AEA instance","title":"load_agent"},{"location":"api/launcher/#aeadirtask-objects","text":"class AEADirTask ( AbstractExecutorTask ) Task to run agent from agent configuration directory.","title":"AEADirTask Objects"},{"location":"api/launcher/#__init__","text":"def __init__ ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"api/launcher/#id","text":"@property def id () -> Union [ PathLike , str ] Return agent_dir.","title":"id"},{"location":"api/launcher/#start","text":"def start () -> None Start task.","title":"start"},{"location":"api/launcher/#stop","text":"def stop () -> None Stop task.","title":"stop"},{"location":"api/launcher/#create_async_task","text":"def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop.","title":"create_async_task"},{"location":"api/launcher/#aeadirmultiprocesstask-objects","text":"class AEADirMultiprocessTask ( AbstractMultiprocessExecutorTask ) Task to run agent from agent configuration directory. Version for multiprocess executor mode.","title":"AEADirMultiprocessTask Objects"},{"location":"api/launcher/#__init___1","text":"def __init__ ( agent_dir : Union [ PathLike , str ], log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. log_level : debug level applied for AEA in subprocess password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"api/launcher/#id_1","text":"@property def id () -> Union [ PathLike , str ] Return agent_dir.","title":"id"},{"location":"api/launcher/#failed","text":"@property def failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool","title":"failed"},{"location":"api/launcher/#start_1","text":"def start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess.","title":"start"},{"location":"api/launcher/#stop_1","text":"def stop () -> None Stop task.","title":"stop"},{"location":"api/launcher/#aealauncher-objects","text":"class AEALauncher ( AbstractMultipleRunner ) Run multiple AEA instances.","title":"AEALauncher Objects"},{"location":"api/launcher/#__init___2","text":"def __init__ ( agent_dirs : Sequence [ Union [ PathLike , str ]], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate , log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init AEALauncher. Arguments : agent_dirs : sequence of AEA config directories. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor log_level : debug level applied for AEA in subprocesses password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"api/multiplexer/","text":"aea.multiplexer Module for the multiplexer class and related classes. MultiplexerStatus Objects class MultiplexerStatus ( AsyncState ) The connection status class. __ init __ def __init__ () -> None Initialize the connection status. is _ connected @property def is_connected () -> bool Return is connected. is _ connecting @property def is_connecting () -> bool Return is connecting. is _ disconnected @property def is_disconnected () -> bool Return is disconnected. is _ disconnecting @property def is_disconnecting () -> bool Return is disconnected. AsyncMultiplexer Objects class AsyncMultiplexer ( Runnable , WithLogger ) This class can handle multiple connections at once. __ init __ def __init__ ( connections : Optional [ Sequence [ Connection ]] = None , default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None , exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , threaded : bool = False , agent_name : str = \"standalone\" , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , default_connection : Optional [ PublicId ] = None , protocols : Optional [ List [ Union [ Protocol , Message ]]] = None ) -> None Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. This information is used for envelopes which don't specify any routing context. If connections is None, this parameter is ignored. loop : the event loop to run the multiplexer. If None, a new event loop is created. exception_policy : the exception policy used for connections. threaded : if True, run in threaded mode, else async agent_name : the name of the agent that owns the multiplexer, for logging purposes. default_routing : default routing map default_connection : default connection protocols : protocols used default _ connection @property def default_connection () -> Optional [ Connection ] Get the default connection. in _ queue @property def in_queue () -> AsyncFriendlyQueue Get the in queue. out _ queue @property def out_queue () -> asyncio . Queue Get the out queue. connections @property def connections () -> Tuple [ Connection , ... ] Get the connections. is _ connected @property def is_connected () -> bool Check whether the multiplexer is processing envelopes. default _ routing @property def default_routing () -> Dict [ PublicId , PublicId ] Get the default routing. default _ routing @default_routing . setter def default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> None Set the default routing. connection _ status @property def connection_status () -> MultiplexerStatus Get the connection status. run async def run () -> None Run multiplexer connect and receive/send tasks. set _ loop def set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop. add _ connection def add_connection ( connection : Connection , is_default : bool = False ) -> None Add a connection to the multiplexer. Arguments : connection : the connection to add. is_default : whether the connection added should be the default one. connect async def connect () -> None Connect the multiplexer. disconnect async def disconnect () -> None Disconnect the multiplexer. get def get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout. async _ get async def async_get () -> Envelope Get an envelope async way. Returns : the envelope async _ wait async def async_wait () -> None Get an envelope async way. Returns : the envelope put def put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Multiplexer Objects class Multiplexer ( AsyncMultiplexer ) Transit sync multiplexer for compatibility. __ init __ def __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the connection multiplexer. Arguments : args : arguments kwargs : keyword arguments set _ loop def set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop. connect def connect () -> None Connect the multiplexer. Synchronously in thread spawned if new loop created. disconnect def disconnect () -> None Disconnect the multiplexer. Also stops a dedicated thread for event loop if spawned on connect. put def put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. InBox Objects class InBox () A queue from where you can only consume envelopes. __ init __ def __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the inbox. Arguments : multiplexer : the multiplexer empty def empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not get def get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Raises : Empty : if the attempt to get an envelope fails. Returns : the envelope object. get _ nowait def get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object async _ get async def async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object. async _ wait async def async_wait () -> None Check for a envelope on the in queue. OutBox Objects class OutBox () A queue from where you can only enqueue envelopes. __ init __ def __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the outbox. Arguments : multiplexer : the multiplexer empty def empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not put def put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. put _ message def put_message ( message : Message , context : Optional [ EnvelopeContext ] = None ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : message : the message context : the envelope context","title":"Multiplexer"},{"location":"api/multiplexer/#aeamultiplexer","text":"Module for the multiplexer class and related classes.","title":"aea.multiplexer"},{"location":"api/multiplexer/#multiplexerstatus-objects","text":"class MultiplexerStatus ( AsyncState ) The connection status class.","title":"MultiplexerStatus Objects"},{"location":"api/multiplexer/#__init__","text":"def __init__ () -> None Initialize the connection status.","title":"__init__"},{"location":"api/multiplexer/#is_connected","text":"@property def is_connected () -> bool Return is connected.","title":"is_connected"},{"location":"api/multiplexer/#is_connecting","text":"@property def is_connecting () -> bool Return is connecting.","title":"is_connecting"},{"location":"api/multiplexer/#is_disconnected","text":"@property def is_disconnected () -> bool Return is disconnected.","title":"is_disconnected"},{"location":"api/multiplexer/#is_disconnecting","text":"@property def is_disconnecting () -> bool Return is disconnected.","title":"is_disconnecting"},{"location":"api/multiplexer/#asyncmultiplexer-objects","text":"class AsyncMultiplexer ( Runnable , WithLogger ) This class can handle multiple connections at once.","title":"AsyncMultiplexer Objects"},{"location":"api/multiplexer/#__init___1","text":"def __init__ ( connections : Optional [ Sequence [ Connection ]] = None , default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None , exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , threaded : bool = False , agent_name : str = \"standalone\" , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , default_connection : Optional [ PublicId ] = None , protocols : Optional [ List [ Union [ Protocol , Message ]]] = None ) -> None Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. This information is used for envelopes which don't specify any routing context. If connections is None, this parameter is ignored. loop : the event loop to run the multiplexer. If None, a new event loop is created. exception_policy : the exception policy used for connections. threaded : if True, run in threaded mode, else async agent_name : the name of the agent that owns the multiplexer, for logging purposes. default_routing : default routing map default_connection : default connection protocols : protocols used","title":"__init__"},{"location":"api/multiplexer/#default_connection","text":"@property def default_connection () -> Optional [ Connection ] Get the default connection.","title":"default_connection"},{"location":"api/multiplexer/#in_queue","text":"@property def in_queue () -> AsyncFriendlyQueue Get the in queue.","title":"in_queue"},{"location":"api/multiplexer/#out_queue","text":"@property def out_queue () -> asyncio . Queue Get the out queue.","title":"out_queue"},{"location":"api/multiplexer/#connections","text":"@property def connections () -> Tuple [ Connection , ... ] Get the connections.","title":"connections"},{"location":"api/multiplexer/#is_connected_1","text":"@property def is_connected () -> bool Check whether the multiplexer is processing envelopes.","title":"is_connected"},{"location":"api/multiplexer/#default_routing","text":"@property def default_routing () -> Dict [ PublicId , PublicId ] Get the default routing.","title":"default_routing"},{"location":"api/multiplexer/#default_routing_1","text":"@default_routing . setter def default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> None Set the default routing.","title":"default_routing"},{"location":"api/multiplexer/#connection_status","text":"@property def connection_status () -> MultiplexerStatus Get the connection status.","title":"connection_status"},{"location":"api/multiplexer/#run","text":"async def run () -> None Run multiplexer connect and receive/send tasks.","title":"run"},{"location":"api/multiplexer/#set_loop","text":"def set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop.","title":"set_loop"},{"location":"api/multiplexer/#add_connection","text":"def add_connection ( connection : Connection , is_default : bool = False ) -> None Add a connection to the multiplexer. Arguments : connection : the connection to add. is_default : whether the connection added should be the default one.","title":"add_connection"},{"location":"api/multiplexer/#connect","text":"async def connect () -> None Connect the multiplexer.","title":"connect"},{"location":"api/multiplexer/#disconnect","text":"async def disconnect () -> None Disconnect the multiplexer.","title":"disconnect"},{"location":"api/multiplexer/#get","text":"def get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout.","title":"get"},{"location":"api/multiplexer/#async_get","text":"async def async_get () -> Envelope Get an envelope async way. Returns : the envelope","title":"async_get"},{"location":"api/multiplexer/#async_wait","text":"async def async_wait () -> None Get an envelope async way. Returns : the envelope","title":"async_wait"},{"location":"api/multiplexer/#put","text":"def put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent.","title":"put"},{"location":"api/multiplexer/#multiplexer-objects","text":"class Multiplexer ( AsyncMultiplexer ) Transit sync multiplexer for compatibility.","title":"Multiplexer Objects"},{"location":"api/multiplexer/#__init___2","text":"def __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the connection multiplexer. Arguments : args : arguments kwargs : keyword arguments","title":"__init__"},{"location":"api/multiplexer/#set_loop_1","text":"def set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop.","title":"set_loop"},{"location":"api/multiplexer/#connect_1","text":"def connect () -> None Connect the multiplexer. Synchronously in thread spawned if new loop created.","title":"connect"},{"location":"api/multiplexer/#disconnect_1","text":"def disconnect () -> None Disconnect the multiplexer. Also stops a dedicated thread for event loop if spawned on connect.","title":"disconnect"},{"location":"api/multiplexer/#put_1","text":"def put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent.","title":"put"},{"location":"api/multiplexer/#inbox-objects","text":"class InBox () A queue from where you can only consume envelopes.","title":"InBox Objects"},{"location":"api/multiplexer/#__init___3","text":"def __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the inbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"api/multiplexer/#empty","text":"def empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"api/multiplexer/#get_1","text":"def get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Raises : Empty : if the attempt to get an envelope fails. Returns : the envelope object.","title":"get"},{"location":"api/multiplexer/#get_nowait","text":"def get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object","title":"get_nowait"},{"location":"api/multiplexer/#async_get_1","text":"async def async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object.","title":"async_get"},{"location":"api/multiplexer/#async_wait_1","text":"async def async_wait () -> None Check for a envelope on the in queue.","title":"async_wait"},{"location":"api/multiplexer/#outbox-objects","text":"class OutBox () A queue from where you can only enqueue envelopes.","title":"OutBox Objects"},{"location":"api/multiplexer/#__init___4","text":"def __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the outbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"api/multiplexer/#empty_1","text":"def empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"api/multiplexer/#put_2","text":"def put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope.","title":"put"},{"location":"api/multiplexer/#put_message","text":"def put_message ( message : Message , context : Optional [ EnvelopeContext ] = None ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : message : the message context : the envelope context","title":"put_message"},{"location":"api/runner/","text":"aea.runner This module contains the implementation of AEA multiple instances runner. AEAInstanceTask Objects class AEAInstanceTask ( AbstractExecutorTask ) Task to run agent instance. __ init __ def __init__ ( agent : AEA ) -> None Init aea instance task. Arguments : agent : AEA instance to run within task. id @property def id () -> str Return agent name. start def start () -> None Start task. stop def stop () -> None Stop task. create _ async _ task def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. Arguments : loop : abstract event loop Returns : task to run runtime AEARunner Objects class AEARunner ( AbstractMultipleRunner ) Run multiple AEA instances. __ init __ def __init__ ( agents : Sequence [ AEA ], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init AEARunner. Arguments : agents : sequence of AEA instances to run. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"Runner"},{"location":"api/runner/#aearunner","text":"This module contains the implementation of AEA multiple instances runner.","title":"aea.runner"},{"location":"api/runner/#aeainstancetask-objects","text":"class AEAInstanceTask ( AbstractExecutorTask ) Task to run agent instance.","title":"AEAInstanceTask Objects"},{"location":"api/runner/#__init__","text":"def __init__ ( agent : AEA ) -> None Init aea instance task. Arguments : agent : AEA instance to run within task.","title":"__init__"},{"location":"api/runner/#id","text":"@property def id () -> str Return agent name.","title":"id"},{"location":"api/runner/#start","text":"def start () -> None Start task.","title":"start"},{"location":"api/runner/#stop","text":"def stop () -> None Stop task.","title":"stop"},{"location":"api/runner/#create_async_task","text":"def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. Arguments : loop : abstract event loop Returns : task to run runtime","title":"create_async_task"},{"location":"api/runner/#aearunner-objects","text":"class AEARunner ( AbstractMultipleRunner ) Run multiple AEA instances.","title":"AEARunner Objects"},{"location":"api/runner/#__init___1","text":"def __init__ ( agents : Sequence [ AEA ], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init AEARunner. Arguments : agents : sequence of AEA instances to run. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"__init__"},{"location":"api/runtime/","text":"aea.runtime This module contains the implementation of runtime for economic agent (AEA). RuntimeStates Objects class RuntimeStates ( Enum ) Runtime states. BaseRuntime Objects class BaseRuntime ( Runnable , WithLogger ) Abstract runtime class to create implementations. __ init __ def __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager. storage @property def storage () -> Optional [ Storage ] Get optional storage. loop _ mode @property def loop_mode () -> str Get current loop mode. task _ manager @property def task_manager () -> TaskManager Get the task manager. loop @property def loop () -> Optional [ AbstractEventLoop ] Get event loop. agent _ loop @property def agent_loop () -> BaseAgentLoop Get the agent loop. multiplexer @property def multiplexer () -> AsyncMultiplexer Get multiplexer. is _ running @property def is_running () -> bool Get running state of the runtime. is _ stopped @property def is_stopped () -> bool Get stopped state of the runtime. state @property def state () -> RuntimeStates Get runtime state. Returns : RuntimeStates decision _ maker @property def decision_maker () -> DecisionMaker Return decision maker if set. set _ decision _ maker def set_decision_maker ( decision_maker_handler : DecisionMakerHandler ) -> None Set decision maker with handler provided. set _ loop def set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use. AsyncRuntime Objects class AsyncRuntime ( BaseRuntime ) Asynchronous runtime: uses asyncio loop for multiplexer and async agent main loop. __ init __ def __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager. set _ loop def set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use. run async def run () -> None Start runtime task. Starts multiplexer and agent loop. stop _ runtime async def stop_runtime () -> None Stop runtime coroutine. Stop main loop. Tear down the agent.. Disconnect multiplexer. run _ runtime async def run_runtime () -> None Run runtime which means start agent loop, multiplexer and storage. ThreadedRuntime Objects class ThreadedRuntime ( AsyncRuntime ) Run agent and multiplexer in different threads with own asyncio loops.","title":"Runtime"},{"location":"api/runtime/#aearuntime","text":"This module contains the implementation of runtime for economic agent (AEA).","title":"aea.runtime"},{"location":"api/runtime/#runtimestates-objects","text":"class RuntimeStates ( Enum ) Runtime states.","title":"RuntimeStates Objects"},{"location":"api/runtime/#baseruntime-objects","text":"class BaseRuntime ( Runnable , WithLogger ) Abstract runtime class to create implementations.","title":"BaseRuntime Objects"},{"location":"api/runtime/#__init__","text":"def __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager.","title":"__init__"},{"location":"api/runtime/#storage","text":"@property def storage () -> Optional [ Storage ] Get optional storage.","title":"storage"},{"location":"api/runtime/#loop_mode","text":"@property def loop_mode () -> str Get current loop mode.","title":"loop_mode"},{"location":"api/runtime/#task_manager","text":"@property def task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"api/runtime/#loop","text":"@property def loop () -> Optional [ AbstractEventLoop ] Get event loop.","title":"loop"},{"location":"api/runtime/#agent_loop","text":"@property def agent_loop () -> BaseAgentLoop Get the agent loop.","title":"agent_loop"},{"location":"api/runtime/#multiplexer","text":"@property def multiplexer () -> AsyncMultiplexer Get multiplexer.","title":"multiplexer"},{"location":"api/runtime/#is_running","text":"@property def is_running () -> bool Get running state of the runtime.","title":"is_running"},{"location":"api/runtime/#is_stopped","text":"@property def is_stopped () -> bool Get stopped state of the runtime.","title":"is_stopped"},{"location":"api/runtime/#state","text":"@property def state () -> RuntimeStates Get runtime state. Returns : RuntimeStates","title":"state"},{"location":"api/runtime/#decision_maker","text":"@property def decision_maker () -> DecisionMaker Return decision maker if set.","title":"decision_maker"},{"location":"api/runtime/#set_decision_maker","text":"def set_decision_maker ( decision_maker_handler : DecisionMakerHandler ) -> None Set decision maker with handler provided.","title":"set_decision_maker"},{"location":"api/runtime/#set_loop","text":"def set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use.","title":"set_loop"},{"location":"api/runtime/#asyncruntime-objects","text":"class AsyncRuntime ( BaseRuntime ) Asynchronous runtime: uses asyncio loop for multiplexer and async agent main loop.","title":"AsyncRuntime Objects"},{"location":"api/runtime/#__init___1","text":"def __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager.","title":"__init__"},{"location":"api/runtime/#set_loop_1","text":"def set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use.","title":"set_loop"},{"location":"api/runtime/#run","text":"async def run () -> None Start runtime task. Starts multiplexer and agent loop.","title":"run"},{"location":"api/runtime/#stop_runtime","text":"async def stop_runtime () -> None Stop runtime coroutine. Stop main loop. Tear down the agent.. Disconnect multiplexer.","title":"stop_runtime"},{"location":"api/runtime/#run_runtime","text":"async def run_runtime () -> None Run runtime which means start agent loop, multiplexer and storage.","title":"run_runtime"},{"location":"api/runtime/#threadedruntime-objects","text":"class ThreadedRuntime ( AsyncRuntime ) Run agent and multiplexer in different threads with own asyncio loops.","title":"ThreadedRuntime Objects"},{"location":"api/components/base/","text":"aea.components.base This module contains definitions of agent components. Component Objects class Component ( ABC , WithLogger ) Abstract class for an agent component. __ init __","title":"Base"},{"location":"api/components/base/#aeacomponentsbase","text":"This module contains definitions of agent components.","title":"aea.components.base"},{"location":"api/components/base/#component-objects","text":"class Component ( ABC , WithLogger ) Abstract class for an agent component.","title":"Component Objects"},{"location":"api/components/base/#__init__","text":"","title":"__init__"},{"location":"api/components/loader/","text":"aea.components.loader This module contains utilities for loading components. component _ type _ to _ class def component_type_to_class ( component_type : ComponentType ) -> Type [ Component ] Get the component class from the component type. Arguments : component_type : the component type Returns : the component class load _ component _ from _ config def load_component_from_config ( configuration : ComponentConfiguration , * args , ** kwargs ) -> Component Load a component from a directory. Arguments : configuration : the component configuration. args : the positional arguments. kwargs : the keyword arguments. Returns : the component instance. AEAPackageNotFound Objects class AEAPackageNotFound ( Exception ) Exception when failed to import package, cause not exists.","title":"Loader"},{"location":"api/components/loader/#aeacomponentsloader","text":"This module contains utilities for loading components.","title":"aea.components.loader"},{"location":"api/components/loader/#component_type_to_class","text":"def component_type_to_class ( component_type : ComponentType ) -> Type [ Component ] Get the component class from the component type. Arguments : component_type : the component type Returns : the component class","title":"component_type_to_class"},{"location":"api/components/loader/#load_component_from_config","text":"def load_component_from_config ( configuration : ComponentConfiguration , * args , ** kwargs ) -> Component Load a component from a directory. Arguments : configuration : the component configuration. args : the positional arguments. kwargs : the keyword arguments. Returns : the component instance.","title":"load_component_from_config"},{"location":"api/components/loader/#aeapackagenotfound-objects","text":"class AEAPackageNotFound ( Exception ) Exception when failed to import package, cause not exists.","title":"AEAPackageNotFound Objects"},{"location":"api/components/utils/","text":"aea.components.utils This module contains the component loading utils.","title":"Utils"},{"location":"api/components/utils/#aeacomponentsutils","text":"This module contains the component loading utils.","title":"aea.components.utils"},{"location":"api/configurations/base/","text":"","title":"Base"},{"location":"api/configurations/constants/","text":"aea.configurations.constants Module to declare constants.","title":"Constants"},{"location":"api/configurations/constants/#aeaconfigurationsconstants","text":"Module to declare constants.","title":"aea.configurations.constants"},{"location":"api/configurations/data_types/","text":"aea.configurations.data _ types Base config data types. JSONSerializable Objects class JSONSerializable ( ABC ) Interface for JSON-serializable objects. json @property @abstractmethod def json () -> Dict Compute the JSON representation. from _ json @classmethod def from_json ( cls , obj : Dict ) -> \"JSONSerializable\" Build from a JSON object. PackageVersion Objects @functools . total_ordering class PackageVersion () A package version. __ init __ def __init__ ( version_like : PackageVersionLike ) -> None Initialize a package version. Arguments : version_like : a string, os a semver.VersionInfo object. is _ latest @property def is_latest () -> bool Check whether the version is 'latest'. __ str __ def __str__ () -> str Get the string representation. __ eq __ def __eq__ ( other : Any ) -> bool Check equality. __ lt __ def __lt__ ( other : Any ) -> bool Compare with another object. PackageType Objects class PackageType ( Enum ) Package types. to _ plural def to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts' Returns : pluralised package type __ str __ def __str__ () -> str Convert to string. ComponentType Objects class ComponentType ( Enum ) Enum of component types supported. to _ package _ type def to_package_type () -> PackageType Get package type for component type. plurals @staticmethod def plurals () -> Collection [ str ] Get the collection of type names, plural. ComponentType.plurals() ['protocols', 'connections', 'skills', 'contracts'] Returns : list of all pluralised component types to _ plural def to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts' Returns : pluralised component type __ str __ def __str__ () -> str Get the string representation. PublicId Objects class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id latest_public_id = PublicId(\"author\", \"my_package\", \"latest\") latest_public_id latest_public_id.package_version.is_latest True __ init __ def __init__ ( author : SimpleIdOrStr , name : SimpleIdOrStr , version : Optional [ PackageVersionLike ] = None , package_hash : Optional [ IPFSHashOrStr ] = None ) -> None Initialize the public identifier. author @property def author () -> str Get the author. name @property def name () -> str Get the name. version @property def version () -> str Get the version string. package _ version @property def package_version () -> PackageVersion Get the package version object. hash @property def hash () -> str Returns the hash for the package. same _ prefix def same_prefix ( other : \"PublicId\" ) -> bool Check if the other public id has the same author and name of this. to _ any def to_any () -> \"PublicId\" Return the same public id, but with any version. to _ latest def to_latest () -> \"PublicId\" Return the same public id, but with latest version. is _ valid _ str @classmethod def is_valid_str ( cls , public_id_string : str ) -> bool Check if a string is a public id. Arguments : public_id_string : the public id in string format. Returns : bool indicating validity from _ str @classmethod def from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' str(PublicId.from_str(\"author/package_name:0.1.0:QmYAXgX8ARiriupMQsbGXtKdDyGzWry1YV3sycKw1qqmgH\")) 'author/package_name:0.1.0:QmYAXgX8ARiriupMQsbGXtKdDyGzWry1YV3sycKw1qqmgH' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. PublicId.from_str(\"bad/formatted:0.1.0:Qmbadhash\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:0.1.0:Qmbadhash' is not well formatted. Arguments : public_id_string : the public id in string format. Raises : ValueError : if the string in input is not well formatted. Returns : the public id object. try _ from _ str @classmethod def try_from_str ( cls , public_id_string : str ) -> Optional [ \"PublicId\" ] Safely try to get public id from string. Arguments : public_id_string : the public id in string format. Returns : the public id object or None from _ uri _ path @classmethod def from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Raises : ValueError : if the string in input is not well formatted. Returns : the public id object. to _ uri _ path @property def to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string json @property def json () -> Dict Compute the JSON representation. from _ json @classmethod def from_json ( cls , obj : Dict ) -> \"PublicId\" Build from a JSON object. __ hash __ def __hash__ () -> int Get the hash. __ repr __ def __repr__ () -> str Get the representation. __ eq __ def __eq__ ( other : Any ) -> bool Compare with another object. __ lt __ def __lt__ ( other : Any ) -> bool Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author or name attributes are different. Arguments : other : the object to compate to Raises : ValueError : if the public ids cannot be confirmed Returns : whether or not the inequality is satisfied without _ hash def without_hash () -> \"PublicId\" Returns a PublicId object with same parameters. __ str __ def __str__ () -> str Get the string representation. PackageId Objects class PackageId () A package identifier. __ init __ def __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) -> None Initialize the package id. Arguments : package_type : the package type. public_id : the public id. package _ type @property def package_type () -> PackageType Get the package type. public _ id @property def public_id () -> PublicId Get the public id. author @property def author () -> str Get the author of the package. name @property def name () -> str Get the name of the package. version @property def version () -> str Get the version of the package. package _ hash @property def package_hash () -> str Get the version of the package. package _ prefix @property def package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version. from _ uri _ path @classmethod def from_uri_path ( cls , package_id_uri_path : str ) -> \"PackageId\" Initialize the package id from the string. str(PackageId.from_uri_path(\"skill/author/package_name/0.1.0\")) '(skill, author/package_name:0.1.0)' A bad formatted input raises value error: PackageId.from_uri_path(\"very/bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'very/bad/formatted:input' is not well formatted. Arguments : package_id_uri_path : the package id in uri path string format. Raises : ValueError : if the string in input is not well formatted. Returns : the package id object. to _ uri _ path @property def to_uri_path () -> str Turn the package id into a uri path string. Returns : uri path string without _ hash def without_hash () -> \"PackageId\" Returns PackageId object without hash __ hash __ def __hash__ () -> int Get the hash. __ str __ def __str__ () -> str Get the string representation. __ repr __ def __repr__ () -> str Get the object representation in string. __ eq __ def __eq__ ( other : Any ) -> bool Compare with another object. __ lt __ def __lt__ ( other : Any ) -> bool Compare two public ids. ComponentId Objects class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False __ init __ def __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) -> None Initialize the component id. Arguments : component_type : the component type. public_id : the public id. component _ type @property def component_type () -> ComponentType Get the component type. component _ prefix @property def component_prefix () -> PackageIdPrefix Get the component identifier without the version. same _ prefix def same_prefix ( other : \"ComponentId\" ) -> bool Check if the other component id has the same type, author and name of this. prefix _ import _ path @property def prefix_import_path () -> str Get the prefix import path for this component. json @property def json () -> Dict Get the JSON representation. from _ json @classmethod def from_json ( cls , json_data : Dict ) -> \"ComponentId\" Create component id from json data. without _ hash def without_hash () -> \"ComponentId\" Returns PackageId object without hash PyPIPackageName Objects class PyPIPackageName ( RegexConstrainedString ) A PyPI Package name. GitRef Objects class GitRef ( RegexConstrainedString ) A Git reference. It can be a branch name, a commit hash or a tag. Dependency Objects class Dependency () This class represents a PyPI dependency. It contains the following information: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command. __ init __ def __init__ ( name : Union [ PyPIPackageName , str ], version : Union [ str , SpecifierSet ] = \"\" , index : Optional [ str ] = None , git : Optional [ str ] = None , ref : Optional [ Union [ GitRef , str ]] = None ) -> None Initialize a PyPI dependency. Arguments : name : the package name. version : the specifier set object index : the URL to the PyPI server. git : the URL to a git repository. ref : the Git reference (branch/commit/tag). name @property def name () -> str Get the name. version @property def version () -> str Get the version. index @property def index () -> Optional [ str ] Get the index. git @property def git () -> Optional [ str ] Get the git. ref @property def ref () -> Optional [ str ] Get the ref. from _ json @classmethod def from_json ( cls , obj : Dict [ str , Dict [ str , str ]]) -> \"Dependency\" Parse a dependency object from a dictionary. to _ json def to_json () -> Dict [ str , Dict [ str , str ]] Transform the object to JSON. get _ pip _ install _ args def get_pip_install_args () -> List [ str ] Get 'pip install' arguments. __ str __ def __str__ () -> str Get the string representation. __ eq __ def __eq__ ( other : Any ) -> bool Compare with another object. Dependencies A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set. CRUDCollection Objects class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection. __ init __ def __init__ () -> None Instantiate a CRUD collection. create def create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Raises : ValueError : if the item with the same id is already in the collection. read def read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present. update def update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. delete def delete ( item_id : str ) -> None Delete an item. read _ all def read_all () -> List [ Tuple [ str , T ]] Read all the items. keys def keys () -> Set [ str ] Get the set of keys.","title":"Data Types"},{"location":"api/configurations/data_types/#aeaconfigurationsdata_types","text":"Base config data types.","title":"aea.configurations.data_types"},{"location":"api/configurations/data_types/#jsonserializable-objects","text":"class JSONSerializable ( ABC ) Interface for JSON-serializable objects.","title":"JSONSerializable Objects"},{"location":"api/configurations/data_types/#json","text":"@property @abstractmethod def json () -> Dict Compute the JSON representation.","title":"json"},{"location":"api/configurations/data_types/#from_json","text":"@classmethod def from_json ( cls , obj : Dict ) -> \"JSONSerializable\" Build from a JSON object.","title":"from_json"},{"location":"api/configurations/data_types/#packageversion-objects","text":"@functools . total_ordering class PackageVersion () A package version.","title":"PackageVersion Objects"},{"location":"api/configurations/data_types/#__init__","text":"def __init__ ( version_like : PackageVersionLike ) -> None Initialize a package version. Arguments : version_like : a string, os a semver.VersionInfo object.","title":"__init__"},{"location":"api/configurations/data_types/#is_latest","text":"@property def is_latest () -> bool Check whether the version is 'latest'.","title":"is_latest"},{"location":"api/configurations/data_types/#__str__","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/configurations/data_types/#__eq__","text":"def __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"api/configurations/data_types/#__lt__","text":"def __lt__ ( other : Any ) -> bool Compare with another object.","title":"__lt__"},{"location":"api/configurations/data_types/#packagetype-objects","text":"class PackageType ( Enum ) Package types.","title":"PackageType Objects"},{"location":"api/configurations/data_types/#to_plural","text":"def to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts' Returns : pluralised package type","title":"to_plural"},{"location":"api/configurations/data_types/#__str___1","text":"def __str__ () -> str Convert to string.","title":"__str__"},{"location":"api/configurations/data_types/#componenttype-objects","text":"class ComponentType ( Enum ) Enum of component types supported.","title":"ComponentType Objects"},{"location":"api/configurations/data_types/#to_package_type","text":"def to_package_type () -> PackageType Get package type for component type.","title":"to_package_type"},{"location":"api/configurations/data_types/#plurals","text":"@staticmethod def plurals () -> Collection [ str ] Get the collection of type names, plural. ComponentType.plurals() ['protocols', 'connections', 'skills', 'contracts'] Returns : list of all pluralised component types","title":"plurals"},{"location":"api/configurations/data_types/#to_plural_1","text":"def to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts' Returns : pluralised component type","title":"to_plural"},{"location":"api/configurations/data_types/#__str___2","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/configurations/data_types/#publicid-objects","text":"class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id latest_public_id = PublicId(\"author\", \"my_package\", \"latest\") latest_public_id latest_public_id.package_version.is_latest True","title":"PublicId Objects"},{"location":"api/configurations/data_types/#__init___1","text":"def __init__ ( author : SimpleIdOrStr , name : SimpleIdOrStr , version : Optional [ PackageVersionLike ] = None , package_hash : Optional [ IPFSHashOrStr ] = None ) -> None Initialize the public identifier.","title":"__init__"},{"location":"api/configurations/data_types/#author","text":"@property def author () -> str Get the author.","title":"author"},{"location":"api/configurations/data_types/#name","text":"@property def name () -> str Get the name.","title":"name"},{"location":"api/configurations/data_types/#version","text":"@property def version () -> str Get the version string.","title":"version"},{"location":"api/configurations/data_types/#package_version","text":"@property def package_version () -> PackageVersion Get the package version object.","title":"package_version"},{"location":"api/configurations/data_types/#hash","text":"@property def hash () -> str Returns the hash for the package.","title":"hash"},{"location":"api/configurations/data_types/#same_prefix","text":"def same_prefix ( other : \"PublicId\" ) -> bool Check if the other public id has the same author and name of this.","title":"same_prefix"},{"location":"api/configurations/data_types/#to_any","text":"def to_any () -> \"PublicId\" Return the same public id, but with any version.","title":"to_any"},{"location":"api/configurations/data_types/#to_latest","text":"def to_latest () -> \"PublicId\" Return the same public id, but with latest version.","title":"to_latest"},{"location":"api/configurations/data_types/#is_valid_str","text":"@classmethod def is_valid_str ( cls , public_id_string : str ) -> bool Check if a string is a public id. Arguments : public_id_string : the public id in string format. Returns : bool indicating validity","title":"is_valid_str"},{"location":"api/configurations/data_types/#from_str","text":"@classmethod def from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' str(PublicId.from_str(\"author/package_name:0.1.0:QmYAXgX8ARiriupMQsbGXtKdDyGzWry1YV3sycKw1qqmgH\")) 'author/package_name:0.1.0:QmYAXgX8ARiriupMQsbGXtKdDyGzWry1YV3sycKw1qqmgH' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. PublicId.from_str(\"bad/formatted:0.1.0:Qmbadhash\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:0.1.0:Qmbadhash' is not well formatted. Arguments : public_id_string : the public id in string format. Raises : ValueError : if the string in input is not well formatted. Returns : the public id object.","title":"from_str"},{"location":"api/configurations/data_types/#try_from_str","text":"@classmethod def try_from_str ( cls , public_id_string : str ) -> Optional [ \"PublicId\" ] Safely try to get public id from string. Arguments : public_id_string : the public id in string format. Returns : the public id object or None","title":"try_from_str"},{"location":"api/configurations/data_types/#from_uri_path","text":"@classmethod def from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Raises : ValueError : if the string in input is not well formatted. Returns : the public id object.","title":"from_uri_path"},{"location":"api/configurations/data_types/#to_uri_path","text":"@property def to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"api/configurations/data_types/#json_1","text":"@property def json () -> Dict Compute the JSON representation.","title":"json"},{"location":"api/configurations/data_types/#from_json_1","text":"@classmethod def from_json ( cls , obj : Dict ) -> \"PublicId\" Build from a JSON object.","title":"from_json"},{"location":"api/configurations/data_types/#__hash__","text":"def __hash__ () -> int Get the hash.","title":"__hash__"},{"location":"api/configurations/data_types/#__repr__","text":"def __repr__ () -> str Get the representation.","title":"__repr__"},{"location":"api/configurations/data_types/#__eq___1","text":"def __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"api/configurations/data_types/#__lt___1","text":"def __lt__ ( other : Any ) -> bool Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author or name attributes are different. Arguments : other : the object to compate to Raises : ValueError : if the public ids cannot be confirmed Returns : whether or not the inequality is satisfied","title":"__lt__"},{"location":"api/configurations/data_types/#without_hash","text":"def without_hash () -> \"PublicId\" Returns a PublicId object with same parameters.","title":"without_hash"},{"location":"api/configurations/data_types/#__str___3","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/configurations/data_types/#packageid-objects","text":"class PackageId () A package identifier.","title":"PackageId Objects"},{"location":"api/configurations/data_types/#__init___2","text":"def __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) -> None Initialize the package id. Arguments : package_type : the package type. public_id : the public id.","title":"__init__"},{"location":"api/configurations/data_types/#package_type","text":"@property def package_type () -> PackageType Get the package type.","title":"package_type"},{"location":"api/configurations/data_types/#public_id","text":"@property def public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"api/configurations/data_types/#author_1","text":"@property def author () -> str Get the author of the package.","title":"author"},{"location":"api/configurations/data_types/#name_1","text":"@property def name () -> str Get the name of the package.","title":"name"},{"location":"api/configurations/data_types/#version_1","text":"@property def version () -> str Get the version of the package.","title":"version"},{"location":"api/configurations/data_types/#package_hash","text":"@property def package_hash () -> str Get the version of the package.","title":"package_hash"},{"location":"api/configurations/data_types/#package_prefix","text":"@property def package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version.","title":"package_prefix"},{"location":"api/configurations/data_types/#from_uri_path_1","text":"@classmethod def from_uri_path ( cls , package_id_uri_path : str ) -> \"PackageId\" Initialize the package id from the string. str(PackageId.from_uri_path(\"skill/author/package_name/0.1.0\")) '(skill, author/package_name:0.1.0)' A bad formatted input raises value error: PackageId.from_uri_path(\"very/bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'very/bad/formatted:input' is not well formatted. Arguments : package_id_uri_path : the package id in uri path string format. Raises : ValueError : if the string in input is not well formatted. Returns : the package id object.","title":"from_uri_path"},{"location":"api/configurations/data_types/#to_uri_path_1","text":"@property def to_uri_path () -> str Turn the package id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"api/configurations/data_types/#without_hash_1","text":"def without_hash () -> \"PackageId\" Returns PackageId object without hash","title":"without_hash"},{"location":"api/configurations/data_types/#__hash___1","text":"def __hash__ () -> int Get the hash.","title":"__hash__"},{"location":"api/configurations/data_types/#__str___4","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/configurations/data_types/#__repr___1","text":"def __repr__ () -> str Get the object representation in string.","title":"__repr__"},{"location":"api/configurations/data_types/#__eq___2","text":"def __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"api/configurations/data_types/#__lt___2","text":"def __lt__ ( other : Any ) -> bool Compare two public ids.","title":"__lt__"},{"location":"api/configurations/data_types/#componentid-objects","text":"class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False","title":"ComponentId Objects"},{"location":"api/configurations/data_types/#__init___3","text":"def __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) -> None Initialize the component id. Arguments : component_type : the component type. public_id : the public id.","title":"__init__"},{"location":"api/configurations/data_types/#component_type","text":"@property def component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"api/configurations/data_types/#component_prefix","text":"@property def component_prefix () -> PackageIdPrefix Get the component identifier without the version.","title":"component_prefix"},{"location":"api/configurations/data_types/#same_prefix_1","text":"def same_prefix ( other : \"ComponentId\" ) -> bool Check if the other component id has the same type, author and name of this.","title":"same_prefix"},{"location":"api/configurations/data_types/#prefix_import_path","text":"@property def prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"api/configurations/data_types/#json_2","text":"@property def json () -> Dict Get the JSON representation.","title":"json"},{"location":"api/configurations/data_types/#from_json_2","text":"@classmethod def from_json ( cls , json_data : Dict ) -> \"ComponentId\" Create component id from json data.","title":"from_json"},{"location":"api/configurations/data_types/#without_hash_2","text":"def without_hash () -> \"ComponentId\" Returns PackageId object without hash","title":"without_hash"},{"location":"api/configurations/data_types/#pypipackagename-objects","text":"class PyPIPackageName ( RegexConstrainedString ) A PyPI Package name.","title":"PyPIPackageName Objects"},{"location":"api/configurations/data_types/#gitref-objects","text":"class GitRef ( RegexConstrainedString ) A Git reference. It can be a branch name, a commit hash or a tag.","title":"GitRef Objects"},{"location":"api/configurations/data_types/#dependency-objects","text":"class Dependency () This class represents a PyPI dependency. It contains the following information: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command.","title":"Dependency Objects"},{"location":"api/configurations/data_types/#__init___4","text":"def __init__ ( name : Union [ PyPIPackageName , str ], version : Union [ str , SpecifierSet ] = \"\" , index : Optional [ str ] = None , git : Optional [ str ] = None , ref : Optional [ Union [ GitRef , str ]] = None ) -> None Initialize a PyPI dependency. Arguments : name : the package name. version : the specifier set object index : the URL to the PyPI server. git : the URL to a git repository. ref : the Git reference (branch/commit/tag).","title":"__init__"},{"location":"api/configurations/data_types/#name_2","text":"@property def name () -> str Get the name.","title":"name"},{"location":"api/configurations/data_types/#version_2","text":"@property def version () -> str Get the version.","title":"version"},{"location":"api/configurations/data_types/#index","text":"@property def index () -> Optional [ str ] Get the index.","title":"index"},{"location":"api/configurations/data_types/#git","text":"@property def git () -> Optional [ str ] Get the git.","title":"git"},{"location":"api/configurations/data_types/#ref","text":"@property def ref () -> Optional [ str ] Get the ref.","title":"ref"},{"location":"api/configurations/data_types/#from_json_3","text":"@classmethod def from_json ( cls , obj : Dict [ str , Dict [ str , str ]]) -> \"Dependency\" Parse a dependency object from a dictionary.","title":"from_json"},{"location":"api/configurations/data_types/#to_json","text":"def to_json () -> Dict [ str , Dict [ str , str ]] Transform the object to JSON.","title":"to_json"},{"location":"api/configurations/data_types/#get_pip_install_args","text":"def get_pip_install_args () -> List [ str ] Get 'pip install' arguments.","title":"get_pip_install_args"},{"location":"api/configurations/data_types/#__str___5","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/configurations/data_types/#__eq___3","text":"def __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"api/configurations/data_types/#dependencies","text":"A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set.","title":"Dependencies"},{"location":"api/configurations/data_types/#crudcollection-objects","text":"class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection.","title":"CRUDCollection Objects"},{"location":"api/configurations/data_types/#__init___5","text":"def __init__ () -> None Instantiate a CRUD collection.","title":"__init__"},{"location":"api/configurations/data_types/#create","text":"def create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Raises : ValueError : if the item with the same id is already in the collection.","title":"create"},{"location":"api/configurations/data_types/#read","text":"def read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present.","title":"read"},{"location":"api/configurations/data_types/#update","text":"def update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added.","title":"update"},{"location":"api/configurations/data_types/#delete","text":"def delete ( item_id : str ) -> None Delete an item.","title":"delete"},{"location":"api/configurations/data_types/#read_all","text":"def read_all () -> List [ Tuple [ str , T ]] Read all the items.","title":"read_all"},{"location":"api/configurations/data_types/#keys","text":"def keys () -> Set [ str ] Get the set of keys.","title":"keys"},{"location":"api/configurations/loader/","text":"","title":"Loader"},{"location":"api/configurations/manager/","text":"aea.configurations.manager Implementation of the AgentConfigManager. VariableDoesNotExist Objects class VariableDoesNotExist ( ValueError ) Variable does not exist in a config exception. handle _ dotted _ path def handle_dotted_path ( value : str , author : str , aea_project_path : Union [ str , Path ] = \".\" ) -> Tuple [ List [ str ], Path , ConfigLoader , Optional [ ComponentId ]] Separate the path between path to resource and json path to attribute. Allowed values: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|contracts|connections|skills].package_name.attribute_name We also return the component id to retrieve the configuration of a specific component. Notice that at this point we don't know the version, so we put 'latest' as version, but later we will ignore it because we will filter with only the component prefix (i.e. the triple type, author and name). Arguments : value : dotted path. author : the author string. aea_project_path : project path Returns : Tuple[list of settings dict keys, filepath, config loader, component id]. find _ component _ directory _ from _ component _ id def find_component_directory_from_component_id ( aea_project_directory : Path , component_id : ComponentId ) -> Path Find a component directory from component id. AgentConfigManager Objects class AgentConfigManager () AeaConfig manager. __ init __ def __init__ ( agent_config : AgentConfig , aea_project_directory : Union [ str , Path ], env_vars_friendly : bool = False ) -> None Init manager. Arguments : agent_config : AgentConfig to manage. aea_project_directory : directory where project for agent_config placed. env_vars_friendly : whether or not it is env vars friendly load _ component _ configuration def load_component_configuration ( component_id : ComponentId , skip_consistency_check : bool = True ) -> ComponentConfiguration Load component configuration from the project directory. Arguments : component_id : Id of the component to load config for. skip_consistency_check : bool. Returns : ComponentConfiguration agent _ config _ file _ path @property def agent_config_file_path () -> Path Return agent config file path. load @classmethod def load ( cls , aea_project_path : Union [ Path , str ], substitude_env_vars : bool = False ) -> \"AgentConfigManager\" Create AgentConfigManager instance from agent project path. set _ variable def set_variable ( path : VariablePath , value : JSON_TYPES ) -> None Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] value : one of the json friendly objects. get _ variable def get_variable ( path : VariablePath ) -> JSON_TYPES Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] Returns : json friendly value. update _ config def update_config ( overrides : Dict ) -> None Apply overrides for agent config. Validates and applies agent config and component overrides. Does not save it on the disc! Arguments : overrides : overridden values dictionary Returns : None validate _ current _ config def validate_current_config () -> None Check is current config valid. json @property def json () -> Dict Return current agent config json representation. dump _ config def dump_config () -> None Save agent config on the disc. verify _ private _ keys @classmethod def verify_private_keys ( cls , aea_project_path : Union [ Path , str ], private_key_helper : Callable [[ AgentConfig , Path , Optional [ str ]], None ], substitude_env_vars : bool = False , password : Optional [ str ] = None ) -> \"AgentConfigManager\" Verify private keys. Does not saves the config! Use AgentConfigManager.dump_config() Arguments : aea_project_path : path to an AEA project. private_key_helper : private_key_helper is a function that use agent config to check the keys substitude_env_vars : replace env vars with values, does not dump config password : the password to encrypt/decrypt the private key. Returns : the agent configuration manager. get _ overridables def get_overridables () -> Tuple [ Dict , Dict [ ComponentId , Dict ]] Get config overridables.","title":"Manager"},{"location":"api/configurations/manager/#aeaconfigurationsmanager","text":"Implementation of the AgentConfigManager.","title":"aea.configurations.manager"},{"location":"api/configurations/manager/#variabledoesnotexist-objects","text":"class VariableDoesNotExist ( ValueError ) Variable does not exist in a config exception.","title":"VariableDoesNotExist Objects"},{"location":"api/configurations/manager/#handle_dotted_path","text":"def handle_dotted_path ( value : str , author : str , aea_project_path : Union [ str , Path ] = \".\" ) -> Tuple [ List [ str ], Path , ConfigLoader , Optional [ ComponentId ]] Separate the path between path to resource and json path to attribute. Allowed values: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|contracts|connections|skills].package_name.attribute_name We also return the component id to retrieve the configuration of a specific component. Notice that at this point we don't know the version, so we put 'latest' as version, but later we will ignore it because we will filter with only the component prefix (i.e. the triple type, author and name). Arguments : value : dotted path. author : the author string. aea_project_path : project path Returns : Tuple[list of settings dict keys, filepath, config loader, component id].","title":"handle_dotted_path"},{"location":"api/configurations/manager/#find_component_directory_from_component_id","text":"def find_component_directory_from_component_id ( aea_project_directory : Path , component_id : ComponentId ) -> Path Find a component directory from component id.","title":"find_component_directory_from_component_id"},{"location":"api/configurations/manager/#agentconfigmanager-objects","text":"class AgentConfigManager () AeaConfig manager.","title":"AgentConfigManager Objects"},{"location":"api/configurations/manager/#__init__","text":"def __init__ ( agent_config : AgentConfig , aea_project_directory : Union [ str , Path ], env_vars_friendly : bool = False ) -> None Init manager. Arguments : agent_config : AgentConfig to manage. aea_project_directory : directory where project for agent_config placed. env_vars_friendly : whether or not it is env vars friendly","title":"__init__"},{"location":"api/configurations/manager/#load_component_configuration","text":"def load_component_configuration ( component_id : ComponentId , skip_consistency_check : bool = True ) -> ComponentConfiguration Load component configuration from the project directory. Arguments : component_id : Id of the component to load config for. skip_consistency_check : bool. Returns : ComponentConfiguration","title":"load_component_configuration"},{"location":"api/configurations/manager/#agent_config_file_path","text":"@property def agent_config_file_path () -> Path Return agent config file path.","title":"agent_config_file_path"},{"location":"api/configurations/manager/#load","text":"@classmethod def load ( cls , aea_project_path : Union [ Path , str ], substitude_env_vars : bool = False ) -> \"AgentConfigManager\" Create AgentConfigManager instance from agent project path.","title":"load"},{"location":"api/configurations/manager/#set_variable","text":"def set_variable ( path : VariablePath , value : JSON_TYPES ) -> None Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] value : one of the json friendly objects.","title":"set_variable"},{"location":"api/configurations/manager/#get_variable","text":"def get_variable ( path : VariablePath ) -> JSON_TYPES Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] Returns : json friendly value.","title":"get_variable"},{"location":"api/configurations/manager/#update_config","text":"def update_config ( overrides : Dict ) -> None Apply overrides for agent config. Validates and applies agent config and component overrides. Does not save it on the disc! Arguments : overrides : overridden values dictionary Returns : None","title":"update_config"},{"location":"api/configurations/manager/#validate_current_config","text":"def validate_current_config () -> None Check is current config valid.","title":"validate_current_config"},{"location":"api/configurations/manager/#json","text":"@property def json () -> Dict Return current agent config json representation.","title":"json"},{"location":"api/configurations/manager/#dump_config","text":"def dump_config () -> None Save agent config on the disc.","title":"dump_config"},{"location":"api/configurations/manager/#verify_private_keys","text":"@classmethod def verify_private_keys ( cls , aea_project_path : Union [ Path , str ], private_key_helper : Callable [[ AgentConfig , Path , Optional [ str ]], None ], substitude_env_vars : bool = False , password : Optional [ str ] = None ) -> \"AgentConfigManager\" Verify private keys. Does not saves the config! Use AgentConfigManager.dump_config() Arguments : aea_project_path : path to an AEA project. private_key_helper : private_key_helper is a function that use agent config to check the keys substitude_env_vars : replace env vars with values, does not dump config password : the password to encrypt/decrypt the private key. Returns : the agent configuration manager.","title":"verify_private_keys"},{"location":"api/configurations/manager/#get_overridables","text":"def get_overridables () -> Tuple [ Dict , Dict [ ComponentId , Dict ]] Get config overridables.","title":"get_overridables"},{"location":"api/configurations/pypi/","text":"aea.configurations.pypi This module contains a checker for PyPI version consistency. and _ def and_ ( s1 : SpecifierSet , s2 : SpecifierSet ) -> SpecifierSet Do the and between two specifier sets. is _ satisfiable def is_satisfiable ( specifier_set : SpecifierSet ) -> bool Check if the specifier set is satisfiable. Satisfiable means that there exists a version number that satisfies all the constraints. It is worth noticing that it doesn't mean that that version number with that package actually exists. from packaging.specifiers import SpecifierSet The specifier set \">0.9, ==1.0\" is satisfiable: the version number \"1.0\" satisfies the constraints s1 = SpecifierSet(\">0.9,==1.0\") \"1.0\" in s1 True is_satisfiable(s1) True The specifier set \"==1.0, >1.1\" is not satisfiable: s1 = SpecifierSet(\"==1.0,>1.1\") is_satisfiable(s1) False For other details, please refer to PEP440: https://www.python.org/dev/peps/pep-0440 Arguments : specifier_set : the specifier set. Returns : False if the constraints are surely non-satisfiable, True if we don't know. is _ simple _ dep def is_simple_dep ( dep : Dependency ) -> bool Check if it is a simple dependency. Namely, if it has no field specified, or only the 'version' field set. Arguments : dep : the dependency Returns : whether it is a simple dependency or not to _ set _ specifier def to_set_specifier ( dep : Dependency ) -> SpecifierSet Get the set specifier. It assumes to be a simple dependency (see above). merge _ dependencies def merge_dependencies ( dep1 : Dependencies , dep2 : Dependencies ) -> Dependencies Merge two groups of dependencies. If some of them are not \"simple\" (see above), and there is no risk of conflict because there is no other package with the same name, we leave them; otherwise we raise an error. Arguments : dep1 : the first operand dep2 : the second operand. Returns : the merged dependencies. merge _ dependencies _ list def merge_dependencies_list ( * deps : Dependencies ) -> Dependencies Merge a list of dependencies. Arguments : deps : the list of dependencies Returns : the merged dependencies.","title":"Pypi"},{"location":"api/configurations/pypi/#aeaconfigurationspypi","text":"This module contains a checker for PyPI version consistency.","title":"aea.configurations.pypi"},{"location":"api/configurations/pypi/#and_","text":"def and_ ( s1 : SpecifierSet , s2 : SpecifierSet ) -> SpecifierSet Do the and between two specifier sets.","title":"and_"},{"location":"api/configurations/pypi/#is_satisfiable","text":"def is_satisfiable ( specifier_set : SpecifierSet ) -> bool Check if the specifier set is satisfiable. Satisfiable means that there exists a version number that satisfies all the constraints. It is worth noticing that it doesn't mean that that version number with that package actually exists. from packaging.specifiers import SpecifierSet The specifier set \">0.9, ==1.0\" is satisfiable: the version number \"1.0\" satisfies the constraints s1 = SpecifierSet(\">0.9,==1.0\") \"1.0\" in s1 True is_satisfiable(s1) True The specifier set \"==1.0, >1.1\" is not satisfiable: s1 = SpecifierSet(\"==1.0,>1.1\") is_satisfiable(s1) False For other details, please refer to PEP440: https://www.python.org/dev/peps/pep-0440 Arguments : specifier_set : the specifier set. Returns : False if the constraints are surely non-satisfiable, True if we don't know.","title":"is_satisfiable"},{"location":"api/configurations/pypi/#is_simple_dep","text":"def is_simple_dep ( dep : Dependency ) -> bool Check if it is a simple dependency. Namely, if it has no field specified, or only the 'version' field set. Arguments : dep : the dependency Returns : whether it is a simple dependency or not","title":"is_simple_dep"},{"location":"api/configurations/pypi/#to_set_specifier","text":"def to_set_specifier ( dep : Dependency ) -> SpecifierSet Get the set specifier. It assumes to be a simple dependency (see above).","title":"to_set_specifier"},{"location":"api/configurations/pypi/#merge_dependencies","text":"def merge_dependencies ( dep1 : Dependencies , dep2 : Dependencies ) -> Dependencies Merge two groups of dependencies. If some of them are not \"simple\" (see above), and there is no risk of conflict because there is no other package with the same name, we leave them; otherwise we raise an error. Arguments : dep1 : the first operand dep2 : the second operand. Returns : the merged dependencies.","title":"merge_dependencies"},{"location":"api/configurations/pypi/#merge_dependencies_list","text":"def merge_dependencies_list ( * deps : Dependencies ) -> Dependencies Merge a list of dependencies. Arguments : deps : the list of dependencies Returns : the merged dependencies.","title":"merge_dependencies_list"},{"location":"api/configurations/utils/","text":"aea.configurations.utils AEA configuration utils. replace _ component _ ids @singledispatch def replace_component_ids ( _arg : PackageConfiguration , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Update public id references in a package configuration. This depends on the actual configuration being considered. _ @replace_component_ids . register ( AgentConfig ) # type: ignore def _ ( arg : AgentConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in agent configuration. It breaks down in: 1) replace public ids in 'protocols', 'connections', 'contracts' and 'skills'; 2) replace public ids in default routing; 3) replace public id of default connection; 4) replace custom component configurations. Arguments : arg : the agent configuration. replacements : the replacement mapping. _ @replace_component_ids . register ( ProtocolConfig ) # type: ignore def _ ( _arg : ProtocolConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - protocols have no references. _ @replace_component_ids . register ( ConnectionConfig ) # type: ignore def _ ( arg : ConnectionConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a connection configuration. _ @replace_component_ids . register ( ContractConfig ) # type: ignore def _ ( _arg : ContractConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - contracts have no references. _ @replace_component_ids . register ( SkillConfig ) # type: ignore def _ ( arg : SkillConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a skill configuration. get _ latest _ component _ id _ from _ prefix def get_latest_component_id_from_prefix ( agent_config : AgentConfig , component_prefix : PackageIdPrefix ) -> Optional [ ComponentId ] Get component id with the greatest version in an agent configuration given its prefix. Arguments : agent_config : the agent configuration. component_prefix : the package prefix. Returns : the package id with the greatest version, or None if not found.","title":"Utils"},{"location":"api/configurations/utils/#aeaconfigurationsutils","text":"AEA configuration utils.","title":"aea.configurations.utils"},{"location":"api/configurations/utils/#replace_component_ids","text":"@singledispatch def replace_component_ids ( _arg : PackageConfiguration , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Update public id references in a package configuration. This depends on the actual configuration being considered.","title":"replace_component_ids"},{"location":"api/configurations/utils/#_","text":"@replace_component_ids . register ( AgentConfig ) # type: ignore def _ ( arg : AgentConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in agent configuration. It breaks down in: 1) replace public ids in 'protocols', 'connections', 'contracts' and 'skills'; 2) replace public ids in default routing; 3) replace public id of default connection; 4) replace custom component configurations. Arguments : arg : the agent configuration. replacements : the replacement mapping.","title":"_"},{"location":"api/configurations/utils/#__1","text":"@replace_component_ids . register ( ProtocolConfig ) # type: ignore def _ ( _arg : ProtocolConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - protocols have no references.","title":"_"},{"location":"api/configurations/utils/#__2","text":"@replace_component_ids . register ( ConnectionConfig ) # type: ignore def _ ( arg : ConnectionConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a connection configuration.","title":"_"},{"location":"api/configurations/utils/#__3","text":"@replace_component_ids . register ( ContractConfig ) # type: ignore def _ ( _arg : ContractConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - contracts have no references.","title":"_"},{"location":"api/configurations/utils/#__4","text":"@replace_component_ids . register ( SkillConfig ) # type: ignore def _ ( arg : SkillConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a skill configuration.","title":"_"},{"location":"api/configurations/utils/#get_latest_component_id_from_prefix","text":"def get_latest_component_id_from_prefix ( agent_config : AgentConfig , component_prefix : PackageIdPrefix ) -> Optional [ ComponentId ] Get component id with the greatest version in an agent configuration given its prefix. Arguments : agent_config : the agent configuration. component_prefix : the package prefix. Returns : the package id with the greatest version, or None if not found.","title":"get_latest_component_id_from_prefix"},{"location":"api/configurations/validation/","text":"aea.configurations.validation Implementation of the configuration validation. make _ jsonschema _ base _ uri def make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form. ExtraPropertiesError Objects class ExtraPropertiesError ( ValueError ) Extra properties exception. __ str __ def __str__ () -> str Get string representation of the object. __ repr __ def __repr__ () -> str Get string representation of the object. CustomTypeChecker Objects class CustomTypeChecker ( TypeChecker ) Custom type checker to handle env variables. is _ type def is_type ( instance , type ) -> bool Check is instance of type. own _ additional _ properties def own_additional_properties ( validator , aP , instance , schema ) -> Iterator Additional properties validator. ConfigValidator Objects class ConfigValidator () Configuration validator implementation. __ init __ def __init__ ( schema_filename : str , env_vars_friendly : bool = False ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. env_vars_friendly : whether or not it is env var friendly. split _ component _ id _ and _ config @staticmethod def split_component_id_and_config ( component_index : int , component_configuration_json : Dict ) -> ComponentId Split component id and configuration. Arguments : component_index : the position of the component configuration in the agent config file.. component_configuration_json : the JSON object to process. Raises : ValueError : if the component id cannot be extracted. Returns : the component id and the configuration object. validate _ component _ configuration @classmethod def validate_component_configuration ( cls , component_id : ComponentId , configuration : Dict , env_vars_friendly : bool = False ) -> None Validate the component configuration of an agent configuration file. This check is to detect inconsistencies in the specified fields. Arguments : component_id : the component id. configuration : the configuration dictionary. env_vars_friendly : bool, if set True, will not raise errors over the env variable definitions. Raises : ValueError : if the configuration is not valid. validate def validate ( json_data : Dict ) -> None Validate a JSON object against the right JSON schema. Arguments : json_data : the JSON data. validate _ agent _ components _ configuration def validate_agent_components_configuration ( component_configurations : Dict ) -> None Validate agent component configurations overrides. Arguments : component_configurations : the component configurations to validate. required _ fields @property def required_fields () -> List [ str ] Get the required fields. Returns : list of required fields. validate _ data _ with _ pattern def validate_data_with_pattern ( data : dict , pattern : dict , excludes : Optional [ List [ Tuple [ str ]]] = None , skip_env_vars : bool = False ) -> List [ str ] Validate data dict with pattern dict for attributes present and type match. Arguments : data : data dict to validate pattern : dict with pattern to check over excludes : list of tuples of str of paths to be skipped during the check skip_env_vars : is set True will not check data type over env variables. Returns : list of str with error descriptions filter _ data def filter_data ( base : Any , updates : Any ) -> Any Return difference in values or SAME_MARK object if values are the same.","title":"Validation"},{"location":"api/configurations/validation/#aeaconfigurationsvalidation","text":"Implementation of the configuration validation.","title":"aea.configurations.validation"},{"location":"api/configurations/validation/#make_jsonschema_base_uri","text":"def make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form.","title":"make_jsonschema_base_uri"},{"location":"api/configurations/validation/#extrapropertieserror-objects","text":"class ExtraPropertiesError ( ValueError ) Extra properties exception.","title":"ExtraPropertiesError Objects"},{"location":"api/configurations/validation/#__str__","text":"def __str__ () -> str Get string representation of the object.","title":"__str__"},{"location":"api/configurations/validation/#__repr__","text":"def __repr__ () -> str Get string representation of the object.","title":"__repr__"},{"location":"api/configurations/validation/#customtypechecker-objects","text":"class CustomTypeChecker ( TypeChecker ) Custom type checker to handle env variables.","title":"CustomTypeChecker Objects"},{"location":"api/configurations/validation/#is_type","text":"def is_type ( instance , type ) -> bool Check is instance of type.","title":"is_type"},{"location":"api/configurations/validation/#own_additional_properties","text":"def own_additional_properties ( validator , aP , instance , schema ) -> Iterator Additional properties validator.","title":"own_additional_properties"},{"location":"api/configurations/validation/#configvalidator-objects","text":"class ConfigValidator () Configuration validator implementation.","title":"ConfigValidator Objects"},{"location":"api/configurations/validation/#__init__","text":"def __init__ ( schema_filename : str , env_vars_friendly : bool = False ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. env_vars_friendly : whether or not it is env var friendly.","title":"__init__"},{"location":"api/configurations/validation/#split_component_id_and_config","text":"@staticmethod def split_component_id_and_config ( component_index : int , component_configuration_json : Dict ) -> ComponentId Split component id and configuration. Arguments : component_index : the position of the component configuration in the agent config file.. component_configuration_json : the JSON object to process. Raises : ValueError : if the component id cannot be extracted. Returns : the component id and the configuration object.","title":"split_component_id_and_config"},{"location":"api/configurations/validation/#validate_component_configuration","text":"@classmethod def validate_component_configuration ( cls , component_id : ComponentId , configuration : Dict , env_vars_friendly : bool = False ) -> None Validate the component configuration of an agent configuration file. This check is to detect inconsistencies in the specified fields. Arguments : component_id : the component id. configuration : the configuration dictionary. env_vars_friendly : bool, if set True, will not raise errors over the env variable definitions. Raises : ValueError : if the configuration is not valid.","title":"validate_component_configuration"},{"location":"api/configurations/validation/#validate","text":"def validate ( json_data : Dict ) -> None Validate a JSON object against the right JSON schema. Arguments : json_data : the JSON data.","title":"validate"},{"location":"api/configurations/validation/#validate_agent_components_configuration","text":"def validate_agent_components_configuration ( component_configurations : Dict ) -> None Validate agent component configurations overrides. Arguments : component_configurations : the component configurations to validate.","title":"validate_agent_components_configuration"},{"location":"api/configurations/validation/#required_fields","text":"@property def required_fields () -> List [ str ] Get the required fields. Returns : list of required fields.","title":"required_fields"},{"location":"api/configurations/validation/#validate_data_with_pattern","text":"def validate_data_with_pattern ( data : dict , pattern : dict , excludes : Optional [ List [ Tuple [ str ]]] = None , skip_env_vars : bool = False ) -> List [ str ] Validate data dict with pattern dict for attributes present and type match. Arguments : data : data dict to validate pattern : dict with pattern to check over excludes : list of tuples of str of paths to be skipped during the check skip_env_vars : is set True will not check data type over env variables. Returns : list of str with error descriptions","title":"validate_data_with_pattern"},{"location":"api/configurations/validation/#filter_data","text":"def filter_data ( base : Any , updates : Any ) -> Any Return difference in values or SAME_MARK object if values are the same.","title":"filter_data"},{"location":"api/connections/base/","text":"aea.connections.base The base connection package. ConnectionStates Objects class ConnectionStates ( Enum ) Connection states enum. Connection Objects class Connection ( Component , ABC ) Abstract definition of a connection. __ init __","title":"Base"},{"location":"api/connections/base/#aeaconnectionsbase","text":"The base connection package.","title":"aea.connections.base"},{"location":"api/connections/base/#connectionstates-objects","text":"class ConnectionStates ( Enum ) Connection states enum.","title":"ConnectionStates Objects"},{"location":"api/connections/base/#connection-objects","text":"class Connection ( Component , ABC ) Abstract definition of a connection.","title":"Connection Objects"},{"location":"api/connections/base/#__init__","text":"","title":"__init__"},{"location":"api/context/base/","text":"aea.context.base This module contains the agent context class. AgentContext Objects class AgentContext () Provide read access to relevant objects of the agent for the skills. __ init __ def __init__ ( identity : Identity , connection_status : MultiplexerStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , default_ledger_id : str , currency_denominations : Dict [ str , str ], default_connection : Optional [ PublicId ], default_routing : Dict [ PublicId , PublicId ], search_service_address : Address , decision_maker_address : Address , data_dir : str , storage_callable : Callable [[], Optional [ Storage ]] = lambda : None , send_to_skill : Optional [ Callable ] = None , ** kwargs : Any ) -> None Initialize an agent context. Arguments : identity : the identity object connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager default_ledger_id : the default ledger id currency_denominations : mapping from ledger ids to currency denominations default_connection : the default connection default_routing : the default routing search_service_address : the address of the search service decision_maker_address : the address of the decision maker data_dir : directory where to put local files. storage_callable : function that returns optional storage attached to agent. send_to_skill : callable for sending envelopes to skills. kwargs : keyword arguments to be attached in the agent context namespace. send _ to _ skill def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context storage @property def storage () -> Optional [ Storage ] Return storage instance if enabled in AEA. data _ dir @property def data_dir () -> str Return assets directory. shared _ state @property def shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills. Returns : dictionary of the shared state. identity @property def identity () -> Identity Get the identity. agent _ name @property def agent_name () -> str Get agent name. addresses @property def addresses () -> Dict [ str , Address ] Get addresses. public _ keys @property def public_keys () -> Dict [ str , str ] Get public keys. address @property def address () -> Address Get the default address. public _ key @property def public_key () -> str Get the default public key. connection _ status @property def connection_status () -> MultiplexerStatus Get connection status of the multiplexer. outbox @property def outbox () -> OutBox Get outbox. decision _ maker _ message _ queue @property def decision_maker_message_queue () -> Queue Get decision maker queue. decision _ maker _ handler _ context @property def decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context. task _ manager @property def task_manager () -> TaskManager Get the task manager. search _ service _ address @property def search_service_address () -> Address Get the address of the search service. decision _ maker _ address @property def decision_maker_address () -> Address Get the address of the decision maker. default _ ledger _ id @property def default_ledger_id () -> str Get the default ledger id. currency _ denominations @property def currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations. default _ connection @property def default_connection () -> Optional [ PublicId ] Get the default connection. default _ routing @property def default_routing () -> Dict [ PublicId , PublicId ] Get the default routing. namespace @property def namespace () -> SimpleNamespace Get the agent context namespace.","title":"Context"},{"location":"api/context/base/#aeacontextbase","text":"This module contains the agent context class.","title":"aea.context.base"},{"location":"api/context/base/#agentcontext-objects","text":"class AgentContext () Provide read access to relevant objects of the agent for the skills.","title":"AgentContext Objects"},{"location":"api/context/base/#__init__","text":"def __init__ ( identity : Identity , connection_status : MultiplexerStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , default_ledger_id : str , currency_denominations : Dict [ str , str ], default_connection : Optional [ PublicId ], default_routing : Dict [ PublicId , PublicId ], search_service_address : Address , decision_maker_address : Address , data_dir : str , storage_callable : Callable [[], Optional [ Storage ]] = lambda : None , send_to_skill : Optional [ Callable ] = None , ** kwargs : Any ) -> None Initialize an agent context. Arguments : identity : the identity object connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager default_ledger_id : the default ledger id currency_denominations : mapping from ledger ids to currency denominations default_connection : the default connection default_routing : the default routing search_service_address : the address of the search service decision_maker_address : the address of the decision maker data_dir : directory where to put local files. storage_callable : function that returns optional storage attached to agent. send_to_skill : callable for sending envelopes to skills. kwargs : keyword arguments to be attached in the agent context namespace.","title":"__init__"},{"location":"api/context/base/#send_to_skill","text":"def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context","title":"send_to_skill"},{"location":"api/context/base/#storage","text":"@property def storage () -> Optional [ Storage ] Return storage instance if enabled in AEA.","title":"storage"},{"location":"api/context/base/#data_dir","text":"@property def data_dir () -> str Return assets directory.","title":"data_dir"},{"location":"api/context/base/#shared_state","text":"@property def shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills. Returns : dictionary of the shared state.","title":"shared_state"},{"location":"api/context/base/#identity","text":"@property def identity () -> Identity Get the identity.","title":"identity"},{"location":"api/context/base/#agent_name","text":"@property def agent_name () -> str Get agent name.","title":"agent_name"},{"location":"api/context/base/#addresses","text":"@property def addresses () -> Dict [ str , Address ] Get addresses.","title":"addresses"},{"location":"api/context/base/#public_keys","text":"@property def public_keys () -> Dict [ str , str ] Get public keys.","title":"public_keys"},{"location":"api/context/base/#address","text":"@property def address () -> Address Get the default address.","title":"address"},{"location":"api/context/base/#public_key","text":"@property def public_key () -> str Get the default public key.","title":"public_key"},{"location":"api/context/base/#connection_status","text":"@property def connection_status () -> MultiplexerStatus Get connection status of the multiplexer.","title":"connection_status"},{"location":"api/context/base/#outbox","text":"@property def outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"api/context/base/#decision_maker_message_queue","text":"@property def decision_maker_message_queue () -> Queue Get decision maker queue.","title":"decision_maker_message_queue"},{"location":"api/context/base/#decision_maker_handler_context","text":"@property def decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context.","title":"decision_maker_handler_context"},{"location":"api/context/base/#task_manager","text":"@property def task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"api/context/base/#search_service_address","text":"@property def search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"api/context/base/#decision_maker_address","text":"@property def decision_maker_address () -> Address Get the address of the decision maker.","title":"decision_maker_address"},{"location":"api/context/base/#default_ledger_id","text":"@property def default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"api/context/base/#currency_denominations","text":"@property def currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations.","title":"currency_denominations"},{"location":"api/context/base/#default_connection","text":"@property def default_connection () -> Optional [ PublicId ] Get the default connection.","title":"default_connection"},{"location":"api/context/base/#default_routing","text":"@property def default_routing () -> Dict [ PublicId , PublicId ] Get the default routing.","title":"default_routing"},{"location":"api/context/base/#namespace","text":"@property def namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"api/contracts/base/","text":"aea.contracts.base The base contract. Contract Objects class Contract ( Component ) Abstract definition of a contract. __ init __ def __init__ ( contract_config : ContractConfig , ** kwargs : Any ) -> None Initialize the contract. Arguments : contract_config : the contract configurations. kwargs : the keyword arguments. id @property def id () -> PublicId Get the name. configuration @property def configuration () -> ContractConfig Get the configuration. get _ instance @classmethod def get_instance ( cls , ledger_api : LedgerApi , contract_address : Optional [ str ] = None ) -> Any Get the instance. Arguments : ledger_api : the ledger api we are using. contract_address : the contract address. Returns : the contract instance from _ dir @classmethod def from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the contract object. from _ config @classmethod def from_config ( cls , configuration : ContractConfig , ** kwargs : Any ) -> \"Contract\" Load contract from configuration. Arguments : configuration : the contract configuration. kwargs : the keyword arguments. Returns : the contract object. get _ deploy _ transaction @classmethod def get_deploy_transaction ( cls , ledger_api : LedgerApi , deployer_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_DEPLOY_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the tx get _ raw _ transaction @classmethod def get_raw_transaction ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_RAW_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202 get _ raw _ message @classmethod def get_raw_message ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ bytes ] Handler method for the 'GET_RAW_MESSAGE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202 get _ state @classmethod def get_state ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_STATE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202 contract _ method _ call @classmethod def contract_method_call ( cls , ledger_api : LedgerApi , method_name : str , ** kwargs : Any ) -> Optional [ JSONLike ] Make a contract call. Arguments : ledger_api : the ledger apis. method_name : the contract method name. kwargs : keyword arguments. Returns : the call result build _ transaction @classmethod def build_transaction ( cls , ledger_api : LedgerApi , method_name : str , method_args : Optional [ Dict ], tx_args : Optional [ Dict ]) -> Optional [ JSONLike ] Build a transaction. Arguments : ledger_api : the ledger apis. method_name : method name. method_args : method arguments. tx_args : transaction arguments. Returns : the transaction get _ transaction _ transfer _ logs @classmethod def get_transaction_transfer_logs ( cls , ledger_api : LedgerApi , tx_hash : str , target_address : Optional [ str ] = None ) -> Optional [ JSONLike ] Retrieve the logs from a transaction. Arguments : ledger_api : the ledger apis. tx_hash : The transaction hash to check logs from. target_address : optional address to filter tranfer events to just those that affect it Returns : the tx logs","title":"Base"},{"location":"api/contracts/base/#aeacontractsbase","text":"The base contract.","title":"aea.contracts.base"},{"location":"api/contracts/base/#contract-objects","text":"class Contract ( Component ) Abstract definition of a contract.","title":"Contract Objects"},{"location":"api/contracts/base/#__init__","text":"def __init__ ( contract_config : ContractConfig , ** kwargs : Any ) -> None Initialize the contract. Arguments : contract_config : the contract configurations. kwargs : the keyword arguments.","title":"__init__"},{"location":"api/contracts/base/#id","text":"@property def id () -> PublicId Get the name.","title":"id"},{"location":"api/contracts/base/#configuration","text":"@property def configuration () -> ContractConfig Get the configuration.","title":"configuration"},{"location":"api/contracts/base/#get_instance","text":"@classmethod def get_instance ( cls , ledger_api : LedgerApi , contract_address : Optional [ str ] = None ) -> Any Get the instance. Arguments : ledger_api : the ledger api we are using. contract_address : the contract address. Returns : the contract instance","title":"get_instance"},{"location":"api/contracts/base/#from_dir","text":"@classmethod def from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the contract object.","title":"from_dir"},{"location":"api/contracts/base/#from_config","text":"@classmethod def from_config ( cls , configuration : ContractConfig , ** kwargs : Any ) -> \"Contract\" Load contract from configuration. Arguments : configuration : the contract configuration. kwargs : the keyword arguments. Returns : the contract object.","title":"from_config"},{"location":"api/contracts/base/#get_deploy_transaction","text":"@classmethod def get_deploy_transaction ( cls , ledger_api : LedgerApi , deployer_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_DEPLOY_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the tx","title":"get_deploy_transaction"},{"location":"api/contracts/base/#get_raw_transaction","text":"@classmethod def get_raw_transaction ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_RAW_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202","title":"get_raw_transaction"},{"location":"api/contracts/base/#get_raw_message","text":"@classmethod def get_raw_message ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ bytes ] Handler method for the 'GET_RAW_MESSAGE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202","title":"get_raw_message"},{"location":"api/contracts/base/#get_state","text":"@classmethod def get_state ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_STATE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202","title":"get_state"},{"location":"api/contracts/base/#contract_method_call","text":"@classmethod def contract_method_call ( cls , ledger_api : LedgerApi , method_name : str , ** kwargs : Any ) -> Optional [ JSONLike ] Make a contract call. Arguments : ledger_api : the ledger apis. method_name : the contract method name. kwargs : keyword arguments. Returns : the call result","title":"contract_method_call"},{"location":"api/contracts/base/#build_transaction","text":"@classmethod def build_transaction ( cls , ledger_api : LedgerApi , method_name : str , method_args : Optional [ Dict ], tx_args : Optional [ Dict ]) -> Optional [ JSONLike ] Build a transaction. Arguments : ledger_api : the ledger apis. method_name : method name. method_args : method arguments. tx_args : transaction arguments. Returns : the transaction","title":"build_transaction"},{"location":"api/contracts/base/#get_transaction_transfer_logs","text":"@classmethod def get_transaction_transfer_logs ( cls , ledger_api : LedgerApi , tx_hash : str , target_address : Optional [ str ] = None ) -> Optional [ JSONLike ] Retrieve the logs from a transaction. Arguments : ledger_api : the ledger apis. tx_hash : The transaction hash to check logs from. target_address : optional address to filter tranfer events to just those that affect it Returns : the tx logs","title":"get_transaction_transfer_logs"},{"location":"api/crypto/base/","text":"aea.crypto.base Abstract module wrapping the public and private key cryptography and ledger api. Crypto Objects class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object. __ init __","title":"Base"},{"location":"api/crypto/base/#aeacryptobase","text":"Abstract module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.base"},{"location":"api/crypto/base/#crypto-objects","text":"class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object.","title":"Crypto Objects"},{"location":"api/crypto/base/#__init__","text":"","title":"__init__"},{"location":"api/crypto/helpers/","text":"aea.crypto.helpers Module wrapping the helpers of public and private key cryptography. try _ validate _ private _ key _ path def try_validate_private_key_path ( ledger_id : str , private_key_path : str , password : Optional [ str ] = None ) -> None Try validate a private key path. Arguments : ledger_id : one of 'fetchai', 'ethereum' private_key_path : the path to the private key. password : the password to encrypt/decrypt the private key. Raises : None : ValueError if the identifier is invalid. create _ private _ key def create_private_key ( ledger_id : str , private_key_file : str , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Create a private key for the specified ledger identifier. Arguments : ledger_id : the ledger identifier. private_key_file : the private key file. password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide Raises : None : ValueError if the identifier is invalid. try _ generate _ testnet _ wealth def try_generate_testnet_wealth ( identifier : str , address : str , url : Optional [ str ] = None , _sync : bool = True ) -> None Try generate wealth on a testnet. Arguments : identifier : the identifier of the ledger address : the address to check for url : the url _sync : whether to wait to sync or not; currently unused private _ key _ verify def private_key_verify ( aea_conf : AgentConfig , aea_project_path : Path , password : Optional [ str ] = None ) -> None Check key. Arguments : aea_conf : AgentConfig aea_project_path : Path, where project placed. password : the password to encrypt/decrypt the private key. make _ certificate def make_certificate ( ledger_id : str , crypto_private_key_path : str , message : bytes , output_path : str , password : Optional [ str ] = None ) -> str Create certificate. Arguments : ledger_id : the ledger id crypto_private_key_path : the path to the private key. message : the message to be signed. output_path : the location where to save the certificate. password : the password to encrypt/decrypt the private keys. Returns : the signature/certificate get _ wallet _ from _ agent _ config def get_wallet_from_agent_config ( agent_config : AgentConfig , password : Optional [ str ] = None ) -> Wallet Get wallet from agent_cofig provided. Arguments : agent_config : the agent configuration object password : the password to encrypt/decrypt the private keys. Returns : wallet DecryptError Objects class DecryptError ( ValueError ) Error on bytes decryption with password. __ init __ def __init__ ( msg : Optional [ str ] = None ) -> None Init exception. KeyIsIncorrect Objects class KeyIsIncorrect ( ValueError ) Error decoding hex string to bytes for private key. hex _ to _ bytes _ for _ key def hex_to_bytes_for_key ( data : str ) -> bytes Convert hex string to bytes with error handling.","title":"Helpers"},{"location":"api/crypto/helpers/#aeacryptohelpers","text":"Module wrapping the helpers of public and private key cryptography.","title":"aea.crypto.helpers"},{"location":"api/crypto/helpers/#try_validate_private_key_path","text":"def try_validate_private_key_path ( ledger_id : str , private_key_path : str , password : Optional [ str ] = None ) -> None Try validate a private key path. Arguments : ledger_id : one of 'fetchai', 'ethereum' private_key_path : the path to the private key. password : the password to encrypt/decrypt the private key. Raises : None : ValueError if the identifier is invalid.","title":"try_validate_private_key_path"},{"location":"api/crypto/helpers/#create_private_key","text":"def create_private_key ( ledger_id : str , private_key_file : str , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Create a private key for the specified ledger identifier. Arguments : ledger_id : the ledger identifier. private_key_file : the private key file. password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide Raises : None : ValueError if the identifier is invalid.","title":"create_private_key"},{"location":"api/crypto/helpers/#try_generate_testnet_wealth","text":"def try_generate_testnet_wealth ( identifier : str , address : str , url : Optional [ str ] = None , _sync : bool = True ) -> None Try generate wealth on a testnet. Arguments : identifier : the identifier of the ledger address : the address to check for url : the url _sync : whether to wait to sync or not; currently unused","title":"try_generate_testnet_wealth"},{"location":"api/crypto/helpers/#private_key_verify","text":"def private_key_verify ( aea_conf : AgentConfig , aea_project_path : Path , password : Optional [ str ] = None ) -> None Check key. Arguments : aea_conf : AgentConfig aea_project_path : Path, where project placed. password : the password to encrypt/decrypt the private key.","title":"private_key_verify"},{"location":"api/crypto/helpers/#make_certificate","text":"def make_certificate ( ledger_id : str , crypto_private_key_path : str , message : bytes , output_path : str , password : Optional [ str ] = None ) -> str Create certificate. Arguments : ledger_id : the ledger id crypto_private_key_path : the path to the private key. message : the message to be signed. output_path : the location where to save the certificate. password : the password to encrypt/decrypt the private keys. Returns : the signature/certificate","title":"make_certificate"},{"location":"api/crypto/helpers/#get_wallet_from_agent_config","text":"def get_wallet_from_agent_config ( agent_config : AgentConfig , password : Optional [ str ] = None ) -> Wallet Get wallet from agent_cofig provided. Arguments : agent_config : the agent configuration object password : the password to encrypt/decrypt the private keys. Returns : wallet","title":"get_wallet_from_agent_config"},{"location":"api/crypto/helpers/#decrypterror-objects","text":"class DecryptError ( ValueError ) Error on bytes decryption with password.","title":"DecryptError Objects"},{"location":"api/crypto/helpers/#__init__","text":"def __init__ ( msg : Optional [ str ] = None ) -> None Init exception.","title":"__init__"},{"location":"api/crypto/helpers/#keyisincorrect-objects","text":"class KeyIsIncorrect ( ValueError ) Error decoding hex string to bytes for private key.","title":"KeyIsIncorrect Objects"},{"location":"api/crypto/helpers/#hex_to_bytes_for_key","text":"def hex_to_bytes_for_key ( data : str ) -> bytes Convert hex string to bytes with error handling.","title":"hex_to_bytes_for_key"},{"location":"api/crypto/ledger_apis/","text":"aea.crypto.ledger _ apis Module wrapping all the public and private keys cryptography. LedgerApis Objects class LedgerApis () Store all the ledger apis we initialise. has _ ledger @staticmethod def has_ledger ( identifier : str ) -> bool Check if it has the api. get _ api @classmethod def get_api ( cls , identifier : str ) -> LedgerApi Get the ledger API. get _ balance @classmethod def get_balance ( cls , identifier : str , address : str ) -> Optional [ int ] Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance get _ transfer _ transaction","title":"LedgerApis"},{"location":"api/crypto/ledger_apis/#aeacryptoledger_apis","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.ledger_apis"},{"location":"api/crypto/ledger_apis/#ledgerapis-objects","text":"class LedgerApis () Store all the ledger apis we initialise.","title":"LedgerApis Objects"},{"location":"api/crypto/ledger_apis/#has_ledger","text":"@staticmethod def has_ledger ( identifier : str ) -> bool Check if it has the api.","title":"has_ledger"},{"location":"api/crypto/ledger_apis/#get_api","text":"@classmethod def get_api ( cls , identifier : str ) -> LedgerApi Get the ledger API.","title":"get_api"},{"location":"api/crypto/ledger_apis/#get_balance","text":"@classmethod def get_balance ( cls , identifier : str , address : str ) -> Optional [ int ] Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance","title":"get_balance"},{"location":"api/crypto/ledger_apis/#get_transfer_transaction","text":"","title":"get_transfer_transaction"},{"location":"api/crypto/plugin/","text":"aea.crypto.plugin Implementation of plug-in mechanism for cryptos. Plugin Objects class Plugin () Class that implements an AEA plugin. __ init __ def __init__ ( group : str , entry_point : EntryPoint ) Initialize the plugin. Arguments : group : the group the plugin belongs to. entry_point : the entrypoint. name @property def name () -> str Get the plugin identifier. group @property def group () -> str Get the group. attr @property def attr () -> str Get the class name. entry _ point _ path @property def entry_point_path () -> str Get the entry point path. load _ all _ plugins def load_all_plugins ( is_raising_exception : bool = True ) -> None Load all plugins.","title":"Plugin"},{"location":"api/crypto/plugin/#aeacryptoplugin","text":"Implementation of plug-in mechanism for cryptos.","title":"aea.crypto.plugin"},{"location":"api/crypto/plugin/#plugin-objects","text":"class Plugin () Class that implements an AEA plugin.","title":"Plugin Objects"},{"location":"api/crypto/plugin/#__init__","text":"def __init__ ( group : str , entry_point : EntryPoint ) Initialize the plugin. Arguments : group : the group the plugin belongs to. entry_point : the entrypoint.","title":"__init__"},{"location":"api/crypto/plugin/#name","text":"@property def name () -> str Get the plugin identifier.","title":"name"},{"location":"api/crypto/plugin/#group","text":"@property def group () -> str Get the group.","title":"group"},{"location":"api/crypto/plugin/#attr","text":"@property def attr () -> str Get the class name.","title":"attr"},{"location":"api/crypto/plugin/#entry_point_path","text":"@property def entry_point_path () -> str Get the entry point path.","title":"entry_point_path"},{"location":"api/crypto/plugin/#load_all_plugins","text":"def load_all_plugins ( is_raising_exception : bool = True ) -> None Load all plugins.","title":"load_all_plugins"},{"location":"api/crypto/wallet/","text":"aea.crypto.wallet Module wrapping all the public and private keys cryptography. CryptoStore Objects class CryptoStore () Utility class to store and retrieve crypto objects. __ init __ def __init__ ( crypto_id_to_path : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) -> None Initialize the crypto store. Arguments : crypto_id_to_path : dictionary from crypto id to an (optional) path to the private key. password : the password to encrypt/decrypt the private key. public _ keys @property def public_keys () -> Dict [ str , str ] Get the public_key dictionary. crypto _ objects @property def crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair). addresses @property def addresses () -> Dict [ str , str ] Get the crypto addresses. private _ keys @property def private_keys () -> Dict [ str , str ] Get the crypto addresses. Wallet Objects class Wallet () Container for crypto objects. The cryptos are separated into two categories: main cryptos: used by the AEA for the economic side (i.e. signing transaction) connection cryptos: exposed to the connection objects for encrypted communication. __ init __ def __init__ ( private_key_paths : Dict [ str , Optional [ str ]], connection_private_key_paths : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) Instantiate a wallet object. Arguments : private_key_paths : the private key paths connection_private_key_paths : the private key paths for the connections. password : the password to encrypt/decrypt the private key. public _ keys @property def public_keys () -> Dict [ str , str ] Get the public_key dictionary. crypto _ objects @property def crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair). addresses @property def addresses () -> Dict [ str , str ] Get the crypto addresses. private _ keys @property def private_keys () -> Dict [ str , str ] Get the crypto addresses. main _ cryptos @property def main_cryptos () -> CryptoStore Get the main crypto store. connection _ cryptos @property def connection_cryptos () -> CryptoStore Get the connection crypto store. sign _ message def sign_message ( crypto_id : str , message : bytes , is_deprecated_mode : bool = False ) -> Optional [ str ] Sign a message. Arguments : crypto_id : the id of the crypto message : the message to be signed is_deprecated_mode : what signing mode to use Returns : the signature of the message sign _ transaction def sign_transaction ( crypto_id : str , transaction : Any ) -> Optional [ JSONLike ] Sign a tx. Arguments : crypto_id : the id of the crypto transaction : the transaction to be signed Returns : the signed tx","title":"Wallet"},{"location":"api/crypto/wallet/#aeacryptowallet","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.wallet"},{"location":"api/crypto/wallet/#cryptostore-objects","text":"class CryptoStore () Utility class to store and retrieve crypto objects.","title":"CryptoStore Objects"},{"location":"api/crypto/wallet/#__init__","text":"def __init__ ( crypto_id_to_path : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) -> None Initialize the crypto store. Arguments : crypto_id_to_path : dictionary from crypto id to an (optional) path to the private key. password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"api/crypto/wallet/#public_keys","text":"@property def public_keys () -> Dict [ str , str ] Get the public_key dictionary.","title":"public_keys"},{"location":"api/crypto/wallet/#crypto_objects","text":"@property def crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"api/crypto/wallet/#addresses","text":"@property def addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"api/crypto/wallet/#private_keys","text":"@property def private_keys () -> Dict [ str , str ] Get the crypto addresses.","title":"private_keys"},{"location":"api/crypto/wallet/#wallet-objects","text":"class Wallet () Container for crypto objects. The cryptos are separated into two categories: main cryptos: used by the AEA for the economic side (i.e. signing transaction) connection cryptos: exposed to the connection objects for encrypted communication.","title":"Wallet Objects"},{"location":"api/crypto/wallet/#__init___1","text":"def __init__ ( private_key_paths : Dict [ str , Optional [ str ]], connection_private_key_paths : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) Instantiate a wallet object. Arguments : private_key_paths : the private key paths connection_private_key_paths : the private key paths for the connections. password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"api/crypto/wallet/#public_keys_1","text":"@property def public_keys () -> Dict [ str , str ] Get the public_key dictionary.","title":"public_keys"},{"location":"api/crypto/wallet/#crypto_objects_1","text":"@property def crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"api/crypto/wallet/#addresses_1","text":"@property def addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"api/crypto/wallet/#private_keys_1","text":"@property def private_keys () -> Dict [ str , str ] Get the crypto addresses.","title":"private_keys"},{"location":"api/crypto/wallet/#main_cryptos","text":"@property def main_cryptos () -> CryptoStore Get the main crypto store.","title":"main_cryptos"},{"location":"api/crypto/wallet/#connection_cryptos","text":"@property def connection_cryptos () -> CryptoStore Get the connection crypto store.","title":"connection_cryptos"},{"location":"api/crypto/wallet/#sign_message","text":"def sign_message ( crypto_id : str , message : bytes , is_deprecated_mode : bool = False ) -> Optional [ str ] Sign a message. Arguments : crypto_id : the id of the crypto message : the message to be signed is_deprecated_mode : what signing mode to use Returns : the signature of the message","title":"sign_message"},{"location":"api/crypto/wallet/#sign_transaction","text":"def sign_transaction ( crypto_id : str , transaction : Any ) -> Optional [ JSONLike ] Sign a tx. Arguments : crypto_id : the id of the crypto transaction : the transaction to be signed Returns : the signed tx","title":"sign_transaction"},{"location":"api/crypto/registries/base/","text":"aea.crypto.registries.base This module implements the base registry. ItemId Objects class ItemId ( RegexConstrainedString ) The identifier of an item class. name @property def name () -> str Get the id name. EntryPoint Objects class EntryPoint ( Generic [ ItemType ], RegexConstrainedString ) The entry point for a resource. The regular expression matches the strings in the following format: path.to.module:className __ init __ def __init__ ( seq : Union [ \"EntryPoint\" , str ]) -> None Initialize the entrypoint. import _ path @property def import_path () -> str Get the import path. class _ name @property def class_name () -> str Get the class name. load def load () -> Type [ ItemType ] Load the item object. Returns : the crypto object, loaded following the spec. ItemSpec Objects class ItemSpec ( Generic [ ItemType ]) A specification for a particular instance of an object. __ init __","title":"Base"},{"location":"api/crypto/registries/base/#aeacryptoregistriesbase","text":"This module implements the base registry.","title":"aea.crypto.registries.base"},{"location":"api/crypto/registries/base/#itemid-objects","text":"class ItemId ( RegexConstrainedString ) The identifier of an item class.","title":"ItemId Objects"},{"location":"api/crypto/registries/base/#name","text":"@property def name () -> str Get the id name.","title":"name"},{"location":"api/crypto/registries/base/#entrypoint-objects","text":"class EntryPoint ( Generic [ ItemType ], RegexConstrainedString ) The entry point for a resource. The regular expression matches the strings in the following format: path.to.module:className","title":"EntryPoint Objects"},{"location":"api/crypto/registries/base/#__init__","text":"def __init__ ( seq : Union [ \"EntryPoint\" , str ]) -> None Initialize the entrypoint.","title":"__init__"},{"location":"api/crypto/registries/base/#import_path","text":"@property def import_path () -> str Get the import path.","title":"import_path"},{"location":"api/crypto/registries/base/#class_name","text":"@property def class_name () -> str Get the class name.","title":"class_name"},{"location":"api/crypto/registries/base/#load","text":"def load () -> Type [ ItemType ] Load the item object. Returns : the crypto object, loaded following the spec.","title":"load"},{"location":"api/crypto/registries/base/#itemspec-objects","text":"class ItemSpec ( Generic [ ItemType ]) A specification for a particular instance of an object.","title":"ItemSpec Objects"},{"location":"api/crypto/registries/base/#__init___1","text":"","title":"__init__"},{"location":"api/decision_maker/base/","text":"aea.decision _ maker.base This module contains the decision maker class. OwnershipState Objects class OwnershipState ( ABC ) Represent the ownership state of an agent (can proxy a ledger). set @abstractmethod def set ( ** kwargs : Any ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments apply _ delta @abstractmethod def apply_delta ( ** kwargs : Any ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments is _ initialized @property @abstractmethod def is_initialized () -> bool Get the initialization status. is _ affordable _ transaction @abstractmethod def is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise. apply _ transactions @abstractmethod def apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state. __ copy __ @abstractmethod def __copy__ () -> \"OwnershipState\" Copy the object. Preferences Objects class Preferences ( ABC ) Class to represent the preferences. set @abstractmethod def set ( ** kwargs : Any ) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments is _ initialized @property @abstractmethod def is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None. marginal _ utility @abstractmethod def marginal_utility ( ownership_state : OwnershipState , ** kwargs : Any ) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword arguments Returns : the marginal utility score utility _ diff _ from _ transaction @abstractmethod def utility_diff_from_transaction ( ownership_state : OwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score. __ copy __ @abstractmethod def __copy__ () -> \"Preferences\" Copy the object. ProtectedQueue Objects class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it. __ init __ def __init__ ( access_code : str ) -> None Initialize the protected queue. Arguments : access_code : the access code to read from the queue put def put ( internal_message : Optional [ Message ], block : bool = True , timeout : Optional [ float ] = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue block : whether to block or not timeout : timeout on block Raises : None : ValueError, if the item is not an internal message put _ nowait def put_nowait ( internal_message : Optional [ Message ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue Raises : None : ValueError, if the item is not an internal message get def get ( block : bool = True , timeout : Optional [ float ] = None ) -> None Inaccessible get method. Arguments : block : whether to block or not timeout : timeout on block Raises : None : ValueError, access not permitted. get _ nowait def get_nowait () -> None Inaccessible get_nowait method. Raises : None : ValueError, access not permitted. protected _ get def protected_get ( access_code : str , block : bool = True , timeout : Optional [ float ] = None ) -> Optional [ Message ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Raises : None : ValueError, if caller is not permitted Returns : internal message DecisionMakerHandler Objects class DecisionMakerHandler ( WithLogger , ABC ) This class implements the decision maker. __ init __ def __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ], ** kwargs : Any ) -> None Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler kwargs : the key word arguments agent _ name @property def agent_name () -> str Get the agent name. identity @property def identity () -> Identity Get identity of the agent. wallet @property def wallet () -> Wallet Get wallet of the agent. config @property def config () -> Dict [ str , Any ] Get user defined configuration context @property def context () -> SimpleNamespace Get the context. message _ out _ queue @property def message_out_queue () -> AsyncFriendlyQueue Get (out) queue. handle @abstractmethod def handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message DecisionMaker Objects class DecisionMaker ( WithLogger ) This class implements the decision maker. __ init __ def __init__ ( decision_maker_handler : DecisionMakerHandler ) -> None Initialize the decision maker. Arguments : decision_maker_handler : the decision maker handler agent _ name @property def agent_name () -> str Get the agent name. message _ in _ queue @property def message_in_queue () -> ProtectedQueue Get (in) queue. message _ out _ queue @property def message_out_queue () -> AsyncFriendlyQueue Get (out) queue. decision _ maker _ handler @property def decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler. start def start () -> None Start the decision maker. stop def stop () -> None Stop the decision maker. execute def execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them handle def handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"Base"},{"location":"api/decision_maker/base/#aeadecision_makerbase","text":"This module contains the decision maker class.","title":"aea.decision_maker.base"},{"location":"api/decision_maker/base/#ownershipstate-objects","text":"class OwnershipState ( ABC ) Represent the ownership state of an agent (can proxy a ledger).","title":"OwnershipState Objects"},{"location":"api/decision_maker/base/#set","text":"@abstractmethod def set ( ** kwargs : Any ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments","title":"set"},{"location":"api/decision_maker/base/#apply_delta","text":"@abstractmethod def apply_delta ( ** kwargs : Any ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments","title":"apply_delta"},{"location":"api/decision_maker/base/#is_initialized","text":"@property @abstractmethod def is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"api/decision_maker/base/#is_affordable_transaction","text":"@abstractmethod def is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise.","title":"is_affordable_transaction"},{"location":"api/decision_maker/base/#apply_transactions","text":"@abstractmethod def apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state.","title":"apply_transactions"},{"location":"api/decision_maker/base/#__copy__","text":"@abstractmethod def __copy__ () -> \"OwnershipState\" Copy the object.","title":"__copy__"},{"location":"api/decision_maker/base/#preferences-objects","text":"class Preferences ( ABC ) Class to represent the preferences.","title":"Preferences Objects"},{"location":"api/decision_maker/base/#set_1","text":"@abstractmethod def set ( ** kwargs : Any ) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments","title":"set"},{"location":"api/decision_maker/base/#is_initialized_1","text":"@property @abstractmethod def is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None.","title":"is_initialized"},{"location":"api/decision_maker/base/#marginal_utility","text":"@abstractmethod def marginal_utility ( ownership_state : OwnershipState , ** kwargs : Any ) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword arguments Returns : the marginal utility score","title":"marginal_utility"},{"location":"api/decision_maker/base/#utility_diff_from_transaction","text":"@abstractmethod def utility_diff_from_transaction ( ownership_state : OwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score.","title":"utility_diff_from_transaction"},{"location":"api/decision_maker/base/#__copy___1","text":"@abstractmethod def __copy__ () -> \"Preferences\" Copy the object.","title":"__copy__"},{"location":"api/decision_maker/base/#protectedqueue-objects","text":"class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it.","title":"ProtectedQueue Objects"},{"location":"api/decision_maker/base/#__init__","text":"def __init__ ( access_code : str ) -> None Initialize the protected queue. Arguments : access_code : the access code to read from the queue","title":"__init__"},{"location":"api/decision_maker/base/#put","text":"def put ( internal_message : Optional [ Message ], block : bool = True , timeout : Optional [ float ] = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue block : whether to block or not timeout : timeout on block Raises : None : ValueError, if the item is not an internal message","title":"put"},{"location":"api/decision_maker/base/#put_nowait","text":"def put_nowait ( internal_message : Optional [ Message ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue Raises : None : ValueError, if the item is not an internal message","title":"put_nowait"},{"location":"api/decision_maker/base/#get","text":"def get ( block : bool = True , timeout : Optional [ float ] = None ) -> None Inaccessible get method. Arguments : block : whether to block or not timeout : timeout on block Raises : None : ValueError, access not permitted.","title":"get"},{"location":"api/decision_maker/base/#get_nowait","text":"def get_nowait () -> None Inaccessible get_nowait method. Raises : None : ValueError, access not permitted.","title":"get_nowait"},{"location":"api/decision_maker/base/#protected_get","text":"def protected_get ( access_code : str , block : bool = True , timeout : Optional [ float ] = None ) -> Optional [ Message ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Raises : None : ValueError, if caller is not permitted Returns : internal message","title":"protected_get"},{"location":"api/decision_maker/base/#decisionmakerhandler-objects","text":"class DecisionMakerHandler ( WithLogger , ABC ) This class implements the decision maker.","title":"DecisionMakerHandler Objects"},{"location":"api/decision_maker/base/#__init___1","text":"def __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ], ** kwargs : Any ) -> None Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler kwargs : the key word arguments","title":"__init__"},{"location":"api/decision_maker/base/#agent_name","text":"@property def agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"api/decision_maker/base/#identity","text":"@property def identity () -> Identity Get identity of the agent.","title":"identity"},{"location":"api/decision_maker/base/#wallet","text":"@property def wallet () -> Wallet Get wallet of the agent.","title":"wallet"},{"location":"api/decision_maker/base/#config","text":"@property def config () -> Dict [ str , Any ] Get user defined configuration","title":"config"},{"location":"api/decision_maker/base/#context","text":"@property def context () -> SimpleNamespace Get the context.","title":"context"},{"location":"api/decision_maker/base/#message_out_queue","text":"@property def message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"api/decision_maker/base/#handle","text":"@abstractmethod def handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"handle"},{"location":"api/decision_maker/base/#decisionmaker-objects","text":"class DecisionMaker ( WithLogger ) This class implements the decision maker.","title":"DecisionMaker Objects"},{"location":"api/decision_maker/base/#__init___2","text":"def __init__ ( decision_maker_handler : DecisionMakerHandler ) -> None Initialize the decision maker. Arguments : decision_maker_handler : the decision maker handler","title":"__init__"},{"location":"api/decision_maker/base/#agent_name_1","text":"@property def agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"api/decision_maker/base/#message_in_queue","text":"@property def message_in_queue () -> ProtectedQueue Get (in) queue.","title":"message_in_queue"},{"location":"api/decision_maker/base/#message_out_queue_1","text":"@property def message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"api/decision_maker/base/#decision_maker_handler","text":"@property def decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler.","title":"decision_maker_handler"},{"location":"api/decision_maker/base/#start","text":"def start () -> None Start the decision maker.","title":"start"},{"location":"api/decision_maker/base/#stop","text":"def stop () -> None Stop the decision maker.","title":"stop"},{"location":"api/decision_maker/base/#execute","text":"def execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them","title":"execute"},{"location":"api/decision_maker/base/#handle_1","text":"def handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"handle"},{"location":"api/decision_maker/default/","text":"aea.decision _ maker.default This module contains the decision maker class. DecisionMakerHandler Objects class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker. SigningDialogues Objects class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues. __ init __ def __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments __ init __ def __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ]) -> None Initialize the decision maker. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler handle def handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"Default"},{"location":"api/decision_maker/default/#aeadecision_makerdefault","text":"This module contains the decision maker class.","title":"aea.decision_maker.default"},{"location":"api/decision_maker/default/#decisionmakerhandler-objects","text":"class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker.","title":"DecisionMakerHandler Objects"},{"location":"api/decision_maker/default/#signingdialogues-objects","text":"class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues.","title":"SigningDialogues Objects"},{"location":"api/decision_maker/default/#__init__","text":"def __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments","title":"__init__"},{"location":"api/decision_maker/default/#__init___1","text":"def __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ]) -> None Initialize the decision maker. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler","title":"__init__"},{"location":"api/decision_maker/default/#handle","text":"def handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"handle"},{"location":"api/error_handler/base/","text":"aea.error _ handler.base This module contains the abstract error handler class. AbstractErrorHandler Objects class AbstractErrorHandler ( ABC ) Error handler class for handling problematic envelopes. __ init __ def __init__ ( ** kwargs : Any ) Instantiate error handler. config @property def config () -> Dict [ str , Any ] Get handler config. send _ unsupported _ protocol @abstractmethod def send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger Returns : None send _ decoding _ error @abstractmethod def send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger Returns : None send _ no _ active _ handler @abstractmethod def send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger Returns : None","title":"Base"},{"location":"api/error_handler/base/#aeaerror_handlerbase","text":"This module contains the abstract error handler class.","title":"aea.error_handler.base"},{"location":"api/error_handler/base/#abstracterrorhandler-objects","text":"class AbstractErrorHandler ( ABC ) Error handler class for handling problematic envelopes.","title":"AbstractErrorHandler Objects"},{"location":"api/error_handler/base/#__init__","text":"def __init__ ( ** kwargs : Any ) Instantiate error handler.","title":"__init__"},{"location":"api/error_handler/base/#config","text":"@property def config () -> Dict [ str , Any ] Get handler config.","title":"config"},{"location":"api/error_handler/base/#send_unsupported_protocol","text":"@abstractmethod def send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger Returns : None","title":"send_unsupported_protocol"},{"location":"api/error_handler/base/#send_decoding_error","text":"@abstractmethod def send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger Returns : None","title":"send_decoding_error"},{"location":"api/error_handler/base/#send_no_active_handler","text":"@abstractmethod def send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger Returns : None","title":"send_no_active_handler"},{"location":"api/error_handler/default/","text":"aea.error _ handler.default This module contains the default error handler class. ErrorHandler Objects class ErrorHandler ( AbstractErrorHandler ) Error handler class for handling problematic envelopes. __ init __ def __init__ ( ** kwargs : Any ) Instantiate error handler. send _ unsupported _ protocol def send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger send _ decoding _ error def send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger send _ no _ active _ handler def send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger","title":"Default"},{"location":"api/error_handler/default/#aeaerror_handlerdefault","text":"This module contains the default error handler class.","title":"aea.error_handler.default"},{"location":"api/error_handler/default/#errorhandler-objects","text":"class ErrorHandler ( AbstractErrorHandler ) Error handler class for handling problematic envelopes.","title":"ErrorHandler Objects"},{"location":"api/error_handler/default/#__init__","text":"def __init__ ( ** kwargs : Any ) Instantiate error handler.","title":"__init__"},{"location":"api/error_handler/default/#send_unsupported_protocol","text":"def send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger","title":"send_unsupported_protocol"},{"location":"api/error_handler/default/#send_decoding_error","text":"def send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger","title":"send_decoding_error"},{"location":"api/error_handler/default/#send_no_active_handler","text":"def send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger","title":"send_no_active_handler"},{"location":"api/helpers/async_friendly_queue/","text":"aea.helpers.async _ friendly _ queue This module contains the implementation of AsyncFriendlyQueue. AsyncFriendlyQueue Objects class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method. __ init __ def __init__ ( * args : Any , ** kwargs : Any ) -> None Init queue. put def put ( item : Any , * args : Any , ** kwargs : Any ) -> None Put an item into the queue. Arguments : item : item to put in the queue args : similar to queue.Queue.put kwargs : similar to queue.Queue.put get def get ( * args : Any , ** kwargs : Any ) -> Any Get an item into the queue. Arguments : args : similar to queue.Queue.get kwargs : similar to queue.Queue.get Returns : similar to queue.Queue.get async _ wait async def async_wait () -> None Wait an item appears in the queue. Returns : None async _ get async def async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"Async Friendly Queue"},{"location":"api/helpers/async_friendly_queue/#aeahelpersasync_friendly_queue","text":"This module contains the implementation of AsyncFriendlyQueue.","title":"aea.helpers.async_friendly_queue"},{"location":"api/helpers/async_friendly_queue/#asyncfriendlyqueue-objects","text":"class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method.","title":"AsyncFriendlyQueue Objects"},{"location":"api/helpers/async_friendly_queue/#__init__","text":"def __init__ ( * args : Any , ** kwargs : Any ) -> None Init queue.","title":"__init__"},{"location":"api/helpers/async_friendly_queue/#put","text":"def put ( item : Any , * args : Any , ** kwargs : Any ) -> None Put an item into the queue. Arguments : item : item to put in the queue args : similar to queue.Queue.put kwargs : similar to queue.Queue.put","title":"put"},{"location":"api/helpers/async_friendly_queue/#get","text":"def get ( * args : Any , ** kwargs : Any ) -> Any Get an item into the queue. Arguments : args : similar to queue.Queue.get kwargs : similar to queue.Queue.get Returns : similar to queue.Queue.get","title":"get"},{"location":"api/helpers/async_friendly_queue/#async_wait","text":"async def async_wait () -> None Wait an item appears in the queue. Returns : None","title":"async_wait"},{"location":"api/helpers/async_friendly_queue/#async_get","text":"async def async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"async_get"},{"location":"api/helpers/async_utils/","text":"aea.helpers.async _ utils This module contains the misc utils for async code. ensure _ list def ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence. AsyncState Objects class AsyncState () Awaitable state. __ init __ def __init__ ( initial_state : Any = None , states_enum : Optional [ Container [ Any ]] = None ) -> None Init async state. Arguments : initial_state : state to set on start. states_enum : container of valid states if not provided state not checked on set. set def set ( state : Any ) -> None Set state. add _ callback def add_callback ( callback_fn : Callable [[ Any ], None ]) -> None Add callback to track state changes. Arguments : callback_fn : callable object to be called on state changed. get def get () -> Any Get state. wait async def wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state. transit @contextmanager def transit ( initial : Any = not_set , success : Any = not_set , fail : Any = not_set ) -> Generator Change state context according to success or not. Arguments : initial : set state on context enter, not_set by default success : set state on context block done, not_set by default fail : set state on context block raises exception, not_set by default Returns : generator PeriodicCaller Objects class PeriodicCaller () Schedule a periodic call of callable using event loop. Used for periodic function run using asyncio. __ init __ def __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) -> None Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop start def start () -> None Activate period calls. stop def stop () -> None Remove from schedule. AnotherThreadTask Objects class AnotherThreadTask () Schedule a task to run on the loop in another thread. Provides better cancel behaviour: on cancel it will wait till cancelled completely. __ init __ def __init__ ( coro : Awaitable , loop : AbstractEventLoop ) -> None Init the task. Arguments : coro : coroutine to schedule loop : an event loop to schedule on. result def result ( timeout : Optional [ float ] = None ) -> Any Wait for coroutine execution result. Arguments : timeout : optional timeout to wait in seconds. Returns : result cancel def cancel () -> None Cancel coroutine task execution in a target loop. done def done () -> bool Check task is done. ThreadedAsyncRunner Objects class ThreadedAsyncRunner ( Thread ) Util to run thread with event loop and execute coroutines inside. __ init __ def __init__ ( loop : Optional [ AbstractEventLoop ] = None ) -> None Init threaded runner. Arguments : loop : optional event loop. is it's running loop, threaded runner will use it. start def start () -> None Start event loop in dedicated thread. run def run () -> None Run code inside thread. call def call ( coro : Awaitable ) -> Any Run a coroutine inside the event loop. Arguments : coro : a coroutine to run. Returns : task stop def stop () -> None Stop event loop in thread. Runnable Objects class Runnable ( ABC ) Abstract Runnable class. Use to run async task in same event loop or in dedicated thread. Provides: start, stop sync methods to start and stop task Use wait_completed to await task was completed. __ init __ def __init__ ( loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init runnable. Arguments : loop : asyncio event loop to use. threaded : bool. start in thread if True. start def start () -> bool Start runnable. Returns : bool started or not. is _ running @property def is_running () -> bool Get running state. run @abstractmethod async def run () -> Any Implement run logic respectful to CancelError on termination. wait _ completed def wait_completed ( sync : bool = False , timeout : float = None , force_result : bool = False ) -> Awaitable Wait runnable execution completed. Arguments : sync : bool. blocking wait timeout : float seconds force_result : check result even it was waited. Returns : awaitable if sync is False, otherwise None stop def stop ( force : bool = False ) -> None Stop runnable. start _ and _ wait _ completed def start_and_wait_completed ( * args : Any , ** kwargs : Any ) -> Awaitable Alias for start and wait methods.","title":"Async Utils"},{"location":"api/helpers/async_utils/#aeahelpersasync_utils","text":"This module contains the misc utils for async code.","title":"aea.helpers.async_utils"},{"location":"api/helpers/async_utils/#ensure_list","text":"def ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence.","title":"ensure_list"},{"location":"api/helpers/async_utils/#asyncstate-objects","text":"class AsyncState () Awaitable state.","title":"AsyncState Objects"},{"location":"api/helpers/async_utils/#__init__","text":"def __init__ ( initial_state : Any = None , states_enum : Optional [ Container [ Any ]] = None ) -> None Init async state. Arguments : initial_state : state to set on start. states_enum : container of valid states if not provided state not checked on set.","title":"__init__"},{"location":"api/helpers/async_utils/#set","text":"def set ( state : Any ) -> None Set state.","title":"set"},{"location":"api/helpers/async_utils/#add_callback","text":"def add_callback ( callback_fn : Callable [[ Any ], None ]) -> None Add callback to track state changes. Arguments : callback_fn : callable object to be called on state changed.","title":"add_callback"},{"location":"api/helpers/async_utils/#get","text":"def get () -> Any Get state.","title":"get"},{"location":"api/helpers/async_utils/#wait","text":"async def wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state.","title":"wait"},{"location":"api/helpers/async_utils/#transit","text":"@contextmanager def transit ( initial : Any = not_set , success : Any = not_set , fail : Any = not_set ) -> Generator Change state context according to success or not. Arguments : initial : set state on context enter, not_set by default success : set state on context block done, not_set by default fail : set state on context block raises exception, not_set by default Returns : generator","title":"transit"},{"location":"api/helpers/async_utils/#periodiccaller-objects","text":"class PeriodicCaller () Schedule a periodic call of callable using event loop. Used for periodic function run using asyncio.","title":"PeriodicCaller Objects"},{"location":"api/helpers/async_utils/#__init___1","text":"def __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) -> None Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop","title":"__init__"},{"location":"api/helpers/async_utils/#start","text":"def start () -> None Activate period calls.","title":"start"},{"location":"api/helpers/async_utils/#stop","text":"def stop () -> None Remove from schedule.","title":"stop"},{"location":"api/helpers/async_utils/#anotherthreadtask-objects","text":"class AnotherThreadTask () Schedule a task to run on the loop in another thread. Provides better cancel behaviour: on cancel it will wait till cancelled completely.","title":"AnotherThreadTask Objects"},{"location":"api/helpers/async_utils/#__init___2","text":"def __init__ ( coro : Awaitable , loop : AbstractEventLoop ) -> None Init the task. Arguments : coro : coroutine to schedule loop : an event loop to schedule on.","title":"__init__"},{"location":"api/helpers/async_utils/#result","text":"def result ( timeout : Optional [ float ] = None ) -> Any Wait for coroutine execution result. Arguments : timeout : optional timeout to wait in seconds. Returns : result","title":"result"},{"location":"api/helpers/async_utils/#cancel","text":"def cancel () -> None Cancel coroutine task execution in a target loop.","title":"cancel"},{"location":"api/helpers/async_utils/#done","text":"def done () -> bool Check task is done.","title":"done"},{"location":"api/helpers/async_utils/#threadedasyncrunner-objects","text":"class ThreadedAsyncRunner ( Thread ) Util to run thread with event loop and execute coroutines inside.","title":"ThreadedAsyncRunner Objects"},{"location":"api/helpers/async_utils/#__init___3","text":"def __init__ ( loop : Optional [ AbstractEventLoop ] = None ) -> None Init threaded runner. Arguments : loop : optional event loop. is it's running loop, threaded runner will use it.","title":"__init__"},{"location":"api/helpers/async_utils/#start_1","text":"def start () -> None Start event loop in dedicated thread.","title":"start"},{"location":"api/helpers/async_utils/#run","text":"def run () -> None Run code inside thread.","title":"run"},{"location":"api/helpers/async_utils/#call","text":"def call ( coro : Awaitable ) -> Any Run a coroutine inside the event loop. Arguments : coro : a coroutine to run. Returns : task","title":"call"},{"location":"api/helpers/async_utils/#stop_1","text":"def stop () -> None Stop event loop in thread.","title":"stop"},{"location":"api/helpers/async_utils/#runnable-objects","text":"class Runnable ( ABC ) Abstract Runnable class. Use to run async task in same event loop or in dedicated thread. Provides: start, stop sync methods to start and stop task Use wait_completed to await task was completed.","title":"Runnable Objects"},{"location":"api/helpers/async_utils/#__init___4","text":"def __init__ ( loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init runnable. Arguments : loop : asyncio event loop to use. threaded : bool. start in thread if True.","title":"__init__"},{"location":"api/helpers/async_utils/#start_2","text":"def start () -> bool Start runnable. Returns : bool started or not.","title":"start"},{"location":"api/helpers/async_utils/#is_running","text":"@property def is_running () -> bool Get running state.","title":"is_running"},{"location":"api/helpers/async_utils/#run_1","text":"@abstractmethod async def run () -> Any Implement run logic respectful to CancelError on termination.","title":"run"},{"location":"api/helpers/async_utils/#wait_completed","text":"def wait_completed ( sync : bool = False , timeout : float = None , force_result : bool = False ) -> Awaitable Wait runnable execution completed. Arguments : sync : bool. blocking wait timeout : float seconds force_result : check result even it was waited. Returns : awaitable if sync is False, otherwise None","title":"wait_completed"},{"location":"api/helpers/async_utils/#stop_2","text":"def stop ( force : bool = False ) -> None Stop runnable.","title":"stop"},{"location":"api/helpers/async_utils/#start_and_wait_completed","text":"def start_and_wait_completed ( * args : Any , ** kwargs : Any ) -> Awaitable Alias for start and wait methods.","title":"start_and_wait_completed"},{"location":"api/helpers/base/","text":"aea.helpers.base Miscellaneous helpers. locate def locate ( path : str ) -> Any Locate an object by name or dotted save_path, importing as necessary. load _ module def load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted save_path of the package/module. filepath : the file to the package/module. Raises : ValueError : if the filepath provided is not a module. # noqa: DAR402 Exception : if the execution of the module raises exception. # noqa: DAR402 Returns : module type load _ env _ file def load_env_file ( env_file : str ) -> None Load the content of the environment file into the process environment. Arguments : env_file : save_path to the env file. sigint _ crossplatform def sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to. win _ popen _ kwargs def win_popen_kwargs () -> dict Return kwargs to start a process in windows with new process group. Help to handle ctrl c properly. Return empty dict if platform is not win32 Returns : windows popen kwargs send _ control _ c def send_control_c ( process : subprocess . Popen , kill_group : bool = False ) -> None Send ctrl-C cross-platform to terminate a subprocess. Arguments : process : the process to send the signal to. kill_group : whether or not to kill group RegexConstrainedString Objects class RegexConstrainedString ( UserString ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour. __ init __ def __init__ ( seq : Union [ UserString , str ]) -> None Initialize a regex constrained string. SimpleId Objects class SimpleId ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"an identifier\") Traceback (most recent call last): ... ValueError: Value an identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') IPFSHash Objects class IPFSHash ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"an identifier\") Traceback (most recent call last): ... ValueError: Value an identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') cd @contextlib . contextmanager def cd ( path : PathLike ) -> Generator Change working directory temporarily. get _ logger _ method def get_logger_method ( fn : Callable , logger_method : Union [ str , Callable ]) -> Callable Get logger method for function. Get logger in fn definition module or creates logger is module. name . Or return logger_method if it's callable. Arguments : fn : function to get logger for. logger_method : logger name or callable. Returns : callable to write log with try _ decorator def try_decorator ( error_message : str , default_return : Callable = None , logger_method : Any = \"error\" ) -> Callable Run function, log and return default value on exception. Does not support async or coroutines! Arguments : error_message : message template with one {} for exception default_return : value to return on exception, by default None logger_method : name of the logger method or callable to print logs Returns : the callable MaxRetriesError Objects class MaxRetriesError ( Exception ) Exception for retry decorator. retry _ decorator def retry_decorator ( number_of_retries : int , error_message : str , delay : float = 0 , logger_method : str = \"error\" ) -> Callable Run function with several attempts. Does not support async or coroutines! Arguments : number_of_retries : amount of attempts error_message : message template with one {} for exception delay : number of seconds to sleep between retries. default 0 logger_method : name of the logger method or callable to print logs Returns : the callable exception _ log _ and _ reraise @contextlib . contextmanager def exception_log_and_reraise ( log_method : Callable , message : str ) -> Generator Run code in context to log and re raise exception. Arguments : log_method : function to print log message : message template to add error text. Returns : the generator recursive _ update def recursive_update ( to_update : Dict , new_values : Dict , allow_new_values : bool = False ) -> None Update a dictionary by replacing conflicts with the new values. It does side-effects to the first dictionary. to_update = dict(a=1, b=2, subdict=dict(subfield1=1)) new_values = dict(b=3, subdict=dict(subfield1=2)) recursive_update(to_update, new_values) to_update {'a': 1, 'b': 3, 'subdict': {'subfield1': 2}} Arguments : to_update : the dictionary to update. new_values : the dictionary of new values to replace. allow_new_values : whether or not to allow new values. find _ topological _ order def find_topological_order ( adjacency_list : Dict [ T , Set [ T ]]) -> List [ T ] Compute the topological order of a graph (using Kahn's algorithm). Arguments : adjacency_list : the adjacency list of the graph. Raises : ValueError : if the graph contains a cycle. Returns : the topological order for the graph (as a sequence of nodes) reachable _ nodes def reachable_nodes ( adjacency_list : Dict [ T , Set [ T ]], starting_nodes : Set [ T ]) -> Dict [ T , Set [ T ]] Find the reachable subgraph induced by a set of starting nodes. Arguments : adjacency_list : the adjacency list of the full graph. starting_nodes : the starting nodes of the new graph. Returns : the adjacency list of the subgraph. cached _ property Objects class cached_property () Cached property from python3.8 functools. __ init __ def __init__ ( func : Callable ) -> None Init cached property. __ set _ name __ def __set_name__ ( _ : Any , name : Any ) -> None Set name. __ get __ def __get__ ( instance : Any , _ : Optional [ Any ] = None ) -> Any Get instance. ensure _ dir def ensure_dir ( dir_path : str ) -> None Check if dir_path is a directory or create it. dict _ to _ path _ value def dict_to_path_value ( data : Mapping , path : Optional [ List ] = None ) -> Iterable [ Tuple [ List [ str ], Any ]] Convert dict to sequence of terminal path build of keys and value. parse _ datetime _ from _ str def parse_datetime_from_str ( date_string : str ) -> datetime . datetime Parse datetime from string. CertRequest Objects class CertRequest () Certificate request for proof of representation. __ init __ def __init__ ( public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , save_path : str ) -> None Initialize the certificate request. Arguments : public_key : the public key, or the key id. identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing save_path : the save_path where to save the certificate. public _ key @property def public_key () -> Optional [ str ] Get the public key. ledger _ id @property def ledger_id () -> str Get the ledger id. key _ identifier @property def key_identifier () -> Optional [ str ] Get the key identifier. identifier @property def identifier () -> str Get the identifier. not _ before _ string @property def not_before_string () -> str Get the not_before field as string. not _ after _ string @property def not_after_string () -> str Get the not_after field as string. not _ before @property def not_before () -> datetime . datetime Get the not_before field. not _ after @property def not_after () -> datetime . datetime Get the not_after field. message _ format @property def message_format () -> str Get the message format. save _ path @property def save_path () -> Path Get the save path for the certificate. Note: if the path is not absolute, then the actual save path might depend on the context. Returns : the save path get _ absolute _ save _ path def get_absolute_save_path ( path_prefix : Optional [ PathLike ] = None ) -> Path Get the absolute save path. If save_path is an absolute path, then the prefix is ignored. Otherwise, the path prefix is prepended. Arguments : path_prefix : the (absolute) path to prepend to the save path. Returns : the actual save path. public _ key _ or _ identifier @property def public_key_or_identifier () -> str Get the public key or identifier. get _ message def get_message ( public_key : str ) -> bytes Get the message to sign. construct _ message @classmethod def construct_message ( cls , public_key : str , identifier : SimpleIdOrStr , not_before_string : str , not_after_string : str , message_format : str ) -> bytes Construct message for singning. Arguments : public_key : the public key identifier : identifier to be signed not_before_string : signature not valid before not_after_string : signature not valid after message_format : message format used for signing Returns : the message get _ signature def get_signature ( path_prefix : Optional [ PathLike ] = None ) -> str Get signature from save_path. Arguments : path_prefix : the path prefix to be prepended to save_path. Defaults to cwd. Returns : the signature. json @property def json () -> Dict Compute the JSON representation. from _ json @classmethod def from_json ( cls , obj : Dict ) -> \"CertRequest\" Compute the JSON representation. __ eq __ def __eq__ ( other : Any ) -> bool Check equality. compute _ specifier _ from _ version def compute_specifier_from_version ( version : Version ) -> str Compute the specifier set from a version. version specifier is: >=major.minor.0, <next_major.0.0 Arguments : version : the version Returns : the specifier set decorator _ with _ optional _ params def decorator_with_optional_params ( decorator : Callable ) -> Callable Make a decorator usable either with or without parameters. In other words, if a decorator \"mydecorator\" is decorated with this decorator, It can be used both as: @mydecorator def myfunction(): ... or as: @mydecorator(arg1, kwarg1=\"value\") def myfunction(): ... Arguments : decorator : a decorator callable Returns : a decorator callable delete _ directory _ contents def delete_directory_contents ( directory : Path ) -> None Delete the content of a directory, without deleting it. prepend _ if _ not _ absolute def prepend_if_not_absolute ( path : PathLike , prefix : PathLike ) -> PathLike Prepend a path with a prefix, but only if not absolute Arguments : path : the path to process. prefix : the path prefix. Returns : the same path if absolute, else the prepended path.","title":"Base"},{"location":"api/helpers/base/#aeahelpersbase","text":"Miscellaneous helpers.","title":"aea.helpers.base"},{"location":"api/helpers/base/#locate","text":"def locate ( path : str ) -> Any Locate an object by name or dotted save_path, importing as necessary.","title":"locate"},{"location":"api/helpers/base/#load_module","text":"def load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted save_path of the package/module. filepath : the file to the package/module. Raises : ValueError : if the filepath provided is not a module. # noqa: DAR402 Exception : if the execution of the module raises exception. # noqa: DAR402 Returns : module type","title":"load_module"},{"location":"api/helpers/base/#load_env_file","text":"def load_env_file ( env_file : str ) -> None Load the content of the environment file into the process environment. Arguments : env_file : save_path to the env file.","title":"load_env_file"},{"location":"api/helpers/base/#sigint_crossplatform","text":"def sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to.","title":"sigint_crossplatform"},{"location":"api/helpers/base/#win_popen_kwargs","text":"def win_popen_kwargs () -> dict Return kwargs to start a process in windows with new process group. Help to handle ctrl c properly. Return empty dict if platform is not win32 Returns : windows popen kwargs","title":"win_popen_kwargs"},{"location":"api/helpers/base/#send_control_c","text":"def send_control_c ( process : subprocess . Popen , kill_group : bool = False ) -> None Send ctrl-C cross-platform to terminate a subprocess. Arguments : process : the process to send the signal to. kill_group : whether or not to kill group","title":"send_control_c"},{"location":"api/helpers/base/#regexconstrainedstring-objects","text":"class RegexConstrainedString ( UserString ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour.","title":"RegexConstrainedString Objects"},{"location":"api/helpers/base/#__init__","text":"def __init__ ( seq : Union [ UserString , str ]) -> None Initialize a regex constrained string.","title":"__init__"},{"location":"api/helpers/base/#simpleid-objects","text":"class SimpleId ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"an identifier\") Traceback (most recent call last): ... ValueError: Value an identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}')","title":"SimpleId Objects"},{"location":"api/helpers/base/#ipfshash-objects","text":"class IPFSHash ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"an identifier\") Traceback (most recent call last): ... ValueError: Value an identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}')","title":"IPFSHash Objects"},{"location":"api/helpers/base/#cd","text":"@contextlib . contextmanager def cd ( path : PathLike ) -> Generator Change working directory temporarily.","title":"cd"},{"location":"api/helpers/base/#get_logger_method","text":"def get_logger_method ( fn : Callable , logger_method : Union [ str , Callable ]) -> Callable Get logger method for function. Get logger in fn definition module or creates logger is module. name . Or return logger_method if it's callable. Arguments : fn : function to get logger for. logger_method : logger name or callable. Returns : callable to write log with","title":"get_logger_method"},{"location":"api/helpers/base/#try_decorator","text":"def try_decorator ( error_message : str , default_return : Callable = None , logger_method : Any = \"error\" ) -> Callable Run function, log and return default value on exception. Does not support async or coroutines! Arguments : error_message : message template with one {} for exception default_return : value to return on exception, by default None logger_method : name of the logger method or callable to print logs Returns : the callable","title":"try_decorator"},{"location":"api/helpers/base/#maxretrieserror-objects","text":"class MaxRetriesError ( Exception ) Exception for retry decorator.","title":"MaxRetriesError Objects"},{"location":"api/helpers/base/#retry_decorator","text":"def retry_decorator ( number_of_retries : int , error_message : str , delay : float = 0 , logger_method : str = \"error\" ) -> Callable Run function with several attempts. Does not support async or coroutines! Arguments : number_of_retries : amount of attempts error_message : message template with one {} for exception delay : number of seconds to sleep between retries. default 0 logger_method : name of the logger method or callable to print logs Returns : the callable","title":"retry_decorator"},{"location":"api/helpers/base/#exception_log_and_reraise","text":"@contextlib . contextmanager def exception_log_and_reraise ( log_method : Callable , message : str ) -> Generator Run code in context to log and re raise exception. Arguments : log_method : function to print log message : message template to add error text. Returns : the generator","title":"exception_log_and_reraise"},{"location":"api/helpers/base/#recursive_update","text":"def recursive_update ( to_update : Dict , new_values : Dict , allow_new_values : bool = False ) -> None Update a dictionary by replacing conflicts with the new values. It does side-effects to the first dictionary. to_update = dict(a=1, b=2, subdict=dict(subfield1=1)) new_values = dict(b=3, subdict=dict(subfield1=2)) recursive_update(to_update, new_values) to_update {'a': 1, 'b': 3, 'subdict': {'subfield1': 2}} Arguments : to_update : the dictionary to update. new_values : the dictionary of new values to replace. allow_new_values : whether or not to allow new values.","title":"recursive_update"},{"location":"api/helpers/base/#find_topological_order","text":"def find_topological_order ( adjacency_list : Dict [ T , Set [ T ]]) -> List [ T ] Compute the topological order of a graph (using Kahn's algorithm). Arguments : adjacency_list : the adjacency list of the graph. Raises : ValueError : if the graph contains a cycle. Returns : the topological order for the graph (as a sequence of nodes)","title":"find_topological_order"},{"location":"api/helpers/base/#reachable_nodes","text":"def reachable_nodes ( adjacency_list : Dict [ T , Set [ T ]], starting_nodes : Set [ T ]) -> Dict [ T , Set [ T ]] Find the reachable subgraph induced by a set of starting nodes. Arguments : adjacency_list : the adjacency list of the full graph. starting_nodes : the starting nodes of the new graph. Returns : the adjacency list of the subgraph.","title":"reachable_nodes"},{"location":"api/helpers/base/#cached_property-objects","text":"class cached_property () Cached property from python3.8 functools.","title":"cached_property Objects"},{"location":"api/helpers/base/#__init___1","text":"def __init__ ( func : Callable ) -> None Init cached property.","title":"__init__"},{"location":"api/helpers/base/#__set_name__","text":"def __set_name__ ( _ : Any , name : Any ) -> None Set name.","title":"__set_name__"},{"location":"api/helpers/base/#__get__","text":"def __get__ ( instance : Any , _ : Optional [ Any ] = None ) -> Any Get instance.","title":"__get__"},{"location":"api/helpers/base/#ensure_dir","text":"def ensure_dir ( dir_path : str ) -> None Check if dir_path is a directory or create it.","title":"ensure_dir"},{"location":"api/helpers/base/#dict_to_path_value","text":"def dict_to_path_value ( data : Mapping , path : Optional [ List ] = None ) -> Iterable [ Tuple [ List [ str ], Any ]] Convert dict to sequence of terminal path build of keys and value.","title":"dict_to_path_value"},{"location":"api/helpers/base/#parse_datetime_from_str","text":"def parse_datetime_from_str ( date_string : str ) -> datetime . datetime Parse datetime from string.","title":"parse_datetime_from_str"},{"location":"api/helpers/base/#certrequest-objects","text":"class CertRequest () Certificate request for proof of representation.","title":"CertRequest Objects"},{"location":"api/helpers/base/#__init___2","text":"def __init__ ( public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , save_path : str ) -> None Initialize the certificate request. Arguments : public_key : the public key, or the key id. identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing save_path : the save_path where to save the certificate.","title":"__init__"},{"location":"api/helpers/base/#public_key","text":"@property def public_key () -> Optional [ str ] Get the public key.","title":"public_key"},{"location":"api/helpers/base/#ledger_id","text":"@property def ledger_id () -> str Get the ledger id.","title":"ledger_id"},{"location":"api/helpers/base/#key_identifier","text":"@property def key_identifier () -> Optional [ str ] Get the key identifier.","title":"key_identifier"},{"location":"api/helpers/base/#identifier","text":"@property def identifier () -> str Get the identifier.","title":"identifier"},{"location":"api/helpers/base/#not_before_string","text":"@property def not_before_string () -> str Get the not_before field as string.","title":"not_before_string"},{"location":"api/helpers/base/#not_after_string","text":"@property def not_after_string () -> str Get the not_after field as string.","title":"not_after_string"},{"location":"api/helpers/base/#not_before","text":"@property def not_before () -> datetime . datetime Get the not_before field.","title":"not_before"},{"location":"api/helpers/base/#not_after","text":"@property def not_after () -> datetime . datetime Get the not_after field.","title":"not_after"},{"location":"api/helpers/base/#message_format","text":"@property def message_format () -> str Get the message format.","title":"message_format"},{"location":"api/helpers/base/#save_path","text":"@property def save_path () -> Path Get the save path for the certificate. Note: if the path is not absolute, then the actual save path might depend on the context. Returns : the save path","title":"save_path"},{"location":"api/helpers/base/#get_absolute_save_path","text":"def get_absolute_save_path ( path_prefix : Optional [ PathLike ] = None ) -> Path Get the absolute save path. If save_path is an absolute path, then the prefix is ignored. Otherwise, the path prefix is prepended. Arguments : path_prefix : the (absolute) path to prepend to the save path. Returns : the actual save path.","title":"get_absolute_save_path"},{"location":"api/helpers/base/#public_key_or_identifier","text":"@property def public_key_or_identifier () -> str Get the public key or identifier.","title":"public_key_or_identifier"},{"location":"api/helpers/base/#get_message","text":"def get_message ( public_key : str ) -> bytes Get the message to sign.","title":"get_message"},{"location":"api/helpers/base/#construct_message","text":"@classmethod def construct_message ( cls , public_key : str , identifier : SimpleIdOrStr , not_before_string : str , not_after_string : str , message_format : str ) -> bytes Construct message for singning. Arguments : public_key : the public key identifier : identifier to be signed not_before_string : signature not valid before not_after_string : signature not valid after message_format : message format used for signing Returns : the message","title":"construct_message"},{"location":"api/helpers/base/#get_signature","text":"def get_signature ( path_prefix : Optional [ PathLike ] = None ) -> str Get signature from save_path. Arguments : path_prefix : the path prefix to be prepended to save_path. Defaults to cwd. Returns : the signature.","title":"get_signature"},{"location":"api/helpers/base/#json","text":"@property def json () -> Dict Compute the JSON representation.","title":"json"},{"location":"api/helpers/base/#from_json","text":"@classmethod def from_json ( cls , obj : Dict ) -> \"CertRequest\" Compute the JSON representation.","title":"from_json"},{"location":"api/helpers/base/#__eq__","text":"def __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"api/helpers/base/#compute_specifier_from_version","text":"def compute_specifier_from_version ( version : Version ) -> str Compute the specifier set from a version. version specifier is: >=major.minor.0, <next_major.0.0 Arguments : version : the version Returns : the specifier set","title":"compute_specifier_from_version"},{"location":"api/helpers/base/#decorator_with_optional_params","text":"def decorator_with_optional_params ( decorator : Callable ) -> Callable Make a decorator usable either with or without parameters. In other words, if a decorator \"mydecorator\" is decorated with this decorator, It can be used both as: @mydecorator def myfunction(): ... or as: @mydecorator(arg1, kwarg1=\"value\") def myfunction(): ... Arguments : decorator : a decorator callable Returns : a decorator callable","title":"decorator_with_optional_params"},{"location":"api/helpers/base/#delete_directory_contents","text":"def delete_directory_contents ( directory : Path ) -> None Delete the content of a directory, without deleting it.","title":"delete_directory_contents"},{"location":"api/helpers/base/#prepend_if_not_absolute","text":"def prepend_if_not_absolute ( path : PathLike , prefix : PathLike ) -> PathLike Prepend a path with a prefix, but only if not absolute Arguments : path : the path to process. prefix : the path prefix. Returns : the same path if absolute, else the prepended path.","title":"prepend_if_not_absolute"},{"location":"api/helpers/constants/","text":"aea.helpers.constants Module with helpers constants.","title":"Constants"},{"location":"api/helpers/constants/#aeahelpersconstants","text":"Module with helpers constants.","title":"aea.helpers.constants"},{"location":"api/helpers/dependency_tree/","text":"aea.helpers.dependency _ tree This module contains the code to generate dependency trees from registries. load _ yaml def load_yaml ( file_path : Path ) -> Tuple [ Dict , List [ Dict ]] Load yaml file. dump _ yaml def dump_yaml ( file_path : Path , data : Dict , extra_data : Optional [ List [ Dict ]] = None ) -> None Dump yaml file. without _ hash def without_hash ( public_id : str ) -> PublicId Convert to public id. to _ plural def to_plural ( string : str ) -> str Convert component to plural reduce _ sets def reduce_sets ( list_of_sets : List [ Set ]) -> Set [ PackageId ] Reduce a list of sets to one dimentional set. to _ package _ id def to_package_id ( public_id : str , package_type : str ) -> PackageId Convert to public id. DependecyTree Objects class DependecyTree () This class represents the dependency tree for a registry. get _ all _ dependencies @staticmethod def get_all_dependencies ( item_config : Dict ) -> List [ PackageId ] Returns a list of all available dependencies. resolve _ tree @classmethod def resolve_tree ( cls , dependency_list : Dict [ PackageId , List [ PackageId ]], tree : Dict ) -> None Resolve dependency tree flatten _ tree @classmethod def flatten_tree ( cls , dependency_tree : Dict , flat_tree : List [ List [ PackageId ]], level : int ) -> None Flatten tree. generate @classmethod def generate ( cls , packages_dir : Path ) -> List [ List [ PackageId ]] Returns PublicId to hash mapping.","title":"Dependency Tree"},{"location":"api/helpers/dependency_tree/#aeahelpersdependency_tree","text":"This module contains the code to generate dependency trees from registries.","title":"aea.helpers.dependency_tree"},{"location":"api/helpers/dependency_tree/#load_yaml","text":"def load_yaml ( file_path : Path ) -> Tuple [ Dict , List [ Dict ]] Load yaml file.","title":"load_yaml"},{"location":"api/helpers/dependency_tree/#dump_yaml","text":"def dump_yaml ( file_path : Path , data : Dict , extra_data : Optional [ List [ Dict ]] = None ) -> None Dump yaml file.","title":"dump_yaml"},{"location":"api/helpers/dependency_tree/#without_hash","text":"def without_hash ( public_id : str ) -> PublicId Convert to public id.","title":"without_hash"},{"location":"api/helpers/dependency_tree/#to_plural","text":"def to_plural ( string : str ) -> str Convert component to plural","title":"to_plural"},{"location":"api/helpers/dependency_tree/#reduce_sets","text":"def reduce_sets ( list_of_sets : List [ Set ]) -> Set [ PackageId ] Reduce a list of sets to one dimentional set.","title":"reduce_sets"},{"location":"api/helpers/dependency_tree/#to_package_id","text":"def to_package_id ( public_id : str , package_type : str ) -> PackageId Convert to public id.","title":"to_package_id"},{"location":"api/helpers/dependency_tree/#dependecytree-objects","text":"class DependecyTree () This class represents the dependency tree for a registry.","title":"DependecyTree Objects"},{"location":"api/helpers/dependency_tree/#get_all_dependencies","text":"@staticmethod def get_all_dependencies ( item_config : Dict ) -> List [ PackageId ] Returns a list of all available dependencies.","title":"get_all_dependencies"},{"location":"api/helpers/dependency_tree/#resolve_tree","text":"@classmethod def resolve_tree ( cls , dependency_list : Dict [ PackageId , List [ PackageId ]], tree : Dict ) -> None Resolve dependency tree","title":"resolve_tree"},{"location":"api/helpers/dependency_tree/#flatten_tree","text":"@classmethod def flatten_tree ( cls , dependency_tree : Dict , flat_tree : List [ List [ PackageId ]], level : int ) -> None Flatten tree.","title":"flatten_tree"},{"location":"api/helpers/dependency_tree/#generate","text":"@classmethod def generate ( cls , packages_dir : Path ) -> List [ List [ PackageId ]] Returns PublicId to hash mapping.","title":"generate"},{"location":"api/helpers/env_vars/","text":"aea.helpers.env _ vars Implementation of the environment variables support. is _ env _ variable def is_env_variable ( value : Any ) -> bool Check is variable string with env variable pattern. replace _ with _ env _ var def replace_with_env_var ( value : str , env_variables : dict , default_value : Any = NotSet ) -> JSON_TYPES Replace env var with value. apply _ env _ variables def apply_env_variables ( data : Union [ Dict , List [ Dict ]], env_variables : Mapping [ str , Any ], default_value : Any = NotSet ) -> JSON_TYPES Create new resulting dict with env variables applied. convert _ value _ str _ to _ type def convert_value_str_to_type ( value : str , type_str : str ) -> JSON_TYPES Convert value by type name to native python type.","title":"Env Vars"},{"location":"api/helpers/env_vars/#aeahelpersenv_vars","text":"Implementation of the environment variables support.","title":"aea.helpers.env_vars"},{"location":"api/helpers/env_vars/#is_env_variable","text":"def is_env_variable ( value : Any ) -> bool Check is variable string with env variable pattern.","title":"is_env_variable"},{"location":"api/helpers/env_vars/#replace_with_env_var","text":"def replace_with_env_var ( value : str , env_variables : dict , default_value : Any = NotSet ) -> JSON_TYPES Replace env var with value.","title":"replace_with_env_var"},{"location":"api/helpers/env_vars/#apply_env_variables","text":"def apply_env_variables ( data : Union [ Dict , List [ Dict ]], env_variables : Mapping [ str , Any ], default_value : Any = NotSet ) -> JSON_TYPES Create new resulting dict with env variables applied.","title":"apply_env_variables"},{"location":"api/helpers/env_vars/#convert_value_str_to_type","text":"def convert_value_str_to_type ( value : str , type_str : str ) -> JSON_TYPES Convert value by type name to native python type.","title":"convert_value_str_to_type"},{"location":"api/helpers/exception_policy/","text":"aea.helpers.exception _ policy This module contains enum of aea exception policies. ExceptionPolicyEnum Objects class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"Exception Policy"},{"location":"api/helpers/exception_policy/#aeahelpersexception_policy","text":"This module contains enum of aea exception policies.","title":"aea.helpers.exception_policy"},{"location":"api/helpers/exception_policy/#exceptionpolicyenum-objects","text":"class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"ExceptionPolicyEnum Objects"},{"location":"api/helpers/exec_timeout/","text":"aea.helpers.exec _ timeout Python code execution time limit tools. TimeoutResult Objects class TimeoutResult () Result of ExecTimeout context manager. __ init __ def __init__ () -> None Init. set _ cancelled _ by _ timeout def set_cancelled_by_timeout () -> None Set code was terminated cause timeout. is _ cancelled _ by _ timeout def is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool TimeoutException Objects class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager BaseExecTimeout Objects class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout. __ init __ def __init__ ( timeout : float = 0.0 ) -> None Init. Arguments : timeout : number of seconds to execute code before interruption __ enter __ def __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult __ exit __ def __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Arguments : exc_type : the exception type exc_val : the exception exc_tb : the traceback ExecTimeoutSigAlarm Objects class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread. ExecTimeoutThreadGuard Objects class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled. __ init __ def __init__ ( timeout : float = 0.0 ) -> None Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption start @classmethod def start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted. stop @classmethod def stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start.","title":"Exec Timeout"},{"location":"api/helpers/exec_timeout/#aeahelpersexec_timeout","text":"Python code execution time limit tools.","title":"aea.helpers.exec_timeout"},{"location":"api/helpers/exec_timeout/#timeoutresult-objects","text":"class TimeoutResult () Result of ExecTimeout context manager.","title":"TimeoutResult Objects"},{"location":"api/helpers/exec_timeout/#__init__","text":"def __init__ () -> None Init.","title":"__init__"},{"location":"api/helpers/exec_timeout/#set_cancelled_by_timeout","text":"def set_cancelled_by_timeout () -> None Set code was terminated cause timeout.","title":"set_cancelled_by_timeout"},{"location":"api/helpers/exec_timeout/#is_cancelled_by_timeout","text":"def is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool","title":"is_cancelled_by_timeout"},{"location":"api/helpers/exec_timeout/#timeoutexception-objects","text":"class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager","title":"TimeoutException Objects"},{"location":"api/helpers/exec_timeout/#baseexectimeout-objects","text":"class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout.","title":"BaseExecTimeout Objects"},{"location":"api/helpers/exec_timeout/#__init___1","text":"def __init__ ( timeout : float = 0.0 ) -> None Init. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"api/helpers/exec_timeout/#__enter__","text":"def __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult","title":"__enter__"},{"location":"api/helpers/exec_timeout/#__exit__","text":"def __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Arguments : exc_type : the exception type exc_val : the exception exc_tb : the traceback","title":"__exit__"},{"location":"api/helpers/exec_timeout/#exectimeoutsigalarm-objects","text":"class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread.","title":"ExecTimeoutSigAlarm Objects"},{"location":"api/helpers/exec_timeout/#exectimeoutthreadguard-objects","text":"class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled.","title":"ExecTimeoutThreadGuard Objects"},{"location":"api/helpers/exec_timeout/#__init___2","text":"def __init__ ( timeout : float = 0.0 ) -> None Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"api/helpers/exec_timeout/#start","text":"@classmethod def start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted.","title":"start"},{"location":"api/helpers/exec_timeout/#stop","text":"@classmethod def stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start.","title":"stop"},{"location":"api/helpers/file_io/","text":"aea.helpers.file _ io Read to and write from file with envelopes. lock _ file @contextmanager def lock_file ( file_descriptor : IO [ bytes ], logger : Logger = _default_logger ) -> Generator Lock file in context manager. Arguments : file_descriptor : file descriptor of file to lock. logger : the logger. Returns : generator write _ envelope def write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ], separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> None Write envelope to file. write _ with _ lock def write_with_lock ( file_pointer : IO [ bytes ], data : Union [ bytes ], logger : Logger = _default_logger ) -> None Write bytes to file protected with file lock. envelope _ from _ bytes def envelope_from_bytes ( bytes_ : bytes , separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> Optional [ Envelope ] Decode bytes to get the envelope. Arguments : bytes_ : the encoded envelope separator : the separator used logger : the logger Returns : Envelope","title":"File IO"},{"location":"api/helpers/file_io/#aeahelpersfile_io","text":"Read to and write from file with envelopes.","title":"aea.helpers.file_io"},{"location":"api/helpers/file_io/#lock_file","text":"@contextmanager def lock_file ( file_descriptor : IO [ bytes ], logger : Logger = _default_logger ) -> Generator Lock file in context manager. Arguments : file_descriptor : file descriptor of file to lock. logger : the logger. Returns : generator","title":"lock_file"},{"location":"api/helpers/file_io/#write_envelope","text":"def write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ], separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> None Write envelope to file.","title":"write_envelope"},{"location":"api/helpers/file_io/#write_with_lock","text":"def write_with_lock ( file_pointer : IO [ bytes ], data : Union [ bytes ], logger : Logger = _default_logger ) -> None Write bytes to file protected with file lock.","title":"write_with_lock"},{"location":"api/helpers/file_io/#envelope_from_bytes","text":"def envelope_from_bytes ( bytes_ : bytes , separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> Optional [ Envelope ] Decode bytes to get the envelope. Arguments : bytes_ : the encoded envelope separator : the separator used logger : the logger Returns : Envelope","title":"envelope_from_bytes"},{"location":"api/helpers/file_lock/","text":"aea.helpers.file _ lock Patch of 'fnctl' to make it compatible with Windows.","title":"File Lock"},{"location":"api/helpers/file_lock/#aeahelpersfile_lock","text":"Patch of 'fnctl' to make it compatible with Windows.","title":"aea.helpers.file_lock"},{"location":"api/helpers/git/","text":"aea.helpers.git Useful git tools. check _ working _ tree _ is _ dirty def check_working_tree_is_dirty () -> None Check if the current Git working tree is dirty.","title":"Git"},{"location":"api/helpers/git/#aeahelpersgit","text":"Useful git tools.","title":"aea.helpers.git"},{"location":"api/helpers/git/#check_working_tree_is_dirty","text":"def check_working_tree_is_dirty () -> None Check if the current Git working tree is dirty.","title":"check_working_tree_is_dirty"},{"location":"api/helpers/http_requests/","text":"aea.helpers.http _ requests Wrapper over requests library. add _ default _ timeout def add_default_timeout ( fn : Callable , timeout : float ) -> Callable Add default timeout for requests methods.","title":"HttpRequests"},{"location":"api/helpers/http_requests/#aeahelpershttp_requests","text":"Wrapper over requests library.","title":"aea.helpers.http_requests"},{"location":"api/helpers/http_requests/#add_default_timeout","text":"def add_default_timeout ( fn : Callable , timeout : float ) -> Callable Add default timeout for requests methods.","title":"add_default_timeout"},{"location":"api/helpers/install_dependency/","text":"aea.helpers.install _ dependency Helper to install python dependencies. install _ dependency def install_dependency ( dependency_name : str , dependency : Dependency , logger : Logger , install_timeout : float = 300 ) -> None Install python dependency to the current python environment. Arguments : dependency_name : name of the python package dependency : Dependency specification logger : the logger install_timeout : timeout to wait pip to install install _ dependencies def install_dependencies ( dependencies : List [ Dependency ], logger : Logger , install_timeout : float = 300 ) -> None Install python dependencies to the current python environment. Arguments : dependencies : dict of dependency name and specification logger : the logger install_timeout : timeout to wait pip to install call _ pip def call_pip ( pip_args : List [ str ], timeout : float = 300 , retry : bool = False ) -> None Run pip install command. Arguments : pip_args : list strings of the command timeout : timeout to wait pip to install retry : bool, try one more time if command failed run _ install _ subprocess def run_install_subprocess ( install_command : List [ str ], install_timeout : float = 300 ) -> int Try executing install command. Arguments : install_command : list strings of the command install_timeout : timeout to wait pip to install Returns : the return code of the subprocess","title":"Install Dependency"},{"location":"api/helpers/install_dependency/#aeahelpersinstall_dependency","text":"Helper to install python dependencies.","title":"aea.helpers.install_dependency"},{"location":"api/helpers/install_dependency/#install_dependency","text":"def install_dependency ( dependency_name : str , dependency : Dependency , logger : Logger , install_timeout : float = 300 ) -> None Install python dependency to the current python environment. Arguments : dependency_name : name of the python package dependency : Dependency specification logger : the logger install_timeout : timeout to wait pip to install","title":"install_dependency"},{"location":"api/helpers/install_dependency/#install_dependencies","text":"def install_dependencies ( dependencies : List [ Dependency ], logger : Logger , install_timeout : float = 300 ) -> None Install python dependencies to the current python environment. Arguments : dependencies : dict of dependency name and specification logger : the logger install_timeout : timeout to wait pip to install","title":"install_dependencies"},{"location":"api/helpers/install_dependency/#call_pip","text":"def call_pip ( pip_args : List [ str ], timeout : float = 300 , retry : bool = False ) -> None Run pip install command. Arguments : pip_args : list strings of the command timeout : timeout to wait pip to install retry : bool, try one more time if command failed","title":"call_pip"},{"location":"api/helpers/install_dependency/#run_install_subprocess","text":"def run_install_subprocess ( install_command : List [ str ], install_timeout : float = 300 ) -> int Try executing install command. Arguments : install_command : list strings of the command install_timeout : timeout to wait pip to install Returns : the return code of the subprocess","title":"run_install_subprocess"},{"location":"api/helpers/io/","text":"aea.helpers.io","title":"IO"},{"location":"api/helpers/io/#aeahelpersio","text":"","title":"aea.helpers.io"},{"location":"api/helpers/logging/","text":"aea.helpers.logging Logging helpers. get _ logger def get_logger ( module_path : str , agent_name : str ) -> Logger Get the logger based on a module path and agent name. AgentLoggerAdapter Objects class AgentLoggerAdapter ( LoggerAdapter ) This class is a logger adapter that prepends the agent name to log messages. __ init __ def __init__ ( logger : Logger , agent_name : str ) -> None Initialize the logger adapter. Arguments : logger : the logger. agent_name : the agent name. process def process ( msg : Any , kwargs : MutableMapping [ str , Any ]) -> Tuple [ Any , MutableMapping [ str , Any ]] Prepend the agent name to every log message. WithLogger Objects class WithLogger () Interface to endow subclasses with a logger. __ init __ def __init__ ( logger : Optional [ Logger ] = None , default_logger_name : str = \"aea\" ) -> None Initialize the logger. Arguments : logger : the logger object. default_logger_name : the default logger name, if a logger is not provided. logger @property def logger () -> Logger Get the component logger. logger @logger . setter def logger ( logger : Optional [ Logger ]) -> None Set the logger.","title":"Logging"},{"location":"api/helpers/logging/#aeahelperslogging","text":"Logging helpers.","title":"aea.helpers.logging"},{"location":"api/helpers/logging/#get_logger","text":"def get_logger ( module_path : str , agent_name : str ) -> Logger Get the logger based on a module path and agent name.","title":"get_logger"},{"location":"api/helpers/logging/#agentloggeradapter-objects","text":"class AgentLoggerAdapter ( LoggerAdapter ) This class is a logger adapter that prepends the agent name to log messages.","title":"AgentLoggerAdapter Objects"},{"location":"api/helpers/logging/#__init__","text":"def __init__ ( logger : Logger , agent_name : str ) -> None Initialize the logger adapter. Arguments : logger : the logger. agent_name : the agent name.","title":"__init__"},{"location":"api/helpers/logging/#process","text":"def process ( msg : Any , kwargs : MutableMapping [ str , Any ]) -> Tuple [ Any , MutableMapping [ str , Any ]] Prepend the agent name to every log message.","title":"process"},{"location":"api/helpers/logging/#withlogger-objects","text":"class WithLogger () Interface to endow subclasses with a logger.","title":"WithLogger Objects"},{"location":"api/helpers/logging/#__init___1","text":"def __init__ ( logger : Optional [ Logger ] = None , default_logger_name : str = \"aea\" ) -> None Initialize the logger. Arguments : logger : the logger object. default_logger_name : the default logger name, if a logger is not provided.","title":"__init__"},{"location":"api/helpers/logging/#logger","text":"@property def logger () -> Logger Get the component logger.","title":"logger"},{"location":"api/helpers/logging/#logger_1","text":"@logger . setter def logger ( logger : Optional [ Logger ]) -> None Set the logger.","title":"logger"},{"location":"api/helpers/multiple_executor/","text":"aea.helpers.multiple _ executor This module contains the helpers to run multiple stoppable tasks in different modes: async, threaded, multiprocess . ExecutorExceptionPolicies Objects class ExecutorExceptionPolicies ( Enum ) Runner exception policy modes. AbstractExecutorTask Objects class AbstractExecutorTask ( ABC ) Abstract task class to create Task classes. __ init __ def __init__ () -> None Init task. future @property def future () -> Optional [ TaskAwaitable ] Return awaitable to get result of task execution. future @future . setter def future ( future : TaskAwaitable ) -> None Set awaitable to get result of task execution. start @abstractmethod def start () -> Tuple [ Callable , Sequence [ Any ]] Implement start task function here. stop @abstractmethod def stop () -> None Implement stop task function here. create _ async _ task @abstractmethod def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Arguments : loop : the event loop Returns : task to run in asyncio loop. id @property def id () -> Any Return task id. failed @property def failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool AbstractMultiprocessExecutorTask Objects class AbstractMultiprocessExecutorTask ( AbstractExecutorTask ) Task for multiprocess executor. start @abstractmethod def start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess. create _ async _ task def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Raise error, cause async mode is not supported, cause this task for multiprocess executor only. Arguments : loop : the event loop Raises : ValueError : async task construction not possible AbstractMultipleExecutor Objects class AbstractMultipleExecutor ( ABC ) Abstract class to create multiple executors classes. __ init __ def __init__ ( tasks : Sequence [ AbstractExecutorTask ], task_fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init executor. Arguments : tasks : sequence of AbstractExecutorTask instances to run. task_fail_policy : the exception policy of all the tasks is _ running @property def is_running () -> bool Return running state of the executor. start def start () -> None Start tasks. stop def stop () -> None Stop tasks. num _ failed @property def num_failed () -> int Return number of failed tasks. failed _ tasks @property def failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence failed tasks. not _ failed _ tasks @property def not_failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence successful tasks. ThreadExecutor Objects class ThreadExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads. ProcessExecutor Objects class ProcessExecutor ( ThreadExecutor ) Subprocess based executor to run multiple agents in threads. AsyncExecutor Objects class AsyncExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads. AbstractMultipleRunner Objects class AbstractMultipleRunner () Abstract multiple runner to create classes to launch tasks with selected mode. __ init __ def __init__ ( mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init with selected executor mode. Arguments : mode : one of supported executor modes fail_policy : one of ExecutorExceptionPolicies to be used with Executor is _ running @property def is_running () -> bool Return state of the executor. start def start ( threaded : bool = False ) -> None Run agents. Arguments : threaded : run in dedicated thread without blocking current thread. stop def stop ( timeout : Optional [ float ] = None ) -> None Stop agents. Arguments : timeout : timeout in seconds to wait thread stopped, only if started in thread mode. num _ failed @property def num_failed () -> int Return number of failed tasks. failed @property def failed () -> Sequence [ Task ] Return sequence failed tasks. not _ failed @property def not_failed () -> Sequence [ Task ] Return sequence successful tasks. try _ join _ thread def try_join_thread () -> None Try to join thread if running in thread mode.","title":"MultipleExecutor"},{"location":"api/helpers/multiple_executor/#aeahelpersmultiple_executor","text":"This module contains the helpers to run multiple stoppable tasks in different modes: async, threaded, multiprocess .","title":"aea.helpers.multiple_executor"},{"location":"api/helpers/multiple_executor/#executorexceptionpolicies-objects","text":"class ExecutorExceptionPolicies ( Enum ) Runner exception policy modes.","title":"ExecutorExceptionPolicies Objects"},{"location":"api/helpers/multiple_executor/#abstractexecutortask-objects","text":"class AbstractExecutorTask ( ABC ) Abstract task class to create Task classes.","title":"AbstractExecutorTask Objects"},{"location":"api/helpers/multiple_executor/#__init__","text":"def __init__ () -> None Init task.","title":"__init__"},{"location":"api/helpers/multiple_executor/#future","text":"@property def future () -> Optional [ TaskAwaitable ] Return awaitable to get result of task execution.","title":"future"},{"location":"api/helpers/multiple_executor/#future_1","text":"@future . setter def future ( future : TaskAwaitable ) -> None Set awaitable to get result of task execution.","title":"future"},{"location":"api/helpers/multiple_executor/#start","text":"@abstractmethod def start () -> Tuple [ Callable , Sequence [ Any ]] Implement start task function here.","title":"start"},{"location":"api/helpers/multiple_executor/#stop","text":"@abstractmethod def stop () -> None Implement stop task function here.","title":"stop"},{"location":"api/helpers/multiple_executor/#create_async_task","text":"@abstractmethod def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Arguments : loop : the event loop Returns : task to run in asyncio loop.","title":"create_async_task"},{"location":"api/helpers/multiple_executor/#id","text":"@property def id () -> Any Return task id.","title":"id"},{"location":"api/helpers/multiple_executor/#failed","text":"@property def failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool","title":"failed"},{"location":"api/helpers/multiple_executor/#abstractmultiprocessexecutortask-objects","text":"class AbstractMultiprocessExecutorTask ( AbstractExecutorTask ) Task for multiprocess executor.","title":"AbstractMultiprocessExecutorTask Objects"},{"location":"api/helpers/multiple_executor/#start_1","text":"@abstractmethod def start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess.","title":"start"},{"location":"api/helpers/multiple_executor/#create_async_task_1","text":"def create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Raise error, cause async mode is not supported, cause this task for multiprocess executor only. Arguments : loop : the event loop Raises : ValueError : async task construction not possible","title":"create_async_task"},{"location":"api/helpers/multiple_executor/#abstractmultipleexecutor-objects","text":"class AbstractMultipleExecutor ( ABC ) Abstract class to create multiple executors classes.","title":"AbstractMultipleExecutor Objects"},{"location":"api/helpers/multiple_executor/#__init___1","text":"def __init__ ( tasks : Sequence [ AbstractExecutorTask ], task_fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init executor. Arguments : tasks : sequence of AbstractExecutorTask instances to run. task_fail_policy : the exception policy of all the tasks","title":"__init__"},{"location":"api/helpers/multiple_executor/#is_running","text":"@property def is_running () -> bool Return running state of the executor.","title":"is_running"},{"location":"api/helpers/multiple_executor/#start_2","text":"def start () -> None Start tasks.","title":"start"},{"location":"api/helpers/multiple_executor/#stop_1","text":"def stop () -> None Stop tasks.","title":"stop"},{"location":"api/helpers/multiple_executor/#num_failed","text":"@property def num_failed () -> int Return number of failed tasks.","title":"num_failed"},{"location":"api/helpers/multiple_executor/#failed_tasks","text":"@property def failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence failed tasks.","title":"failed_tasks"},{"location":"api/helpers/multiple_executor/#not_failed_tasks","text":"@property def not_failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence successful tasks.","title":"not_failed_tasks"},{"location":"api/helpers/multiple_executor/#threadexecutor-objects","text":"class ThreadExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads.","title":"ThreadExecutor Objects"},{"location":"api/helpers/multiple_executor/#processexecutor-objects","text":"class ProcessExecutor ( ThreadExecutor ) Subprocess based executor to run multiple agents in threads.","title":"ProcessExecutor Objects"},{"location":"api/helpers/multiple_executor/#asyncexecutor-objects","text":"class AsyncExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads.","title":"AsyncExecutor Objects"},{"location":"api/helpers/multiple_executor/#abstractmultiplerunner-objects","text":"class AbstractMultipleRunner () Abstract multiple runner to create classes to launch tasks with selected mode.","title":"AbstractMultipleRunner Objects"},{"location":"api/helpers/multiple_executor/#__init___2","text":"def __init__ ( mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init with selected executor mode. Arguments : mode : one of supported executor modes fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"__init__"},{"location":"api/helpers/multiple_executor/#is_running_1","text":"@property def is_running () -> bool Return state of the executor.","title":"is_running"},{"location":"api/helpers/multiple_executor/#start_3","text":"def start ( threaded : bool = False ) -> None Run agents. Arguments : threaded : run in dedicated thread without blocking current thread.","title":"start"},{"location":"api/helpers/multiple_executor/#stop_2","text":"def stop ( timeout : Optional [ float ] = None ) -> None Stop agents. Arguments : timeout : timeout in seconds to wait thread stopped, only if started in thread mode.","title":"stop"},{"location":"api/helpers/multiple_executor/#num_failed_1","text":"@property def num_failed () -> int Return number of failed tasks.","title":"num_failed"},{"location":"api/helpers/multiple_executor/#failed_1","text":"@property def failed () -> Sequence [ Task ] Return sequence failed tasks.","title":"failed"},{"location":"api/helpers/multiple_executor/#not_failed","text":"@property def not_failed () -> Sequence [ Task ] Return sequence successful tasks.","title":"not_failed"},{"location":"api/helpers/multiple_executor/#try_join_thread","text":"def try_join_thread () -> None Try to join thread if running in thread mode.","title":"try_join_thread"},{"location":"api/helpers/pipe/","text":"aea.helpers.pipe Portable pipe implementation for Linux, MacOS, and Windows. IPCChannelClient Objects class IPCChannelClient ( ABC ) Multi-platform interprocess communication channel for the client side. connect @abstractmethod async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to communication channel Arguments : timeout : timeout for other end to connect Returns : connection status write @abstractmethod async def write ( data : bytes ) -> None Write data bytes to the other end of the channel Will first write the size than the actual data Arguments : data : bytes to write read @abstractmethod async def read () -> Optional [ bytes ] Read bytes from the other end of the channel Will first read the size than the actual data Returns : read bytes close @abstractmethod async def close () -> None Close the communication channel. IPCChannel Objects class IPCChannel ( IPCChannelClient ) Multi-platform interprocess communication channel. in _ path @property @abstractmethod def in_path () -> str Rendezvous point for incoming communication. Returns : path out _ path @property @abstractmethod def out_path () -> str Rendezvous point for outgoing communication. Returns : path PosixNamedPipeProtocol Objects class PosixNamedPipeProtocol () Posix named pipes async wrapper communication protocol. __ init __ def __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a new posix named pipe. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop connect async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the pipe Arguments : timeout : timeout before failing Returns : connection success write async def write ( data : bytes ) -> None Write to pipe. Arguments : data : bytes to write to pipe read async def read () -> Optional [ bytes ] Read from pipe. Returns : read bytes close async def close () -> None Disconnect pipe. TCPSocketProtocol Objects class TCPSocketProtocol () TCP socket communication protocol. __ init __ def __init__ ( reader : asyncio . StreamReader , writer : asyncio . StreamWriter , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize the tcp socket protocol. Arguments : reader : established asyncio reader writer : established asyncio writer logger : the logger loop : the event loop writer @property def writer () -> StreamWriter Get a writer associated with protocol. write async def write ( data : bytes ) -> None Write to socket. Arguments : data : bytes to write read async def read () -> Optional [ bytes ] Read from socket. Returns : read bytes close async def close () -> None Disconnect socket. TCPSocketChannel Objects class TCPSocketChannel ( IPCChannel ) Interprocess communication channel implementation using tcp sockets. __ init __ def __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize tcp socket interprocess communication channel. connect async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for the connection to be established Returns : connection status write async def write ( data : bytes ) -> None Write to channel. Arguments : data : bytes to write read async def read () -> Optional [ bytes ] Read from channel. Returns : read bytes close async def close () -> None Disconnect from channel and clean it up. in _ path @property def in_path () -> str Rendezvous point for incoming communication. out _ path @property def out_path () -> str Rendezvous point for outgoing communication. PosixNamedPipeChannel Objects class PosixNamedPipeChannel ( IPCChannel ) Interprocess communication channel implementation using Posix named pipes. __ init __ def __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize posix named pipe interprocess communication channel. connect async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for connection to be established Returns : bool, indicating success write async def write ( data : bytes ) -> None Write to the channel. Arguments : data : data to write to channel read async def read () -> Optional [ bytes ] Read from the channel. Returns : read bytes close async def close () -> None Close the channel and clean it up. in _ path @property def in_path () -> str Rendezvous point for incoming communication. out _ path @property def out_path () -> str Rendezvous point for outgoing communication. TCPSocketChannelClient Objects class TCPSocketChannelClient ( IPCChannelClient ) Interprocess communication channel client using tcp sockets. __ init __ def __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a tcp socket communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop connect async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status write async def write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write read async def read () -> Optional [ bytes ] Read data from channel. Returns : read bytes close async def close () -> None Disconnect from communication channel. PosixNamedPipeChannelClient Objects class PosixNamedPipeChannelClient ( IPCChannelClient ) Interprocess communication channel client using Posix named pipes. __ init __ def __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a posix named pipe communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop connect async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status write async def write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write read async def read () -> Optional [ bytes ] Read data from channel. Returns : read bytes close async def close () -> None Disconnect from communication channel. make _ ipc _ channel def make_ipc_channel ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannel Build a portable bidirectional InterProcess Communication channel Arguments : logger : the logger loop : the loop Returns : IPCChannel make _ ipc _ channel _ client def make_ipc_channel_client ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannelClient Build a portable bidirectional InterProcess Communication client channel Arguments : in_path : rendezvous point for incoming communication out_path : rendezvous point for outgoing outgoing logger : the logger loop : the loop Returns : IPCChannel","title":"Pipe"},{"location":"api/helpers/pipe/#aeahelperspipe","text":"Portable pipe implementation for Linux, MacOS, and Windows.","title":"aea.helpers.pipe"},{"location":"api/helpers/pipe/#ipcchannelclient-objects","text":"class IPCChannelClient ( ABC ) Multi-platform interprocess communication channel for the client side.","title":"IPCChannelClient Objects"},{"location":"api/helpers/pipe/#connect","text":"@abstractmethod async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to communication channel Arguments : timeout : timeout for other end to connect Returns : connection status","title":"connect"},{"location":"api/helpers/pipe/#write","text":"@abstractmethod async def write ( data : bytes ) -> None Write data bytes to the other end of the channel Will first write the size than the actual data Arguments : data : bytes to write","title":"write"},{"location":"api/helpers/pipe/#read","text":"@abstractmethod async def read () -> Optional [ bytes ] Read bytes from the other end of the channel Will first read the size than the actual data Returns : read bytes","title":"read"},{"location":"api/helpers/pipe/#close","text":"@abstractmethod async def close () -> None Close the communication channel.","title":"close"},{"location":"api/helpers/pipe/#ipcchannel-objects","text":"class IPCChannel ( IPCChannelClient ) Multi-platform interprocess communication channel.","title":"IPCChannel Objects"},{"location":"api/helpers/pipe/#in_path","text":"@property @abstractmethod def in_path () -> str Rendezvous point for incoming communication. Returns : path","title":"in_path"},{"location":"api/helpers/pipe/#out_path","text":"@property @abstractmethod def out_path () -> str Rendezvous point for outgoing communication. Returns : path","title":"out_path"},{"location":"api/helpers/pipe/#posixnamedpipeprotocol-objects","text":"class PosixNamedPipeProtocol () Posix named pipes async wrapper communication protocol.","title":"PosixNamedPipeProtocol Objects"},{"location":"api/helpers/pipe/#__init__","text":"def __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a new posix named pipe. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop","title":"__init__"},{"location":"api/helpers/pipe/#connect_1","text":"async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the pipe Arguments : timeout : timeout before failing Returns : connection success","title":"connect"},{"location":"api/helpers/pipe/#write_1","text":"async def write ( data : bytes ) -> None Write to pipe. Arguments : data : bytes to write to pipe","title":"write"},{"location":"api/helpers/pipe/#read_1","text":"async def read () -> Optional [ bytes ] Read from pipe. Returns : read bytes","title":"read"},{"location":"api/helpers/pipe/#close_1","text":"async def close () -> None Disconnect pipe.","title":"close"},{"location":"api/helpers/pipe/#tcpsocketprotocol-objects","text":"class TCPSocketProtocol () TCP socket communication protocol.","title":"TCPSocketProtocol Objects"},{"location":"api/helpers/pipe/#__init___1","text":"def __init__ ( reader : asyncio . StreamReader , writer : asyncio . StreamWriter , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize the tcp socket protocol. Arguments : reader : established asyncio reader writer : established asyncio writer logger : the logger loop : the event loop","title":"__init__"},{"location":"api/helpers/pipe/#writer","text":"@property def writer () -> StreamWriter Get a writer associated with protocol.","title":"writer"},{"location":"api/helpers/pipe/#write_2","text":"async def write ( data : bytes ) -> None Write to socket. Arguments : data : bytes to write","title":"write"},{"location":"api/helpers/pipe/#read_2","text":"async def read () -> Optional [ bytes ] Read from socket. Returns : read bytes","title":"read"},{"location":"api/helpers/pipe/#close_2","text":"async def close () -> None Disconnect socket.","title":"close"},{"location":"api/helpers/pipe/#tcpsocketchannel-objects","text":"class TCPSocketChannel ( IPCChannel ) Interprocess communication channel implementation using tcp sockets.","title":"TCPSocketChannel Objects"},{"location":"api/helpers/pipe/#__init___2","text":"def __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize tcp socket interprocess communication channel.","title":"__init__"},{"location":"api/helpers/pipe/#connect_2","text":"async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for the connection to be established Returns : connection status","title":"connect"},{"location":"api/helpers/pipe/#write_3","text":"async def write ( data : bytes ) -> None Write to channel. Arguments : data : bytes to write","title":"write"},{"location":"api/helpers/pipe/#read_3","text":"async def read () -> Optional [ bytes ] Read from channel. Returns : read bytes","title":"read"},{"location":"api/helpers/pipe/#close_3","text":"async def close () -> None Disconnect from channel and clean it up.","title":"close"},{"location":"api/helpers/pipe/#in_path_1","text":"@property def in_path () -> str Rendezvous point for incoming communication.","title":"in_path"},{"location":"api/helpers/pipe/#out_path_1","text":"@property def out_path () -> str Rendezvous point for outgoing communication.","title":"out_path"},{"location":"api/helpers/pipe/#posixnamedpipechannel-objects","text":"class PosixNamedPipeChannel ( IPCChannel ) Interprocess communication channel implementation using Posix named pipes.","title":"PosixNamedPipeChannel Objects"},{"location":"api/helpers/pipe/#__init___3","text":"def __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize posix named pipe interprocess communication channel.","title":"__init__"},{"location":"api/helpers/pipe/#connect_3","text":"async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for connection to be established Returns : bool, indicating success","title":"connect"},{"location":"api/helpers/pipe/#write_4","text":"async def write ( data : bytes ) -> None Write to the channel. Arguments : data : data to write to channel","title":"write"},{"location":"api/helpers/pipe/#read_4","text":"async def read () -> Optional [ bytes ] Read from the channel. Returns : read bytes","title":"read"},{"location":"api/helpers/pipe/#close_4","text":"async def close () -> None Close the channel and clean it up.","title":"close"},{"location":"api/helpers/pipe/#in_path_2","text":"@property def in_path () -> str Rendezvous point for incoming communication.","title":"in_path"},{"location":"api/helpers/pipe/#out_path_2","text":"@property def out_path () -> str Rendezvous point for outgoing communication.","title":"out_path"},{"location":"api/helpers/pipe/#tcpsocketchannelclient-objects","text":"class TCPSocketChannelClient ( IPCChannelClient ) Interprocess communication channel client using tcp sockets.","title":"TCPSocketChannelClient Objects"},{"location":"api/helpers/pipe/#__init___4","text":"def __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a tcp socket communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop","title":"__init__"},{"location":"api/helpers/pipe/#connect_4","text":"async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status","title":"connect"},{"location":"api/helpers/pipe/#write_5","text":"async def write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write","title":"write"},{"location":"api/helpers/pipe/#read_5","text":"async def read () -> Optional [ bytes ] Read data from channel. Returns : read bytes","title":"read"},{"location":"api/helpers/pipe/#close_5","text":"async def close () -> None Disconnect from communication channel.","title":"close"},{"location":"api/helpers/pipe/#posixnamedpipechannelclient-objects","text":"class PosixNamedPipeChannelClient ( IPCChannelClient ) Interprocess communication channel client using Posix named pipes.","title":"PosixNamedPipeChannelClient Objects"},{"location":"api/helpers/pipe/#__init___5","text":"def __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a posix named pipe communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop","title":"__init__"},{"location":"api/helpers/pipe/#connect_5","text":"async def connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status","title":"connect"},{"location":"api/helpers/pipe/#write_6","text":"async def write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write","title":"write"},{"location":"api/helpers/pipe/#read_6","text":"async def read () -> Optional [ bytes ] Read data from channel. Returns : read bytes","title":"read"},{"location":"api/helpers/pipe/#close_6","text":"async def close () -> None Disconnect from communication channel.","title":"close"},{"location":"api/helpers/pipe/#make_ipc_channel","text":"def make_ipc_channel ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannel Build a portable bidirectional InterProcess Communication channel Arguments : logger : the logger loop : the loop Returns : IPCChannel","title":"make_ipc_channel"},{"location":"api/helpers/pipe/#make_ipc_channel_client","text":"def make_ipc_channel_client ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannelClient Build a portable bidirectional InterProcess Communication client channel Arguments : in_path : rendezvous point for incoming communication out_path : rendezvous point for outgoing outgoing logger : the logger loop : the loop Returns : IPCChannel","title":"make_ipc_channel_client"},{"location":"api/helpers/profiler_type_black_list/","text":"aea.helpers.profiler _ type _ black _ list Profiler blacklisted types.","title":"Profiler Type Blacklist"},{"location":"api/helpers/profiler_type_black_list/#aeahelpersprofiler_type_black_list","text":"Profiler blacklisted types.","title":"aea.helpers.profiler_type_black_list"},{"location":"api/helpers/profiling/","text":"aea.helpers.profiling Implementation of background profiling daemon. Profiling Objects class Profiling ( Runnable ) Profiling service. __ init __ def __init__ ( types_to_track : List [ Type ], period : int = 0 , output_function : Callable [[ str ], None ] = lambda x : print ( x , flush = True ) ) -> None Init profiler. Arguments : period : delay between profiling output in seconds. types_to_track : object types to count output_function : function to display output, one str argument. set _ counters def set_counters () -> None Modify new and del to count objects created created and destroyed. run async def run () -> None Run profiling. output _ profile _ data def output_profile_data () -> None Render profiling data and call output_function. get _ profile _ data def get_profile_data () -> Dict Get profiling data dict. get _ most _ common _ objects _ in _ gc def get_most_common_objects_in_gc ( number : int = 15 ) -> List [ Tuple [ str , int ]] Get the highest-count objects in the garbage collector.","title":"Profiling"},{"location":"api/helpers/profiling/#aeahelpersprofiling","text":"Implementation of background profiling daemon.","title":"aea.helpers.profiling"},{"location":"api/helpers/profiling/#profiling-objects","text":"class Profiling ( Runnable ) Profiling service.","title":"Profiling Objects"},{"location":"api/helpers/profiling/#__init__","text":"def __init__ ( types_to_track : List [ Type ], period : int = 0 , output_function : Callable [[ str ], None ] = lambda x : print ( x , flush = True ) ) -> None Init profiler. Arguments : period : delay between profiling output in seconds. types_to_track : object types to count output_function : function to display output, one str argument.","title":"__init__"},{"location":"api/helpers/profiling/#set_counters","text":"def set_counters () -> None Modify new and del to count objects created created and destroyed.","title":"set_counters"},{"location":"api/helpers/profiling/#run","text":"async def run () -> None Run profiling.","title":"run"},{"location":"api/helpers/profiling/#output_profile_data","text":"def output_profile_data () -> None Render profiling data and call output_function.","title":"output_profile_data"},{"location":"api/helpers/profiling/#get_profile_data","text":"def get_profile_data () -> Dict Get profiling data dict.","title":"get_profile_data"},{"location":"api/helpers/profiling/#get_most_common_objects_in_gc","text":"def get_most_common_objects_in_gc ( number : int = 15 ) -> List [ Tuple [ str , int ]] Get the highest-count objects in the garbage collector.","title":"get_most_common_objects_in_gc"},{"location":"api/helpers/serializers/","text":"aea.helpers.serializers This module contains Serializers that can be used for custom types. DictProtobufStructSerializer Objects class DictProtobufStructSerializer () Serialize python dictionaries of type DictType = Dict[str, ValueType] recursively conserving their dynamic type, using google.protobuf.Struct ValueType = PrimitiveType | DictType | List[ValueType]] PrimitiveType = bool | int | float | str | bytes encode @classmethod def encode ( cls , dictionary : Dict [ str , Any ]) -> bytes Serialize compatible dictionary to bytes. Copies entire dictionary in the process. Arguments : dictionary : the dictionary to serialize Returns : serialized bytes string decode @classmethod def decode ( cls , buffer : bytes ) -> Dict [ str , Any ] Deserialize a compatible dictionary","title":"Serializers"},{"location":"api/helpers/serializers/#aeahelpersserializers","text":"This module contains Serializers that can be used for custom types.","title":"aea.helpers.serializers"},{"location":"api/helpers/serializers/#dictprotobufstructserializer-objects","text":"class DictProtobufStructSerializer () Serialize python dictionaries of type DictType = Dict[str, ValueType] recursively conserving their dynamic type, using google.protobuf.Struct ValueType = PrimitiveType | DictType | List[ValueType]] PrimitiveType = bool | int | float | str | bytes","title":"DictProtobufStructSerializer Objects"},{"location":"api/helpers/serializers/#encode","text":"@classmethod def encode ( cls , dictionary : Dict [ str , Any ]) -> bytes Serialize compatible dictionary to bytes. Copies entire dictionary in the process. Arguments : dictionary : the dictionary to serialize Returns : serialized bytes string","title":"encode"},{"location":"api/helpers/serializers/#decode","text":"@classmethod def decode ( cls , buffer : bytes ) -> Dict [ str , Any ] Deserialize a compatible dictionary","title":"decode"},{"location":"api/helpers/sym_link/","text":"aea.helpers.sym _ link Sym link implementation for Linux, MacOS, and Windows. make _ symlink def make_symlink ( link_name : str , target : str ) -> None Make a symbolic link, cross platform. Arguments : link_name : the link name. target : the target. cd @contextlib . contextmanager def cd ( path : Path ) -> Generator Change directory with context manager. create _ symlink def create_symlink ( link_path : Path , target_path : Path , root_path : Path ) -> int Change directory and call the cross-platform script. The working directory must be the parent of the symbolic link name when executing 'create_symlink_crossplatform.sh'. Hence, we need to translate target_path into the relative path from the symbolic link directory to the target directory. So: 1) from link_path, extract the number of jumps to the parent directory in order to reach the repository root directory, and chain many \"../\" paths. 2) from target_path, compute the relative path to the root 3) relative_target_path is just the concatenation of the results from step (1) and (2). For instance, given - link_path: './directory_1//symbolic_link - target_path: './directory_2/target_path we want to compute: - link_path: 'symbolic_link' (just the last bit) - relative_target_path: '../../directory_1/target_path' The resulting command on UNIX systems will be: cd directory_1 && ln -s ../../directory_1/target_path symbolic_link Arguments : link_path : the source path target_path : the target path root_path : the root path Returns : exit code","title":"Sym Link"},{"location":"api/helpers/sym_link/#aeahelperssym_link","text":"Sym link implementation for Linux, MacOS, and Windows.","title":"aea.helpers.sym_link"},{"location":"api/helpers/sym_link/#make_symlink","text":"def make_symlink ( link_name : str , target : str ) -> None Make a symbolic link, cross platform. Arguments : link_name : the link name. target : the target.","title":"make_symlink"},{"location":"api/helpers/sym_link/#cd","text":"@contextlib . contextmanager def cd ( path : Path ) -> Generator Change directory with context manager.","title":"cd"},{"location":"api/helpers/sym_link/#create_symlink","text":"def create_symlink ( link_path : Path , target_path : Path , root_path : Path ) -> int Change directory and call the cross-platform script. The working directory must be the parent of the symbolic link name when executing 'create_symlink_crossplatform.sh'. Hence, we need to translate target_path into the relative path from the symbolic link directory to the target directory. So: 1) from link_path, extract the number of jumps to the parent directory in order to reach the repository root directory, and chain many \"../\" paths. 2) from target_path, compute the relative path to the root 3) relative_target_path is just the concatenation of the results from step (1) and (2). For instance, given - link_path: './directory_1//symbolic_link - target_path: './directory_2/target_path we want to compute: - link_path: 'symbolic_link' (just the last bit) - relative_target_path: '../../directory_1/target_path' The resulting command on UNIX systems will be: cd directory_1 && ln -s ../../directory_1/target_path symbolic_link Arguments : link_path : the source path target_path : the target path root_path : the root path Returns : exit code","title":"create_symlink"},{"location":"api/helpers/win32/","text":"aea.helpers.win32 Helpers for Windows. enable _ ctrl _ c _ support def enable_ctrl_c_support () -> None Enable ctrl+c support for aea.cli command to be tested on windows platform.","title":"Win32"},{"location":"api/helpers/win32/#aeahelperswin32","text":"Helpers for Windows.","title":"aea.helpers.win32"},{"location":"api/helpers/win32/#enable_ctrl_c_support","text":"def enable_ctrl_c_support () -> None Enable ctrl+c support for aea.cli command to be tested on windows platform.","title":"enable_ctrl_c_support"},{"location":"api/helpers/yaml_utils/","text":"aea.helpers.yaml _ utils Helper functions related to YAML loading/dumping. _ AEAYamlLoader Objects class _AEAYamlLoader ( yaml . SafeLoader ) Custom yaml.SafeLoader for the AEA framework. It extends the default SafeLoader in two ways: - loads YAML configurations while remembering the order of the fields ; - resolves the environment variables at loading time. This class is for internal usage only; please use the public functions of the module 'yaml_load' and 'yaml_load_all'. __ init __ def __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlLoader. It adds a YAML Loader constructor to use 'OderedDict' to load the files. Arguments : args : the positional arguments. kwargs : the keyword arguments. _ AEAYamlDumper Objects class _AEAYamlDumper ( yaml . SafeDumper ) Custom yaml.SafeDumper for the AEA framework. It extends the default SafeDumper so to dump YAML configurations while following the order of the fields . This class is for internal usage only; please use the public functions of the module 'yaml_dump' and 'yaml_dump_all'. __ init __ def __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlDumper. It adds a YAML Dumper representer to use 'OderedDict' to dump the files. Arguments : args : the positional arguments. kwargs : the keyword arguments. yaml _ load def yaml_load ( stream : TextIO ) -> Dict [ str , Any ] Load a yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the dictionary object with the YAML file content. yaml _ load _ all def yaml_load_all ( stream : TextIO ) -> List [ Dict [ str , Any ]] Load a multi-paged yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the list of dictionary objects with the (multi-paged) YAML file content. yaml _ dump def yaml_dump ( data : Dict , stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on. yaml _ dump _ all def yaml_dump_all ( data : Sequence [ Dict ], stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on.","title":"YamlUtils"},{"location":"api/helpers/yaml_utils/#aeahelpersyaml_utils","text":"Helper functions related to YAML loading/dumping.","title":"aea.helpers.yaml_utils"},{"location":"api/helpers/yaml_utils/#_aeayamlloader-objects","text":"class _AEAYamlLoader ( yaml . SafeLoader ) Custom yaml.SafeLoader for the AEA framework. It extends the default SafeLoader in two ways: - loads YAML configurations while remembering the order of the fields ; - resolves the environment variables at loading time. This class is for internal usage only; please use the public functions of the module 'yaml_load' and 'yaml_load_all'.","title":"_AEAYamlLoader Objects"},{"location":"api/helpers/yaml_utils/#__init__","text":"def __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlLoader. It adds a YAML Loader constructor to use 'OderedDict' to load the files. Arguments : args : the positional arguments. kwargs : the keyword arguments.","title":"__init__"},{"location":"api/helpers/yaml_utils/#_aeayamldumper-objects","text":"class _AEAYamlDumper ( yaml . SafeDumper ) Custom yaml.SafeDumper for the AEA framework. It extends the default SafeDumper so to dump YAML configurations while following the order of the fields . This class is for internal usage only; please use the public functions of the module 'yaml_dump' and 'yaml_dump_all'.","title":"_AEAYamlDumper Objects"},{"location":"api/helpers/yaml_utils/#__init___1","text":"def __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlDumper. It adds a YAML Dumper representer to use 'OderedDict' to dump the files. Arguments : args : the positional arguments. kwargs : the keyword arguments.","title":"__init__"},{"location":"api/helpers/yaml_utils/#yaml_load","text":"def yaml_load ( stream : TextIO ) -> Dict [ str , Any ] Load a yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the dictionary object with the YAML file content.","title":"yaml_load"},{"location":"api/helpers/yaml_utils/#yaml_load_all","text":"def yaml_load_all ( stream : TextIO ) -> List [ Dict [ str , Any ]] Load a multi-paged yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the list of dictionary objects with the (multi-paged) YAML file content.","title":"yaml_load_all"},{"location":"api/helpers/yaml_utils/#yaml_dump","text":"def yaml_dump ( data : Dict , stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on.","title":"yaml_dump"},{"location":"api/helpers/yaml_utils/#yaml_dump_all","text":"def yaml_dump_all ( data : Sequence [ Dict ], stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on.","title":"yaml_dump_all"},{"location":"api/helpers/acn/agent_record/","text":"aea.helpers.acn.agent _ record This module contains types and helpers for ACN Proof-of-Representation. AgentRecord Objects class AgentRecord () Agent Proof-of-Representation to representative. __ init __ def __init__ ( address : str , representative_public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , signature : str ) -> None Initialize the AgentRecord Arguments : address : agent address representative_public_key : representative's public key identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing signature : proof-of-representation of this AgentRecord address @property def address () -> str Get agent address public _ key @property def public_key () -> str Get agent public key representative _ public _ key @property def representative_public_key () -> str Get agent representative's public key signature @property def signature () -> str Get record signature message @property def message () -> bytes Get the message. identifier @property def identifier () -> SimpleIdOrStr Get the identifier. ledger _ id @property def ledger_id () -> SimpleIdOrStr Get ledger id. not _ before @property def not_before () -> str Get the not_before field. not _ after @property def not_after () -> str Get the not_after field. message _ format @property def message_format () -> str Get the message format. __ str __ def __str__ () -> str Get string representation. from _ cert _ request @classmethod def from_cert_request ( cls , cert_request : CertRequest , address : str , representative_public_key : str , data_dir : Optional [ PathLike ] = None ) -> \"AgentRecord\" Get agent record from cert request.","title":"Agent Record"},{"location":"api/helpers/acn/agent_record/#aeahelpersacnagent_record","text":"This module contains types and helpers for ACN Proof-of-Representation.","title":"aea.helpers.acn.agent_record"},{"location":"api/helpers/acn/agent_record/#agentrecord-objects","text":"class AgentRecord () Agent Proof-of-Representation to representative.","title":"AgentRecord Objects"},{"location":"api/helpers/acn/agent_record/#__init__","text":"def __init__ ( address : str , representative_public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , signature : str ) -> None Initialize the AgentRecord Arguments : address : agent address representative_public_key : representative's public key identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing signature : proof-of-representation of this AgentRecord","title":"__init__"},{"location":"api/helpers/acn/agent_record/#address","text":"@property def address () -> str Get agent address","title":"address"},{"location":"api/helpers/acn/agent_record/#public_key","text":"@property def public_key () -> str Get agent public key","title":"public_key"},{"location":"api/helpers/acn/agent_record/#representative_public_key","text":"@property def representative_public_key () -> str Get agent representative's public key","title":"representative_public_key"},{"location":"api/helpers/acn/agent_record/#signature","text":"@property def signature () -> str Get record signature","title":"signature"},{"location":"api/helpers/acn/agent_record/#message","text":"@property def message () -> bytes Get the message.","title":"message"},{"location":"api/helpers/acn/agent_record/#identifier","text":"@property def identifier () -> SimpleIdOrStr Get the identifier.","title":"identifier"},{"location":"api/helpers/acn/agent_record/#ledger_id","text":"@property def ledger_id () -> SimpleIdOrStr Get ledger id.","title":"ledger_id"},{"location":"api/helpers/acn/agent_record/#not_before","text":"@property def not_before () -> str Get the not_before field.","title":"not_before"},{"location":"api/helpers/acn/agent_record/#not_after","text":"@property def not_after () -> str Get the not_after field.","title":"not_after"},{"location":"api/helpers/acn/agent_record/#message_format","text":"@property def message_format () -> str Get the message format.","title":"message_format"},{"location":"api/helpers/acn/agent_record/#__str__","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/helpers/acn/agent_record/#from_cert_request","text":"@classmethod def from_cert_request ( cls , cert_request : CertRequest , address : str , representative_public_key : str , data_dir : Optional [ PathLike ] = None ) -> \"AgentRecord\" Get agent record from cert request.","title":"from_cert_request"},{"location":"api/helpers/acn/uri/","text":"aea.helpers.acn.uri This module contains types and helpers for libp2p connections Uris. Uri Objects class Uri () Holds a node address in format \"host:port\". __ init __ def __init__ ( uri : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None ) -> None Initialise Uri. __ str __ def __str__ () -> str Get string representation. __ repr __ def __repr__ () -> str Get object representation. host @property def host () -> str Get host. port @property def port () -> int Get port.","title":"URI"},{"location":"api/helpers/acn/uri/#aeahelpersacnuri","text":"This module contains types and helpers for libp2p connections Uris.","title":"aea.helpers.acn.uri"},{"location":"api/helpers/acn/uri/#uri-objects","text":"class Uri () Holds a node address in format \"host:port\".","title":"Uri Objects"},{"location":"api/helpers/acn/uri/#__init__","text":"def __init__ ( uri : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None ) -> None Initialise Uri.","title":"__init__"},{"location":"api/helpers/acn/uri/#__str__","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/helpers/acn/uri/#__repr__","text":"def __repr__ () -> str Get object representation.","title":"__repr__"},{"location":"api/helpers/acn/uri/#host","text":"@property def host () -> str Get host.","title":"host"},{"location":"api/helpers/acn/uri/#port","text":"@property def port () -> int Get port.","title":"port"},{"location":"api/helpers/ipfs/base/","text":"aea.helpers.ipfs.base This module contains helper methods and classes for the 'aea' package. chunks def chunks ( data : Sized , size : int ) -> Generator Yield successivesize chunks from data. IPFSHashOnly Objects class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon. get @classmethod def get ( cls , file_path : str , wrap : bool = True ) -> str Get the IPFS hash. hash _ file @classmethod def hash_file ( cls , file_path : str , wrap : bool = True ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path wrap : weather to wrap the content in wrapper node or not Returns : the ipfs hash hash _ directory @classmethod def hash_directory ( cls , dir_path : str , wrap : bool = True ) -> str Get the IPFS hash for a directory. Arguments : dir_path : the directory path wrap : weather to wrap the content in wrapper node or not Returns : the ipfs hash create _ link @staticmethod def create_link ( link_hash : bytes , tsize : int , name : str ) -> Any Create PBLink object. wrap _ in _ a _ node @classmethod def wrap_in_a_node ( cls , link : Any ) -> str Wrap content in a wrapper node.","title":"Base"},{"location":"api/helpers/ipfs/base/#aeahelpersipfsbase","text":"This module contains helper methods and classes for the 'aea' package.","title":"aea.helpers.ipfs.base"},{"location":"api/helpers/ipfs/base/#chunks","text":"def chunks ( data : Sized , size : int ) -> Generator Yield successivesize chunks from data.","title":"chunks"},{"location":"api/helpers/ipfs/base/#ipfshashonly-objects","text":"class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon.","title":"IPFSHashOnly Objects"},{"location":"api/helpers/ipfs/base/#get","text":"@classmethod def get ( cls , file_path : str , wrap : bool = True ) -> str Get the IPFS hash.","title":"get"},{"location":"api/helpers/ipfs/base/#hash_file","text":"@classmethod def hash_file ( cls , file_path : str , wrap : bool = True ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path wrap : weather to wrap the content in wrapper node or not Returns : the ipfs hash","title":"hash_file"},{"location":"api/helpers/ipfs/base/#hash_directory","text":"@classmethod def hash_directory ( cls , dir_path : str , wrap : bool = True ) -> str Get the IPFS hash for a directory. Arguments : dir_path : the directory path wrap : weather to wrap the content in wrapper node or not Returns : the ipfs hash","title":"hash_directory"},{"location":"api/helpers/ipfs/base/#create_link","text":"@staticmethod def create_link ( link_hash : bytes , tsize : int , name : str ) -> Any Create PBLink object.","title":"create_link"},{"location":"api/helpers/ipfs/base/#wrap_in_a_node","text":"@classmethod def wrap_in_a_node ( cls , link : Any ) -> str Wrap content in a wrapper node.","title":"wrap_in_a_node"},{"location":"api/helpers/ipfs/utils/","text":"aea.helpers.ipfs.utils This module contains utility methods for ipfs helpers.","title":"Utils"},{"location":"api/helpers/ipfs/utils/#aeahelpersipfsutils","text":"This module contains utility methods for ipfs helpers.","title":"aea.helpers.ipfs.utils"},{"location":"api/helpers/multiaddr/base/","text":"aea.helpers.multiaddr.base This module contains multiaddress class. MultiAddr Objects class MultiAddr () Protocol Labs' Multiaddress representation of a network address. __ init __ def __init__ ( host : str , port : int , public_key : Optional [ str ] = None , multihash_id : Optional [ str ] = None ) -> None Initialize a multiaddress. Arguments : host : ip host of the address port : port number of the address public_key : hex encoded public key. Must conform to Bitcoin EC encoding standard for Secp256k1 multihash_id : a multihash of the public key compute _ peerid @staticmethod def compute_peerid ( public_key : str ) -> str Compute the peer id from a public key. In particular, compute the base58 representation of libp2p PeerID from Bitcoin EC encoded Secp256k1 public key. Arguments : public_key : the public key. Returns : the peer id. from _ string @classmethod def from_string ( cls , maddr : str ) -> \"MultiAddr\" Construct a MultiAddr object from its string format Arguments : maddr : multiaddress string Returns : multiaddress object public _ key @property def public_key () -> str Get the public key. peer _ id @property def peer_id () -> str Get the peer id. host @property def host () -> str Get the peer host. port @property def port () -> int Get the peer port. format def format () -> str Canonical representation of a multiaddress. __ str __ def __str__ () -> str Default string representation of a multiaddress.","title":"Base"},{"location":"api/helpers/multiaddr/base/#aeahelpersmultiaddrbase","text":"This module contains multiaddress class.","title":"aea.helpers.multiaddr.base"},{"location":"api/helpers/multiaddr/base/#multiaddr-objects","text":"class MultiAddr () Protocol Labs' Multiaddress representation of a network address.","title":"MultiAddr Objects"},{"location":"api/helpers/multiaddr/base/#__init__","text":"def __init__ ( host : str , port : int , public_key : Optional [ str ] = None , multihash_id : Optional [ str ] = None ) -> None Initialize a multiaddress. Arguments : host : ip host of the address port : port number of the address public_key : hex encoded public key. Must conform to Bitcoin EC encoding standard for Secp256k1 multihash_id : a multihash of the public key","title":"__init__"},{"location":"api/helpers/multiaddr/base/#compute_peerid","text":"@staticmethod def compute_peerid ( public_key : str ) -> str Compute the peer id from a public key. In particular, compute the base58 representation of libp2p PeerID from Bitcoin EC encoded Secp256k1 public key. Arguments : public_key : the public key. Returns : the peer id.","title":"compute_peerid"},{"location":"api/helpers/multiaddr/base/#from_string","text":"@classmethod def from_string ( cls , maddr : str ) -> \"MultiAddr\" Construct a MultiAddr object from its string format Arguments : maddr : multiaddress string Returns : multiaddress object","title":"from_string"},{"location":"api/helpers/multiaddr/base/#public_key","text":"@property def public_key () -> str Get the public key.","title":"public_key"},{"location":"api/helpers/multiaddr/base/#peer_id","text":"@property def peer_id () -> str Get the peer id.","title":"peer_id"},{"location":"api/helpers/multiaddr/base/#host","text":"@property def host () -> str Get the peer host.","title":"host"},{"location":"api/helpers/multiaddr/base/#port","text":"@property def port () -> int Get the peer port.","title":"port"},{"location":"api/helpers/multiaddr/base/#format","text":"def format () -> str Canonical representation of a multiaddress.","title":"format"},{"location":"api/helpers/multiaddr/base/#__str__","text":"def __str__ () -> str Default string representation of a multiaddress.","title":"__str__"},{"location":"api/helpers/preference_representations/base/","text":"aea.helpers.preference _ representations.base Preference representation helpers. logarithmic _ utility def logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 100 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value linear _ utility def linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"Base"},{"location":"api/helpers/preference_representations/base/#aeahelperspreference_representationsbase","text":"Preference representation helpers.","title":"aea.helpers.preference_representations.base"},{"location":"api/helpers/preference_representations/base/#logarithmic_utility","text":"def logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 100 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value","title":"logarithmic_utility"},{"location":"api/helpers/preference_representations/base/#linear_utility","text":"def linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"linear_utility"},{"location":"api/helpers/search/generic/","text":"aea.helpers.search.generic This module contains a generic data model. GenericDataModel Objects class GenericDataModel ( DataModel ) Generic data model. __ init __ def __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) -> None Initialise the dataModel.","title":"Generic"},{"location":"api/helpers/search/generic/#aeahelperssearchgeneric","text":"This module contains a generic data model.","title":"aea.helpers.search.generic"},{"location":"api/helpers/search/generic/#genericdatamodel-objects","text":"class GenericDataModel ( DataModel ) Generic data model.","title":"GenericDataModel Objects"},{"location":"api/helpers/search/generic/#__init__","text":"def __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) -> None Initialise the dataModel.","title":"__init__"},{"location":"api/helpers/search/models/","text":"","title":"Models"},{"location":"api/helpers/storage/generic_storage/","text":"aea.helpers.storage.generic _ storage This module contains the storage implementation. AsyncCollection Objects class AsyncCollection () Async collection. __ init __ def __init__ ( storage_backend : AbstractStorageBackend , collection_name : str ) -> None Init collection object. Arguments : storage_backend : storage backed to use. collection_name : str put async def put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None get async def get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None remove async def remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None find async def find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None list async def list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies. SyncCollection Objects class SyncCollection () Async collection. __ init __ def __init__ ( async_collection_coro : Coroutine , loop : asyncio . AbstractEventLoop ) -> None Init collection object. Arguments : async_collection_coro : coroutine returns async collection. loop : abstract event loop where storage is running. put def put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None get def get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None remove def remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None find def find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : List of object bodies list def list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies. Storage Objects class Storage ( Runnable ) Generic storage. __ init __ def __init__ ( storage_uri : str , loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init storage. Arguments : storage_uri : configuration string for storage. loop : asyncio event loop to use. threaded : bool. start in thread if True. wait _ connected async def wait_connected () -> None Wait generic storage is connected. is _ connected @property def is_connected () -> bool Get running state of the storage. run async def run () -> None Connect storage. get _ collection async def get_collection ( collection_name : str ) -> AsyncCollection Get async collection. get _ sync _ collection def get_sync_collection ( collection_name : str ) -> SyncCollection Get sync collection. __ repr __ def __repr__ () -> str Get string representation of the storage.","title":"GenericStorage"},{"location":"api/helpers/storage/generic_storage/#aeahelpersstoragegeneric_storage","text":"This module contains the storage implementation.","title":"aea.helpers.storage.generic_storage"},{"location":"api/helpers/storage/generic_storage/#asynccollection-objects","text":"class AsyncCollection () Async collection.","title":"AsyncCollection Objects"},{"location":"api/helpers/storage/generic_storage/#__init__","text":"def __init__ ( storage_backend : AbstractStorageBackend , collection_name : str ) -> None Init collection object. Arguments : storage_backend : storage backed to use. collection_name : str","title":"__init__"},{"location":"api/helpers/storage/generic_storage/#put","text":"async def put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"api/helpers/storage/generic_storage/#get","text":"async def get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"api/helpers/storage/generic_storage/#remove","text":"async def remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None","title":"remove"},{"location":"api/helpers/storage/generic_storage/#find","text":"async def find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None","title":"find"},{"location":"api/helpers/storage/generic_storage/#list","text":"async def list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"api/helpers/storage/generic_storage/#synccollection-objects","text":"class SyncCollection () Async collection.","title":"SyncCollection Objects"},{"location":"api/helpers/storage/generic_storage/#__init___1","text":"def __init__ ( async_collection_coro : Coroutine , loop : asyncio . AbstractEventLoop ) -> None Init collection object. Arguments : async_collection_coro : coroutine returns async collection. loop : abstract event loop where storage is running.","title":"__init__"},{"location":"api/helpers/storage/generic_storage/#put_1","text":"def put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"api/helpers/storage/generic_storage/#get_1","text":"def get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"api/helpers/storage/generic_storage/#remove_1","text":"def remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None","title":"remove"},{"location":"api/helpers/storage/generic_storage/#find_1","text":"def find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : List of object bodies","title":"find"},{"location":"api/helpers/storage/generic_storage/#list_1","text":"def list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"api/helpers/storage/generic_storage/#storage-objects","text":"class Storage ( Runnable ) Generic storage.","title":"Storage Objects"},{"location":"api/helpers/storage/generic_storage/#__init___2","text":"def __init__ ( storage_uri : str , loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init storage. Arguments : storage_uri : configuration string for storage. loop : asyncio event loop to use. threaded : bool. start in thread if True.","title":"__init__"},{"location":"api/helpers/storage/generic_storage/#wait_connected","text":"async def wait_connected () -> None Wait generic storage is connected.","title":"wait_connected"},{"location":"api/helpers/storage/generic_storage/#is_connected","text":"@property def is_connected () -> bool Get running state of the storage.","title":"is_connected"},{"location":"api/helpers/storage/generic_storage/#run","text":"async def run () -> None Connect storage.","title":"run"},{"location":"api/helpers/storage/generic_storage/#get_collection","text":"async def get_collection ( collection_name : str ) -> AsyncCollection Get async collection.","title":"get_collection"},{"location":"api/helpers/storage/generic_storage/#get_sync_collection","text":"def get_sync_collection ( collection_name : str ) -> SyncCollection Get sync collection.","title":"get_sync_collection"},{"location":"api/helpers/storage/generic_storage/#__repr__","text":"def __repr__ () -> str Get string representation of the storage.","title":"__repr__"},{"location":"api/helpers/storage/backends/base/","text":"aea.helpers.storage.backends.base This module contains storage abstract backend class. AbstractStorageBackend Objects class AbstractStorageBackend ( ABC ) Abstract base class for storage backend. __ init __ def __init__ ( uri : str ) -> None Init backend. connect @abstractmethod async def connect () -> None Connect to backend. disconnect @abstractmethod async def disconnect () -> None Disconnect the backend. ensure _ collection @abstractmethod async def ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None put @abstractmethod async def put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None get @abstractmethod async def get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None remove @abstractmethod async def remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None find @abstractmethod async def find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of objects bodies list @abstractmethod async def list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"Base"},{"location":"api/helpers/storage/backends/base/#aeahelpersstoragebackendsbase","text":"This module contains storage abstract backend class.","title":"aea.helpers.storage.backends.base"},{"location":"api/helpers/storage/backends/base/#abstractstoragebackend-objects","text":"class AbstractStorageBackend ( ABC ) Abstract base class for storage backend.","title":"AbstractStorageBackend Objects"},{"location":"api/helpers/storage/backends/base/#__init__","text":"def __init__ ( uri : str ) -> None Init backend.","title":"__init__"},{"location":"api/helpers/storage/backends/base/#connect","text":"@abstractmethod async def connect () -> None Connect to backend.","title":"connect"},{"location":"api/helpers/storage/backends/base/#disconnect","text":"@abstractmethod async def disconnect () -> None Disconnect the backend.","title":"disconnect"},{"location":"api/helpers/storage/backends/base/#ensure_collection","text":"@abstractmethod async def ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None","title":"ensure_collection"},{"location":"api/helpers/storage/backends/base/#put","text":"@abstractmethod async def put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"api/helpers/storage/backends/base/#get","text":"@abstractmethod async def get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"api/helpers/storage/backends/base/#remove","text":"@abstractmethod async def remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None","title":"remove"},{"location":"api/helpers/storage/backends/base/#find","text":"@abstractmethod async def find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of objects bodies","title":"find"},{"location":"api/helpers/storage/backends/base/#list","text":"@abstractmethod async def list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"api/helpers/storage/backends/sqlite/","text":"aea.helpers.storage.backends.sqlite This module contains sqlite storage backend implementation. SqliteStorageBackend Objects class SqliteStorageBackend ( AbstractStorageBackend ) Sqlite storage backend. __ init __ def __init__ ( uri : str ) -> None Init backend. connect async def connect () -> None Connect to backend. disconnect async def disconnect () -> None Disconnect the backend. ensure _ collection async def ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : name of the collection. put async def put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. get async def get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None remove async def remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id find async def find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of object ids and body list async def list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"Sqlite"},{"location":"api/helpers/storage/backends/sqlite/#aeahelpersstoragebackendssqlite","text":"This module contains sqlite storage backend implementation.","title":"aea.helpers.storage.backends.sqlite"},{"location":"api/helpers/storage/backends/sqlite/#sqlitestoragebackend-objects","text":"class SqliteStorageBackend ( AbstractStorageBackend ) Sqlite storage backend.","title":"SqliteStorageBackend Objects"},{"location":"api/helpers/storage/backends/sqlite/#__init__","text":"def __init__ ( uri : str ) -> None Init backend.","title":"__init__"},{"location":"api/helpers/storage/backends/sqlite/#connect","text":"async def connect () -> None Connect to backend.","title":"connect"},{"location":"api/helpers/storage/backends/sqlite/#disconnect","text":"async def disconnect () -> None Disconnect the backend.","title":"disconnect"},{"location":"api/helpers/storage/backends/sqlite/#ensure_collection","text":"async def ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : name of the collection.","title":"ensure_collection"},{"location":"api/helpers/storage/backends/sqlite/#put","text":"async def put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible.","title":"put"},{"location":"api/helpers/storage/backends/sqlite/#get","text":"async def get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"api/helpers/storage/backends/sqlite/#remove","text":"async def remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id","title":"remove"},{"location":"api/helpers/storage/backends/sqlite/#find","text":"async def find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of object ids and body","title":"find"},{"location":"api/helpers/storage/backends/sqlite/#list","text":"async def list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"api/helpers/transaction/base/","text":"aea.helpers.transaction.base This module contains terms related classes. RawTransaction Objects class RawTransaction () This class represents an instance of RawTransaction. __ init __ def __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of RawTransaction. ledger _ id @property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body @property def body () -> JSONLike Get the body. encode @staticmethod def encode ( raw_transaction_protobuf_object : Any , raw_transaction_object : \"RawTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_transaction_protobuf_object argument must be matched with the instance of this class in the 'raw_transaction_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_transaction_object : an instance of this class to be encoded in the protocol buffer object. decode @classmethod def decode ( cls , raw_transaction_protobuf_object : Any ) -> \"RawTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. __ eq __ def __eq__ ( other : Any ) -> bool Check equality. __ str __ def __str__ () -> str Get string representation. RawMessage Objects class RawMessage () This class represents an instance of RawMessage. __ init __ def __init__ ( ledger_id : str , body : bytes , is_deprecated_mode : bool = False ) -> None Initialise an instance of RawMessage. ledger _ id @property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body @property def body () -> bytes Get the body. is _ deprecated _ mode @property def is_deprecated_mode () -> bool Get the is_deprecated_mode. encode @staticmethod def encode ( raw_message_protobuf_object : Any , raw_message_object : \"RawMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_message_protobuf_object argument must be matched with the instance of this class in the 'raw_message_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_message_object : an instance of this class to be encoded in the protocol buffer object. decode @classmethod def decode ( cls , raw_message_protobuf_object : Any ) -> \"RawMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. __ eq __ def __eq__ ( other : Any ) -> bool Check equality. __ str __ def __str__ () -> str Get string representation. SignedTransaction Objects class SignedTransaction () This class represents an instance of SignedTransaction. __ init __ def __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of SignedTransaction. ledger _ id @property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body @property def body () -> JSONLike Get the body. encode @staticmethod def encode ( signed_transaction_protobuf_object : Any , signed_transaction_object : \"SignedTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_transaction_protobuf_object argument must be matched with the instance of this class in the 'signed_transaction_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_transaction_object : an instance of this class to be encoded in the protocol buffer object. decode @classmethod def decode ( cls , signed_transaction_protobuf_object : Any ) -> \"SignedTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. __ eq __ def __eq__ ( other : Any ) -> bool Check equality. __ str __ def __str__ () -> str Get string representation. SignedMessage Objects class SignedMessage () This class represents an instance of RawMessage. __ init __ def __init__ ( ledger_id : str , body : str , is_deprecated_mode : bool = False ) -> None Initialise an instance of SignedMessage. ledger _ id @property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body @property def body () -> str Get the body. is _ deprecated _ mode @property def is_deprecated_mode () -> bool Get the is_deprecated_mode. encode @staticmethod def encode ( signed_message_protobuf_object : Any , signed_message_object : \"SignedMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_message_protobuf_object argument must be matched with the instance of this class in the 'signed_message_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_message_object : an instance of this class to be encoded in the protocol buffer object. decode @classmethod def decode ( cls , signed_message_protobuf_object : Any ) -> \"SignedMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. __ eq __ def __eq__ ( other : Any ) -> bool Check equality. __ str __ def __str__ () -> str Get string representation. State Objects class State () This class represents an instance of State. __ init __ def __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of State. ledger _ id @property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body @property def body () -> JSONLike Get the body. encode @staticmethod def encode ( state_protobuf_object : Any , state_object : \"State\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the state_protobuf_object argument must be matched with the instance of this class in the 'state_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. state_object : an instance of this class to be encoded in the protocol buffer object. decode @classmethod def decode ( cls , state_protobuf_object : Any ) -> \"State\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'state_protobuf_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'state_protobuf_object' argument. __ eq __ def __eq__ ( other : Any ) -> bool Check equality. __ str __ def __str__ () -> str Get string representation. Terms Objects class Terms () Class to represent the terms of a multi-currency & multi-token ledger transaction. __ init __","title":"Base"},{"location":"api/helpers/transaction/base/#aeahelperstransactionbase","text":"This module contains terms related classes.","title":"aea.helpers.transaction.base"},{"location":"api/helpers/transaction/base/#rawtransaction-objects","text":"class RawTransaction () This class represents an instance of RawTransaction.","title":"RawTransaction Objects"},{"location":"api/helpers/transaction/base/#__init__","text":"def __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of RawTransaction.","title":"__init__"},{"location":"api/helpers/transaction/base/#ledger_id","text":"@property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"api/helpers/transaction/base/#body","text":"@property def body () -> JSONLike Get the body.","title":"body"},{"location":"api/helpers/transaction/base/#encode","text":"@staticmethod def encode ( raw_transaction_protobuf_object : Any , raw_transaction_object : \"RawTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_transaction_protobuf_object argument must be matched with the instance of this class in the 'raw_transaction_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_transaction_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"api/helpers/transaction/base/#decode","text":"@classmethod def decode ( cls , raw_transaction_protobuf_object : Any ) -> \"RawTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument.","title":"decode"},{"location":"api/helpers/transaction/base/#__eq__","text":"def __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"api/helpers/transaction/base/#__str__","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/helpers/transaction/base/#rawmessage-objects","text":"class RawMessage () This class represents an instance of RawMessage.","title":"RawMessage Objects"},{"location":"api/helpers/transaction/base/#__init___1","text":"def __init__ ( ledger_id : str , body : bytes , is_deprecated_mode : bool = False ) -> None Initialise an instance of RawMessage.","title":"__init__"},{"location":"api/helpers/transaction/base/#ledger_id_1","text":"@property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"api/helpers/transaction/base/#body_1","text":"@property def body () -> bytes Get the body.","title":"body"},{"location":"api/helpers/transaction/base/#is_deprecated_mode","text":"@property def is_deprecated_mode () -> bool Get the is_deprecated_mode.","title":"is_deprecated_mode"},{"location":"api/helpers/transaction/base/#encode_1","text":"@staticmethod def encode ( raw_message_protobuf_object : Any , raw_message_object : \"RawMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_message_protobuf_object argument must be matched with the instance of this class in the 'raw_message_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_message_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"api/helpers/transaction/base/#decode_1","text":"@classmethod def decode ( cls , raw_message_protobuf_object : Any ) -> \"RawMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_message_protobuf_object' argument.","title":"decode"},{"location":"api/helpers/transaction/base/#__eq___1","text":"def __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"api/helpers/transaction/base/#__str___1","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/helpers/transaction/base/#signedtransaction-objects","text":"class SignedTransaction () This class represents an instance of SignedTransaction.","title":"SignedTransaction Objects"},{"location":"api/helpers/transaction/base/#__init___2","text":"def __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of SignedTransaction.","title":"__init__"},{"location":"api/helpers/transaction/base/#ledger_id_2","text":"@property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"api/helpers/transaction/base/#body_2","text":"@property def body () -> JSONLike Get the body.","title":"body"},{"location":"api/helpers/transaction/base/#encode_2","text":"@staticmethod def encode ( signed_transaction_protobuf_object : Any , signed_transaction_object : \"SignedTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_transaction_protobuf_object argument must be matched with the instance of this class in the 'signed_transaction_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_transaction_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"api/helpers/transaction/base/#decode_2","text":"@classmethod def decode ( cls , signed_transaction_protobuf_object : Any ) -> \"SignedTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument.","title":"decode"},{"location":"api/helpers/transaction/base/#__eq___2","text":"def __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"api/helpers/transaction/base/#__str___2","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/helpers/transaction/base/#signedmessage-objects","text":"class SignedMessage () This class represents an instance of RawMessage.","title":"SignedMessage Objects"},{"location":"api/helpers/transaction/base/#__init___3","text":"def __init__ ( ledger_id : str , body : str , is_deprecated_mode : bool = False ) -> None Initialise an instance of SignedMessage.","title":"__init__"},{"location":"api/helpers/transaction/base/#ledger_id_3","text":"@property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"api/helpers/transaction/base/#body_3","text":"@property def body () -> str Get the body.","title":"body"},{"location":"api/helpers/transaction/base/#is_deprecated_mode_1","text":"@property def is_deprecated_mode () -> bool Get the is_deprecated_mode.","title":"is_deprecated_mode"},{"location":"api/helpers/transaction/base/#encode_3","text":"@staticmethod def encode ( signed_message_protobuf_object : Any , signed_message_object : \"SignedMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_message_protobuf_object argument must be matched with the instance of this class in the 'signed_message_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_message_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"api/helpers/transaction/base/#decode_3","text":"@classmethod def decode ( cls , signed_message_protobuf_object : Any ) -> \"SignedMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_message_protobuf_object' argument.","title":"decode"},{"location":"api/helpers/transaction/base/#__eq___3","text":"def __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"api/helpers/transaction/base/#__str___3","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/helpers/transaction/base/#state-objects","text":"class State () This class represents an instance of State.","title":"State Objects"},{"location":"api/helpers/transaction/base/#__init___4","text":"def __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of State.","title":"__init__"},{"location":"api/helpers/transaction/base/#ledger_id_4","text":"@property def ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"api/helpers/transaction/base/#body_4","text":"@property def body () -> JSONLike Get the body.","title":"body"},{"location":"api/helpers/transaction/base/#encode_4","text":"@staticmethod def encode ( state_protobuf_object : Any , state_object : \"State\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the state_protobuf_object argument must be matched with the instance of this class in the 'state_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. state_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"api/helpers/transaction/base/#decode_4","text":"@classmethod def decode ( cls , state_protobuf_object : Any ) -> \"State\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'state_protobuf_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'state_protobuf_object' argument.","title":"decode"},{"location":"api/helpers/transaction/base/#__eq___4","text":"def __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"api/helpers/transaction/base/#__str___4","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/helpers/transaction/base/#terms-objects","text":"class Terms () Class to represent the terms of a multi-currency & multi-token ledger transaction.","title":"Terms Objects"},{"location":"api/helpers/transaction/base/#__init___5","text":"","title":"__init__"},{"location":"api/identity/base/","text":"aea.identity.base This module contains the identity class. Identity Objects class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair) __ init __ def __init__ ( name : SimpleIdOrStr , address : Optional [ str ] = None , public_key : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , public_keys : Optional [ Dict [ str , str ]] = None , default_address_key : str = DEFAULT_LEDGER ) -> None Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. public_key : the public key of the agent. addresses : the addresses of the agent. public_keys : the public keys of the agent. default_address_key : the key for the default address. default _ address _ key @property def default_address_key () -> str Get the default address key. name @property def name () -> str Get the agent name. addresses @property def addresses () -> Dict [ str , Address ] Get the addresses. address @property def address () -> Address Get the default address. public _ keys @property def public_keys () -> Dict [ str , str ] Get the public keys. public _ key @property def public_key () -> str Get the default public key.","title":"Identity"},{"location":"api/identity/base/#aeaidentitybase","text":"This module contains the identity class.","title":"aea.identity.base"},{"location":"api/identity/base/#identity-objects","text":"class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair)","title":"Identity Objects"},{"location":"api/identity/base/#__init__","text":"def __init__ ( name : SimpleIdOrStr , address : Optional [ str ] = None , public_key : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , public_keys : Optional [ Dict [ str , str ]] = None , default_address_key : str = DEFAULT_LEDGER ) -> None Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. public_key : the public key of the agent. addresses : the addresses of the agent. public_keys : the public keys of the agent. default_address_key : the key for the default address.","title":"__init__"},{"location":"api/identity/base/#default_address_key","text":"@property def default_address_key () -> str Get the default address key.","title":"default_address_key"},{"location":"api/identity/base/#name","text":"@property def name () -> str Get the agent name.","title":"name"},{"location":"api/identity/base/#addresses","text":"@property def addresses () -> Dict [ str , Address ] Get the addresses.","title":"addresses"},{"location":"api/identity/base/#address","text":"@property def address () -> Address Get the default address.","title":"address"},{"location":"api/identity/base/#public_keys","text":"@property def public_keys () -> Dict [ str , str ] Get the public keys.","title":"public_keys"},{"location":"api/identity/base/#public_key","text":"@property def public_key () -> str Get the default public key.","title":"public_key"},{"location":"api/mail/base/","text":"aea.mail.base Mail module abstract base classes. URI Objects class URI () URI following RFC3986. __ init __ def __init__ ( uri_raw : str ) -> None Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri scheme @property def scheme () -> str Get the scheme. netloc @property def netloc () -> str Get the netloc. path @property def path () -> str Get the path. params @property def params () -> str Get the params. query @property def query () -> str Get the query. fragment @property def fragment () -> str Get the fragment. username @property def username () -> Optional [ str ] Get the username. password @property def password () -> Optional [ str ] Get the password. host @property def host () -> Optional [ str ] Get the host. port @property def port () -> Optional [ int ] Get the port. __ str __ def __str__ () -> str Get string representation. __ eq __ def __eq__ ( other : Any ) -> bool Compare with another object. EnvelopeContext Objects class EnvelopeContext () Contains context information of an envelope. __ init __ def __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) -> None Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. uri : the URI sent with the envelope. uri @property def uri () -> Optional [ URI ] Get the URI. connection _ id @property def connection_id () -> Optional [ PublicId ] Get the connection id to route the envelope. connection _ id @connection_id . setter def connection_id ( connection_id : PublicId ) -> None Set the 'via' connection id. __ str __ def __str__ () -> str Get the string representation. __ eq __ def __eq__ ( other : Any ) -> bool Compare with another object. AEAConnectionError Objects class AEAConnectionError ( Exception ) Exception class for connection errors. Empty Objects class Empty ( Exception ) Exception for when the inbox is empty. EnvelopeSerializer Objects class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope. encode @abstractmethod def encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode @abstractmethod def decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope ProtobufEnvelopeSerializer Objects class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf. encode def encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode def decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. The default serializer doesn't decode the message field. Arguments : envelope_bytes : the encoded envelope Returns : the envelope Envelope Objects class Envelope () The top level message class for agent to agent communication. __ init __ def __init__ ( to : Address , sender : Address , message : Union [ Message , bytes ], context : Optional [ EnvelopeContext ] = None , protocol_specification_id : Optional [ PublicId ] = None ) -> None Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. message : the protocol-specific message. context : the optional envelope context. protocol_specification_id : the protocol specification id (wire id). to @property def to () -> Address Get address of receiver. to @to . setter def to ( to : Address ) -> None Set address of receiver. sender @property def sender () -> Address Get address of sender. sender @sender . setter def sender ( sender : Address ) -> None Set address of sender. protocol _ specification _ id @property def protocol_specification_id () -> PublicId Get protocol_specification_id. message @property def message () -> Union [ Message , bytes ] Get the protocol-specific message. message @message . setter def message ( message : Union [ Message , bytes ]) -> None Set the protocol-specific message. message _ bytes @property def message_bytes () -> bytes Get the protocol-specific message. context @property def context () -> Optional [ EnvelopeContext ] Get the envelope context. to _ as _ public _ id @property def to_as_public_id () -> Optional [ PublicId ] Get to as public id. is _ sender _ public _ id @property def is_sender_public_id () -> bool Check if sender is a public id. is _ to _ public _ id @property def is_to_public_id () -> bool Check if to is a public id. is _ component _ to _ component _ message @property def is_component_to_component_message () -> bool Whether or not the message contained is component to component. __ eq __ def __eq__ ( other : Any ) -> bool Compare with another object. encode def encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope. decode @classmethod def decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope. __ str __ def __str__ () -> str Get the string representation of an envelope.","title":"Mail"},{"location":"api/mail/base/#aeamailbase","text":"Mail module abstract base classes.","title":"aea.mail.base"},{"location":"api/mail/base/#uri-objects","text":"class URI () URI following RFC3986.","title":"URI Objects"},{"location":"api/mail/base/#__init__","text":"def __init__ ( uri_raw : str ) -> None Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri","title":"__init__"},{"location":"api/mail/base/#scheme","text":"@property def scheme () -> str Get the scheme.","title":"scheme"},{"location":"api/mail/base/#netloc","text":"@property def netloc () -> str Get the netloc.","title":"netloc"},{"location":"api/mail/base/#path","text":"@property def path () -> str Get the path.","title":"path"},{"location":"api/mail/base/#params","text":"@property def params () -> str Get the params.","title":"params"},{"location":"api/mail/base/#query","text":"@property def query () -> str Get the query.","title":"query"},{"location":"api/mail/base/#fragment","text":"@property def fragment () -> str Get the fragment.","title":"fragment"},{"location":"api/mail/base/#username","text":"@property def username () -> Optional [ str ] Get the username.","title":"username"},{"location":"api/mail/base/#password","text":"@property def password () -> Optional [ str ] Get the password.","title":"password"},{"location":"api/mail/base/#host","text":"@property def host () -> Optional [ str ] Get the host.","title":"host"},{"location":"api/mail/base/#port","text":"@property def port () -> Optional [ int ] Get the port.","title":"port"},{"location":"api/mail/base/#__str__","text":"def __str__ () -> str Get string representation.","title":"__str__"},{"location":"api/mail/base/#__eq__","text":"def __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"api/mail/base/#envelopecontext-objects","text":"class EnvelopeContext () Contains context information of an envelope.","title":"EnvelopeContext Objects"},{"location":"api/mail/base/#__init___1","text":"def __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) -> None Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. uri : the URI sent with the envelope.","title":"__init__"},{"location":"api/mail/base/#uri","text":"@property def uri () -> Optional [ URI ] Get the URI.","title":"uri"},{"location":"api/mail/base/#connection_id","text":"@property def connection_id () -> Optional [ PublicId ] Get the connection id to route the envelope.","title":"connection_id"},{"location":"api/mail/base/#connection_id_1","text":"@connection_id . setter def connection_id ( connection_id : PublicId ) -> None Set the 'via' connection id.","title":"connection_id"},{"location":"api/mail/base/#__str___1","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/mail/base/#__eq___1","text":"def __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"api/mail/base/#aeaconnectionerror-objects","text":"class AEAConnectionError ( Exception ) Exception class for connection errors.","title":"AEAConnectionError Objects"},{"location":"api/mail/base/#empty-objects","text":"class Empty ( Exception ) Exception for when the inbox is empty.","title":"Empty Objects"},{"location":"api/mail/base/#envelopeserializer-objects","text":"class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope.","title":"EnvelopeSerializer Objects"},{"location":"api/mail/base/#encode","text":"@abstractmethod def encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"api/mail/base/#decode","text":"@abstractmethod def decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"api/mail/base/#protobufenvelopeserializer-objects","text":"class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf.","title":"ProtobufEnvelopeSerializer Objects"},{"location":"api/mail/base/#encode_1","text":"def encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"api/mail/base/#decode_1","text":"def decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. The default serializer doesn't decode the message field. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"api/mail/base/#envelope-objects","text":"class Envelope () The top level message class for agent to agent communication.","title":"Envelope Objects"},{"location":"api/mail/base/#__init___2","text":"def __init__ ( to : Address , sender : Address , message : Union [ Message , bytes ], context : Optional [ EnvelopeContext ] = None , protocol_specification_id : Optional [ PublicId ] = None ) -> None Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. message : the protocol-specific message. context : the optional envelope context. protocol_specification_id : the protocol specification id (wire id).","title":"__init__"},{"location":"api/mail/base/#to","text":"@property def to () -> Address Get address of receiver.","title":"to"},{"location":"api/mail/base/#to_1","text":"@to . setter def to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"api/mail/base/#sender","text":"@property def sender () -> Address Get address of sender.","title":"sender"},{"location":"api/mail/base/#sender_1","text":"@sender . setter def sender ( sender : Address ) -> None Set address of sender.","title":"sender"},{"location":"api/mail/base/#protocol_specification_id","text":"@property def protocol_specification_id () -> PublicId Get protocol_specification_id.","title":"protocol_specification_id"},{"location":"api/mail/base/#message","text":"@property def message () -> Union [ Message , bytes ] Get the protocol-specific message.","title":"message"},{"location":"api/mail/base/#message_1","text":"@message . setter def message ( message : Union [ Message , bytes ]) -> None Set the protocol-specific message.","title":"message"},{"location":"api/mail/base/#message_bytes","text":"@property def message_bytes () -> bytes Get the protocol-specific message.","title":"message_bytes"},{"location":"api/mail/base/#context","text":"@property def context () -> Optional [ EnvelopeContext ] Get the envelope context.","title":"context"},{"location":"api/mail/base/#to_as_public_id","text":"@property def to_as_public_id () -> Optional [ PublicId ] Get to as public id.","title":"to_as_public_id"},{"location":"api/mail/base/#is_sender_public_id","text":"@property def is_sender_public_id () -> bool Check if sender is a public id.","title":"is_sender_public_id"},{"location":"api/mail/base/#is_to_public_id","text":"@property def is_to_public_id () -> bool Check if to is a public id.","title":"is_to_public_id"},{"location":"api/mail/base/#is_component_to_component_message","text":"@property def is_component_to_component_message () -> bool Whether or not the message contained is component to component.","title":"is_component_to_component_message"},{"location":"api/mail/base/#__eq___2","text":"def __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"api/mail/base/#encode_2","text":"def encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope.","title":"encode"},{"location":"api/mail/base/#decode_2","text":"@classmethod def decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope.","title":"decode"},{"location":"api/mail/base/#__str___2","text":"def __str__ () -> str Get the string representation of an envelope.","title":"__str__"},{"location":"api/manager/helpers/","text":"aea.manager.helpers Project helper tools. AEAProject Objects class AEAProject () A context manager class to create and delete an AEA project. __ init __ def __init__ ( name : str = \"my_aea\" , parent_dir : Optional [ str ] = None ) Initialize an AEA project. Arguments : name : the name of the AEA project. parent_dir : the parent directory. __ enter __ def __enter__ () -> None Create and enter into the project. __ exit __ def __exit__ ( exc_type , exc_val , exc_tb ) -> None Exit the context manager. run _ cli @staticmethod def run_cli ( * args : Any , ** kwargs : Any ) -> None Run a CLI command. run _ aea @classmethod def run_aea ( cls , * args : Any , ** kwargs : Any ) -> None Run an AEA command. Arguments : args : the AEA command kwargs : keyword arguments to subprocess function","title":"Helpers"},{"location":"api/manager/helpers/#aeamanagerhelpers","text":"Project helper tools.","title":"aea.manager.helpers"},{"location":"api/manager/helpers/#aeaproject-objects","text":"class AEAProject () A context manager class to create and delete an AEA project.","title":"AEAProject Objects"},{"location":"api/manager/helpers/#__init__","text":"def __init__ ( name : str = \"my_aea\" , parent_dir : Optional [ str ] = None ) Initialize an AEA project. Arguments : name : the name of the AEA project. parent_dir : the parent directory.","title":"__init__"},{"location":"api/manager/helpers/#__enter__","text":"def __enter__ () -> None Create and enter into the project.","title":"__enter__"},{"location":"api/manager/helpers/#__exit__","text":"def __exit__ ( exc_type , exc_val , exc_tb ) -> None Exit the context manager.","title":"__exit__"},{"location":"api/manager/helpers/#run_cli","text":"@staticmethod def run_cli ( * args : Any , ** kwargs : Any ) -> None Run a CLI command.","title":"run_cli"},{"location":"api/manager/helpers/#run_aea","text":"@classmethod def run_aea ( cls , * args : Any , ** kwargs : Any ) -> None Run an AEA command. Arguments : args : the AEA command kwargs : keyword arguments to subprocess function","title":"run_aea"},{"location":"api/manager/manager/","text":"aea.manager.manager This module contains the implementation of AEA agents manager. ProjectNotFoundError Objects class ProjectNotFoundError ( ValueError ) Project not found exception. ProjectCheckError Objects class ProjectCheckError ( ValueError ) Project check error exception. __ init __ def __init__ ( msg : str , source_exception : Exception ) Init exception. ProjectPackageConsistencyCheckError Objects class ProjectPackageConsistencyCheckError ( ValueError ) Check consistency of package versions against already added project. __ init __ def __init__ ( agent_project_id : PublicId , conflicting_packages : List [ Tuple [ PackageIdPrefix , str , str , Set [ PublicId ]]]) Initialize the exception. Arguments : agent_project_id : the agent project id whose addition has failed. conflicting_packages : the conflicting packages. BaseAgentRunTask Objects class BaseAgentRunTask ( ABC ) Base abstract class for agent run tasks. start @abstractmethod def start () -> None Start task. wait @abstractmethod def wait () -> asyncio . Future Return future to wait task completed. stop @abstractmethod def stop () -> None Stop task. is _ running @property @abstractmethod def is_running () -> bool Return is task running. AgentRunAsyncTask Objects class AgentRunAsyncTask ( BaseAgentRunTask ) Async task wrapper for agent. __ init __ def __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop. create _ run _ loop def create_run_loop () -> None Create run loop. start def start () -> None Start task. wait def wait () -> asyncio . Future Return future to wait task completed. stop def stop () -> None Stop task. run async def run () -> None Run task body. is _ running @property def is_running () -> bool Return is task running. AgentRunThreadTask Objects class AgentRunThreadTask ( AgentRunAsyncTask ) Threaded wrapper to run agent. __ init __ def __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop. create _ run _ loop def create_run_loop () -> None Create run loop. start def start () -> None Run task in a dedicated thread. stop def stop () -> None Stop the task. AgentRunProcessTask Objects class AgentRunProcessTask ( BaseAgentRunTask ) Subprocess wrapper to run agent. __ init __ def __init__ ( agent_alias : AgentAlias , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop. start def start () -> None Run task in a dedicated process. wait def wait () -> asyncio . Future Return future to wait task completed. stop def stop () -> None Stop the task. is _ running @property def is_running () -> bool Is agent running. MultiAgentManager Objects class MultiAgentManager () Multi agents manager. __ init __ def __init__ ( working_dir : str , mode : str = \"async\" , registry_path : str = DEFAULT_REGISTRY_NAME , auto_add_remove_project : bool = False , password : Optional [ str ] = None ) -> None Initialize manager. Arguments : working_dir : directory to store base agents. mode : str. async or threaded registry_path : str. path to the local packages registry auto_add_remove_project : bool. add/remove project on the first agent add/last agent remove password : the password to encrypt/decrypt the private key. data _ dir @property def data_dir () -> str Get the certs directory. get _ data _ dir _ of _ agent def get_data_dir_of_agent ( agent_name : str ) -> str Get the data directory of a specific agent. is _ running @property def is_running () -> bool Is manager running. dict _ state @property def dict_state () -> Dict [ str , Any ] Create MultiAgentManager dist state. projects @property def projects () -> Dict [ PublicId , Project ] Get all projects. add _ error _ callback def add_error_callback ( error_callback : Callable [[ str , BaseException ], None ]) -> \"MultiAgentManager\" Add error callback to call on error raised. start _ manager def start_manager ( local : bool = False , remote : bool = False ) -> \"MultiAgentManager\" Start manager. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. Returns : the MultiAgentManager instance. last _ start _ status @property def last_start_status () -> Tuple [ bool , Dict [ PublicId , List [ Dict ]], List [ Tuple [ PublicId , List [ Dict ], Exception ]], ] Get status of the last agents start loading state. stop _ manager def stop_manager ( cleanup : bool = True , save : bool = False ) -> \"MultiAgentManager\" Stop manager. Stops all running agents and stop agent. Arguments : cleanup : bool is cleanup on stop. save : bool is save state to file on stop. Returns : None add _ project def add_project ( public_id : PublicId , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Fetch agent project and all dependencies to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : public_id : the public if of the agent project. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self remove _ project def remove_project ( public_id : PublicId , keep_files : bool = False ) -> \"MultiAgentManager\" Remove agent project. list _ projects def list_projects () -> List [ PublicId ] List all agents projects added. Returns : list of public ids of projects add _ agent def add_agent ( public_id : PublicId , agent_name : Optional [ str ] = None , agent_overrides : Optional [ dict ] = None , component_overrides : Optional [ List [ dict ]] = None , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Create new agent configuration based on project with config overrides applied. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent agent_overrides : overrides for agent config. component_overrides : overrides for component section. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self add _ agent _ with _ config def add_agent_with_config ( public_id : PublicId , config : List [ dict ], agent_name : Optional [ str ] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config provided. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent config : agent config (used for agent re-creation). Returns : manager get _ agent _ overridables def get_agent_overridables ( agent_name : str ) -> Tuple [ Dict , List [ Dict ]] Get agent config overridables. Arguments : agent_name : str Returns : Tuple of agent overridables dict and and list of component overridables dict. set _ agent _ overrides def set_agent_overrides ( agent_name : str , agent_overides : Optional [ Dict ], components_overrides : Optional [ List [ Dict ]]) -> \"MultiAgentManager\" Set agent overrides. Arguments : agent_name : str agent_overides : optional dict of agent config overrides components_overrides : optional list of dict of components overrides Returns : self list _ agents _ info def list_agents_info () -> List [ Dict [ str , Any ]] List agents detailed info. Returns : list of dicts that represents agent info: public_id, name, is_running. list _ agents def list_agents ( running_only : bool = False ) -> List [ str ] List all agents. Arguments : running_only : returns only running if set to True Returns : list of agents names remove _ agent def remove_agent ( agent_name : str , skip_project_auto_remove : bool = False ) -> \"MultiAgentManager\" Remove agent alias definition from registry. Arguments : agent_name : agent name to remove skip_project_auto_remove : disable auto project remove on last agent removed. Returns : None start _ agent def start_agent ( agent_name : str ) -> \"MultiAgentManager\" Start selected agent. Arguments : agent_name : agent name to start Returns : None start _ all _ agents def start_all_agents () -> \"MultiAgentManager\" Start all not started agents. Returns : None stop _ agent def stop_agent ( agent_name : str ) -> \"MultiAgentManager\" Stop running agent. Arguments : agent_name : agent name to stop Returns : self stop _ all _ agents def stop_all_agents () -> \"MultiAgentManager\" Stop all agents running. Returns : self stop _ agents def stop_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self start _ agents def start_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self get _ agent _ alias def get_agent_alias ( agent_name : str ) -> AgentAlias Return details about agent alias definition. Arguments : agent_name : name of agent Returns : AgentAlias","title":"Manager"},{"location":"api/manager/manager/#aeamanagermanager","text":"This module contains the implementation of AEA agents manager.","title":"aea.manager.manager"},{"location":"api/manager/manager/#projectnotfounderror-objects","text":"class ProjectNotFoundError ( ValueError ) Project not found exception.","title":"ProjectNotFoundError Objects"},{"location":"api/manager/manager/#projectcheckerror-objects","text":"class ProjectCheckError ( ValueError ) Project check error exception.","title":"ProjectCheckError Objects"},{"location":"api/manager/manager/#__init__","text":"def __init__ ( msg : str , source_exception : Exception ) Init exception.","title":"__init__"},{"location":"api/manager/manager/#projectpackageconsistencycheckerror-objects","text":"class ProjectPackageConsistencyCheckError ( ValueError ) Check consistency of package versions against already added project.","title":"ProjectPackageConsistencyCheckError Objects"},{"location":"api/manager/manager/#__init___1","text":"def __init__ ( agent_project_id : PublicId , conflicting_packages : List [ Tuple [ PackageIdPrefix , str , str , Set [ PublicId ]]]) Initialize the exception. Arguments : agent_project_id : the agent project id whose addition has failed. conflicting_packages : the conflicting packages.","title":"__init__"},{"location":"api/manager/manager/#baseagentruntask-objects","text":"class BaseAgentRunTask ( ABC ) Base abstract class for agent run tasks.","title":"BaseAgentRunTask Objects"},{"location":"api/manager/manager/#start","text":"@abstractmethod def start () -> None Start task.","title":"start"},{"location":"api/manager/manager/#wait","text":"@abstractmethod def wait () -> asyncio . Future Return future to wait task completed.","title":"wait"},{"location":"api/manager/manager/#stop","text":"@abstractmethod def stop () -> None Stop task.","title":"stop"},{"location":"api/manager/manager/#is_running","text":"@property @abstractmethod def is_running () -> bool Return is task running.","title":"is_running"},{"location":"api/manager/manager/#agentrunasynctask-objects","text":"class AgentRunAsyncTask ( BaseAgentRunTask ) Async task wrapper for agent.","title":"AgentRunAsyncTask Objects"},{"location":"api/manager/manager/#__init___2","text":"def __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop.","title":"__init__"},{"location":"api/manager/manager/#create_run_loop","text":"def create_run_loop () -> None Create run loop.","title":"create_run_loop"},{"location":"api/manager/manager/#start_1","text":"def start () -> None Start task.","title":"start"},{"location":"api/manager/manager/#wait_1","text":"def wait () -> asyncio . Future Return future to wait task completed.","title":"wait"},{"location":"api/manager/manager/#stop_1","text":"def stop () -> None Stop task.","title":"stop"},{"location":"api/manager/manager/#run","text":"async def run () -> None Run task body.","title":"run"},{"location":"api/manager/manager/#is_running_1","text":"@property def is_running () -> bool Return is task running.","title":"is_running"},{"location":"api/manager/manager/#agentrunthreadtask-objects","text":"class AgentRunThreadTask ( AgentRunAsyncTask ) Threaded wrapper to run agent.","title":"AgentRunThreadTask Objects"},{"location":"api/manager/manager/#__init___3","text":"def __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop.","title":"__init__"},{"location":"api/manager/manager/#create_run_loop_1","text":"def create_run_loop () -> None Create run loop.","title":"create_run_loop"},{"location":"api/manager/manager/#start_2","text":"def start () -> None Run task in a dedicated thread.","title":"start"},{"location":"api/manager/manager/#stop_2","text":"def stop () -> None Stop the task.","title":"stop"},{"location":"api/manager/manager/#agentrunprocesstask-objects","text":"class AgentRunProcessTask ( BaseAgentRunTask ) Subprocess wrapper to run agent.","title":"AgentRunProcessTask Objects"},{"location":"api/manager/manager/#__init___4","text":"def __init__ ( agent_alias : AgentAlias , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop.","title":"__init__"},{"location":"api/manager/manager/#start_3","text":"def start () -> None Run task in a dedicated process.","title":"start"},{"location":"api/manager/manager/#wait_2","text":"def wait () -> asyncio . Future Return future to wait task completed.","title":"wait"},{"location":"api/manager/manager/#stop_3","text":"def stop () -> None Stop the task.","title":"stop"},{"location":"api/manager/manager/#is_running_2","text":"@property def is_running () -> bool Is agent running.","title":"is_running"},{"location":"api/manager/manager/#multiagentmanager-objects","text":"class MultiAgentManager () Multi agents manager.","title":"MultiAgentManager Objects"},{"location":"api/manager/manager/#__init___5","text":"def __init__ ( working_dir : str , mode : str = \"async\" , registry_path : str = DEFAULT_REGISTRY_NAME , auto_add_remove_project : bool = False , password : Optional [ str ] = None ) -> None Initialize manager. Arguments : working_dir : directory to store base agents. mode : str. async or threaded registry_path : str. path to the local packages registry auto_add_remove_project : bool. add/remove project on the first agent add/last agent remove password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"api/manager/manager/#data_dir","text":"@property def data_dir () -> str Get the certs directory.","title":"data_dir"},{"location":"api/manager/manager/#get_data_dir_of_agent","text":"def get_data_dir_of_agent ( agent_name : str ) -> str Get the data directory of a specific agent.","title":"get_data_dir_of_agent"},{"location":"api/manager/manager/#is_running_3","text":"@property def is_running () -> bool Is manager running.","title":"is_running"},{"location":"api/manager/manager/#dict_state","text":"@property def dict_state () -> Dict [ str , Any ] Create MultiAgentManager dist state.","title":"dict_state"},{"location":"api/manager/manager/#projects","text":"@property def projects () -> Dict [ PublicId , Project ] Get all projects.","title":"projects"},{"location":"api/manager/manager/#add_error_callback","text":"def add_error_callback ( error_callback : Callable [[ str , BaseException ], None ]) -> \"MultiAgentManager\" Add error callback to call on error raised.","title":"add_error_callback"},{"location":"api/manager/manager/#start_manager","text":"def start_manager ( local : bool = False , remote : bool = False ) -> \"MultiAgentManager\" Start manager. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. Returns : the MultiAgentManager instance.","title":"start_manager"},{"location":"api/manager/manager/#last_start_status","text":"@property def last_start_status () -> Tuple [ bool , Dict [ PublicId , List [ Dict ]], List [ Tuple [ PublicId , List [ Dict ], Exception ]], ] Get status of the last agents start loading state.","title":"last_start_status"},{"location":"api/manager/manager/#stop_manager","text":"def stop_manager ( cleanup : bool = True , save : bool = False ) -> \"MultiAgentManager\" Stop manager. Stops all running agents and stop agent. Arguments : cleanup : bool is cleanup on stop. save : bool is save state to file on stop. Returns : None","title":"stop_manager"},{"location":"api/manager/manager/#add_project","text":"def add_project ( public_id : PublicId , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Fetch agent project and all dependencies to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : public_id : the public if of the agent project. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self","title":"add_project"},{"location":"api/manager/manager/#remove_project","text":"def remove_project ( public_id : PublicId , keep_files : bool = False ) -> \"MultiAgentManager\" Remove agent project.","title":"remove_project"},{"location":"api/manager/manager/#list_projects","text":"def list_projects () -> List [ PublicId ] List all agents projects added. Returns : list of public ids of projects","title":"list_projects"},{"location":"api/manager/manager/#add_agent","text":"def add_agent ( public_id : PublicId , agent_name : Optional [ str ] = None , agent_overrides : Optional [ dict ] = None , component_overrides : Optional [ List [ dict ]] = None , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Create new agent configuration based on project with config overrides applied. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent agent_overrides : overrides for agent config. component_overrides : overrides for component section. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self","title":"add_agent"},{"location":"api/manager/manager/#add_agent_with_config","text":"def add_agent_with_config ( public_id : PublicId , config : List [ dict ], agent_name : Optional [ str ] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config provided. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent config : agent config (used for agent re-creation). Returns : manager","title":"add_agent_with_config"},{"location":"api/manager/manager/#get_agent_overridables","text":"def get_agent_overridables ( agent_name : str ) -> Tuple [ Dict , List [ Dict ]] Get agent config overridables. Arguments : agent_name : str Returns : Tuple of agent overridables dict and and list of component overridables dict.","title":"get_agent_overridables"},{"location":"api/manager/manager/#set_agent_overrides","text":"def set_agent_overrides ( agent_name : str , agent_overides : Optional [ Dict ], components_overrides : Optional [ List [ Dict ]]) -> \"MultiAgentManager\" Set agent overrides. Arguments : agent_name : str agent_overides : optional dict of agent config overrides components_overrides : optional list of dict of components overrides Returns : self","title":"set_agent_overrides"},{"location":"api/manager/manager/#list_agents_info","text":"def list_agents_info () -> List [ Dict [ str , Any ]] List agents detailed info. Returns : list of dicts that represents agent info: public_id, name, is_running.","title":"list_agents_info"},{"location":"api/manager/manager/#list_agents","text":"def list_agents ( running_only : bool = False ) -> List [ str ] List all agents. Arguments : running_only : returns only running if set to True Returns : list of agents names","title":"list_agents"},{"location":"api/manager/manager/#remove_agent","text":"def remove_agent ( agent_name : str , skip_project_auto_remove : bool = False ) -> \"MultiAgentManager\" Remove agent alias definition from registry. Arguments : agent_name : agent name to remove skip_project_auto_remove : disable auto project remove on last agent removed. Returns : None","title":"remove_agent"},{"location":"api/manager/manager/#start_agent","text":"def start_agent ( agent_name : str ) -> \"MultiAgentManager\" Start selected agent. Arguments : agent_name : agent name to start Returns : None","title":"start_agent"},{"location":"api/manager/manager/#start_all_agents","text":"def start_all_agents () -> \"MultiAgentManager\" Start all not started agents. Returns : None","title":"start_all_agents"},{"location":"api/manager/manager/#stop_agent","text":"def stop_agent ( agent_name : str ) -> \"MultiAgentManager\" Stop running agent. Arguments : agent_name : agent name to stop Returns : self","title":"stop_agent"},{"location":"api/manager/manager/#stop_all_agents","text":"def stop_all_agents () -> \"MultiAgentManager\" Stop all agents running. Returns : self","title":"stop_all_agents"},{"location":"api/manager/manager/#stop_agents","text":"def stop_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self","title":"stop_agents"},{"location":"api/manager/manager/#start_agents","text":"def start_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self","title":"start_agents"},{"location":"api/manager/manager/#get_agent_alias","text":"def get_agent_alias ( agent_name : str ) -> AgentAlias Return details about agent alias definition. Arguments : agent_name : name of agent Returns : AgentAlias","title":"get_agent_alias"},{"location":"api/manager/project/","text":"aea.manager.project This module contains the implementation of AEA agents project configuration. _ Base Objects class _Base () Base class to share some methods. builder @property def builder () -> AEABuilder Get AEABuilder instance. install _ pypi _ dependencies def install_pypi_dependencies () -> None Install python dependencies for the project. Project Objects class Project ( _Base ) Agent project representation. __ init __ def __init__ ( public_id : PublicId , path : str ) -> None Init project with public_id and project's path. build def build () -> None Call all build entry points. load @classmethod def load ( cls , working_dir : str , public_id : PublicId , is_local : bool = False , is_remote : bool = False , is_restore : bool = False , cli_verbosity : str = \"INFO\" , registry_path : str = DEFAULT_REGISTRY_NAME , skip_consistency_check : bool = False , skip_aea_validation : bool = False ) -> \"Project\" Load project with given public_id to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : working_dir : the working directory public_id : the public id is_local : whether to fetch from local is_remote : whether to fetch from remote is_restore : whether to restore or not cli_verbosity : the logging verbosity of the CLI registry_path : the path to the registry locally skip_consistency_check : consistency checks flag skip_aea_validation : aea validation flag Returns : project remove def remove () -> None Remove project, do cleanup. agent _ config @property def agent_config () -> AgentConfig Get the agent configuration. builder @property def builder () -> AEABuilder Get builder instance. check def check () -> None Check we can still construct an AEA from the project with builder.build. AgentAlias Objects class AgentAlias ( _Base ) Agent alias representation. __ init __ def __init__ ( project : Project , agent_name : str , data_dir : str , password : Optional [ str ] = None ) Init agent alias with project, config, name, agent, builder. set _ agent _ config _ from _ data def set_agent_config_from_data ( json_data : List [ Dict ]) -> None Set agent config instance constructed from json data. Arguments : json_data : agent config json data builder @property def builder () -> AEABuilder Get builder instance. agent _ config @property def agent_config () -> AgentConfig Get agent config. remove _ from _ project def remove_from_project () -> None Remove agent alias from project. dict @property def dict () -> Dict [ str , Any ] Convert AgentAlias to dict. config _ json @property def config_json () -> List [ Dict ] Get agent config json data. get _ aea _ instance def get_aea_instance () -> AEA Build new aea instance. issue _ certificates def issue_certificates () -> None Issue the certificates for this agent. set _ overrides def set_overrides ( agent_overrides : Optional [ Dict ] = None , component_overrides : Optional [ List [ Dict ]] = None ) -> None Set override for this agent alias's config. agent _ config _ manager @property def agent_config_manager () -> AgentConfigManager Get agent configuration manager instance for the config. get _ overridables def get_overridables () -> Tuple [ Dict , List [ Dict ]] Get all overridables for this agent alias's config. get _ addresses def get_addresses () -> Dict [ str , str ] Get addresses from private keys. Returns : dict with crypto id str as key and address str as value get _ connections _ addresses def get_connections_addresses () -> Dict [ str , str ] Get connections addresses from connections private keys. Returns : dict with crypto id str as key and address str as value","title":"Project"},{"location":"api/manager/project/#aeamanagerproject","text":"This module contains the implementation of AEA agents project configuration.","title":"aea.manager.project"},{"location":"api/manager/project/#_base-objects","text":"class _Base () Base class to share some methods.","title":"_Base Objects"},{"location":"api/manager/project/#builder","text":"@property def builder () -> AEABuilder Get AEABuilder instance.","title":"builder"},{"location":"api/manager/project/#install_pypi_dependencies","text":"def install_pypi_dependencies () -> None Install python dependencies for the project.","title":"install_pypi_dependencies"},{"location":"api/manager/project/#project-objects","text":"class Project ( _Base ) Agent project representation.","title":"Project Objects"},{"location":"api/manager/project/#__init__","text":"def __init__ ( public_id : PublicId , path : str ) -> None Init project with public_id and project's path.","title":"__init__"},{"location":"api/manager/project/#build","text":"def build () -> None Call all build entry points.","title":"build"},{"location":"api/manager/project/#load","text":"@classmethod def load ( cls , working_dir : str , public_id : PublicId , is_local : bool = False , is_remote : bool = False , is_restore : bool = False , cli_verbosity : str = \"INFO\" , registry_path : str = DEFAULT_REGISTRY_NAME , skip_consistency_check : bool = False , skip_aea_validation : bool = False ) -> \"Project\" Load project with given public_id to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : working_dir : the working directory public_id : the public id is_local : whether to fetch from local is_remote : whether to fetch from remote is_restore : whether to restore or not cli_verbosity : the logging verbosity of the CLI registry_path : the path to the registry locally skip_consistency_check : consistency checks flag skip_aea_validation : aea validation flag Returns : project","title":"load"},{"location":"api/manager/project/#remove","text":"def remove () -> None Remove project, do cleanup.","title":"remove"},{"location":"api/manager/project/#agent_config","text":"@property def agent_config () -> AgentConfig Get the agent configuration.","title":"agent_config"},{"location":"api/manager/project/#builder_1","text":"@property def builder () -> AEABuilder Get builder instance.","title":"builder"},{"location":"api/manager/project/#check","text":"def check () -> None Check we can still construct an AEA from the project with builder.build.","title":"check"},{"location":"api/manager/project/#agentalias-objects","text":"class AgentAlias ( _Base ) Agent alias representation.","title":"AgentAlias Objects"},{"location":"api/manager/project/#__init___1","text":"def __init__ ( project : Project , agent_name : str , data_dir : str , password : Optional [ str ] = None ) Init agent alias with project, config, name, agent, builder.","title":"__init__"},{"location":"api/manager/project/#set_agent_config_from_data","text":"def set_agent_config_from_data ( json_data : List [ Dict ]) -> None Set agent config instance constructed from json data. Arguments : json_data : agent config json data","title":"set_agent_config_from_data"},{"location":"api/manager/project/#builder_2","text":"@property def builder () -> AEABuilder Get builder instance.","title":"builder"},{"location":"api/manager/project/#agent_config_1","text":"@property def agent_config () -> AgentConfig Get agent config.","title":"agent_config"},{"location":"api/manager/project/#remove_from_project","text":"def remove_from_project () -> None Remove agent alias from project.","title":"remove_from_project"},{"location":"api/manager/project/#dict","text":"@property def dict () -> Dict [ str , Any ] Convert AgentAlias to dict.","title":"dict"},{"location":"api/manager/project/#config_json","text":"@property def config_json () -> List [ Dict ] Get agent config json data.","title":"config_json"},{"location":"api/manager/project/#get_aea_instance","text":"def get_aea_instance () -> AEA Build new aea instance.","title":"get_aea_instance"},{"location":"api/manager/project/#issue_certificates","text":"def issue_certificates () -> None Issue the certificates for this agent.","title":"issue_certificates"},{"location":"api/manager/project/#set_overrides","text":"def set_overrides ( agent_overrides : Optional [ Dict ] = None , component_overrides : Optional [ List [ Dict ]] = None ) -> None Set override for this agent alias's config.","title":"set_overrides"},{"location":"api/manager/project/#agent_config_manager","text":"@property def agent_config_manager () -> AgentConfigManager Get agent configuration manager instance for the config.","title":"agent_config_manager"},{"location":"api/manager/project/#get_overridables","text":"def get_overridables () -> Tuple [ Dict , List [ Dict ]] Get all overridables for this agent alias's config.","title":"get_overridables"},{"location":"api/manager/project/#get_addresses","text":"def get_addresses () -> Dict [ str , str ] Get addresses from private keys. Returns : dict with crypto id str as key and address str as value","title":"get_addresses"},{"location":"api/manager/project/#get_connections_addresses","text":"def get_connections_addresses () -> Dict [ str , str ] Get connections addresses from connections private keys. Returns : dict with crypto id str as key and address str as value","title":"get_connections_addresses"},{"location":"api/manager/utils/","text":"aea.manager.utils Multiagent manager utils. get _ lib _ path def get_lib_path ( env_dir : str ) -> str Get librarty path for env dir. make _ venv def make_venv ( env_dir : str , set_env : bool = False ) -> None Make venv and update variable to use it. Arguments : env_dir : str, path for new env dir set_env : bool. use evn within this python process (update, sys.executable and sys.path) project _ install _ and _ build def project_install_and_build ( project : Project ) -> None Install project dependencies and build required components. get _ venv _ dir _ for _ project def get_venv_dir_for_project ( project : Project ) -> str Get virtual env directory for project specified. project _ check def project_check ( project : Project ) -> None Perform project loads well. run _ in _ venv def run_in_venv ( env_dir : str , fn : Callable , timeout : float , * args : Any ) -> Any Run python function in a dedicated process with virtual env specified.","title":"Utils"},{"location":"api/manager/utils/#aeamanagerutils","text":"Multiagent manager utils.","title":"aea.manager.utils"},{"location":"api/manager/utils/#get_lib_path","text":"def get_lib_path ( env_dir : str ) -> str Get librarty path for env dir.","title":"get_lib_path"},{"location":"api/manager/utils/#make_venv","text":"def make_venv ( env_dir : str , set_env : bool = False ) -> None Make venv and update variable to use it. Arguments : env_dir : str, path for new env dir set_env : bool. use evn within this python process (update, sys.executable and sys.path)","title":"make_venv"},{"location":"api/manager/utils/#project_install_and_build","text":"def project_install_and_build ( project : Project ) -> None Install project dependencies and build required components.","title":"project_install_and_build"},{"location":"api/manager/utils/#get_venv_dir_for_project","text":"def get_venv_dir_for_project ( project : Project ) -> str Get virtual env directory for project specified.","title":"get_venv_dir_for_project"},{"location":"api/manager/utils/#project_check","text":"def project_check ( project : Project ) -> None Perform project loads well.","title":"project_check"},{"location":"api/manager/utils/#run_in_venv","text":"def run_in_venv ( env_dir : str , fn : Callable , timeout : float , * args : Any ) -> Any Run python function in a dedicated process with virtual env specified.","title":"run_in_venv"},{"location":"api/plugins/aea_cli_ipfs/core/","text":"plugins.aea-cli-ipfs.aea _ cli _ ipfs.core Core components for ipfs cli command . ipfs @click . group () @click . pass_context def ipfs ( click_context : click . Context ) -> None IPFS Commands process _ result @ipfs . resultcallback () @click . pass_context def process_result ( click_context : click . Context , * _ : Any , ** __ : Any ) -> None Tear down command group. add @ipfs . command () @click . argument ( \"dir_path\" , type = click . Path ( exists = True , dir_okay = True , file_okay = False , resolve_path = True , readable = True ), required = False , ) @click . option ( \"-p\" , \"--publish\" , is_flag = True ) @click . option ( \"--no-pin\" , is_flag = True ) @click . pass_context def add ( click_context : click . Context , dir_path : Optional [ str ], publish : bool = False , no_pin : bool = False ) -> None Add directory to ipfs, if not directory specified the current one will be added. remove @ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . pass_context def remove ( click_context : click . Context , hash_ : str ) -> None Remove a directory from ipfs by it's hash. download @ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . argument ( \"target_dir\" , type = click . Path ( dir_okay = True , file_okay = False , resolve_path = True ), required = False , ) @click . pass_context def download ( click_context : click . Context , hash_ : str , target_dir : Optional [ str ]) -> None Download directory by it's hash, if not target directory specified will use current one. register _ package def register_package ( ipfs_tool : IPFSTool , dir_path : str , no_pin : bool ) -> str Register package to IPFS registry. Arguments : ipfs_tool : instance of IPFSTool. dir_path : package directory. no_pin : pin object or not. Returns : package hash","title":"API"},{"location":"api/plugins/aea_cli_ipfs/core/#pluginsaea-cli-ipfsaea_cli_ipfscore","text":"Core components for ipfs cli command .","title":"plugins.aea-cli-ipfs.aea_cli_ipfs.core"},{"location":"api/plugins/aea_cli_ipfs/core/#ipfs","text":"@click . group () @click . pass_context def ipfs ( click_context : click . Context ) -> None IPFS Commands","title":"ipfs"},{"location":"api/plugins/aea_cli_ipfs/core/#process_result","text":"@ipfs . resultcallback () @click . pass_context def process_result ( click_context : click . Context , * _ : Any , ** __ : Any ) -> None Tear down command group.","title":"process_result"},{"location":"api/plugins/aea_cli_ipfs/core/#add","text":"@ipfs . command () @click . argument ( \"dir_path\" , type = click . Path ( exists = True , dir_okay = True , file_okay = False , resolve_path = True , readable = True ), required = False , ) @click . option ( \"-p\" , \"--publish\" , is_flag = True ) @click . option ( \"--no-pin\" , is_flag = True ) @click . pass_context def add ( click_context : click . Context , dir_path : Optional [ str ], publish : bool = False , no_pin : bool = False ) -> None Add directory to ipfs, if not directory specified the current one will be added.","title":"add"},{"location":"api/plugins/aea_cli_ipfs/core/#remove","text":"@ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . pass_context def remove ( click_context : click . Context , hash_ : str ) -> None Remove a directory from ipfs by it's hash.","title":"remove"},{"location":"api/plugins/aea_cli_ipfs/core/#download","text":"@ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . argument ( \"target_dir\" , type = click . Path ( dir_okay = True , file_okay = False , resolve_path = True ), required = False , ) @click . pass_context def download ( click_context : click . Context , hash_ : str , target_dir : Optional [ str ]) -> None Download directory by it's hash, if not target directory specified will use current one.","title":"download"},{"location":"api/plugins/aea_cli_ipfs/core/#register_package","text":"def register_package ( ipfs_tool : IPFSTool , dir_path : str , no_pin : bool ) -> str Register package to IPFS registry. Arguments : ipfs_tool : instance of IPFSTool. dir_path : package directory. no_pin : pin object or not. Returns : package hash","title":"register_package"},{"location":"api/plugins/aea_cli_ipfs/exceptions/","text":"plugins.aea-cli-ipfs.aea _ cli _ ipfs.exceptions Module to contain exceptions for ipfs plugin. BaseIPFSToolException Objects class BaseIPFSToolException ( Exception ) Base ipfs tool exception. RemoveError Objects class RemoveError ( BaseIPFSToolException ) Exception on remove. PinError Objects class PinError ( BaseIPFSToolException ) Exception on pin. PublishError Objects class PublishError ( BaseIPFSToolException ) Exception on publish. NodeError Objects class NodeError ( BaseIPFSToolException ) Exception for node connection check. DownloadError Objects class DownloadError ( BaseIPFSToolException ) Exception on download failed. HashNotProvided Objects class HashNotProvided ( BaseIPFSToolException ) Exception when hash is not provided.","title":"Exceptions"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#pluginsaea-cli-ipfsaea_cli_ipfsexceptions","text":"Module to contain exceptions for ipfs plugin.","title":"plugins.aea-cli-ipfs.aea_cli_ipfs.exceptions"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#baseipfstoolexception-objects","text":"class BaseIPFSToolException ( Exception ) Base ipfs tool exception.","title":"BaseIPFSToolException Objects"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#removeerror-objects","text":"class RemoveError ( BaseIPFSToolException ) Exception on remove.","title":"RemoveError Objects"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#pinerror-objects","text":"class PinError ( BaseIPFSToolException ) Exception on pin.","title":"PinError Objects"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#publisherror-objects","text":"class PublishError ( BaseIPFSToolException ) Exception on publish.","title":"PublishError Objects"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#nodeerror-objects","text":"class NodeError ( BaseIPFSToolException ) Exception for node connection check.","title":"NodeError Objects"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#downloaderror-objects","text":"class DownloadError ( BaseIPFSToolException ) Exception on download failed.","title":"DownloadError Objects"},{"location":"api/plugins/aea_cli_ipfs/exceptions/#hashnotprovided-objects","text":"class HashNotProvided ( BaseIPFSToolException ) Exception when hash is not provided.","title":"HashNotProvided Objects"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/","text":"plugins.aea-cli-ipfs.aea _ cli _ ipfs.ipfs _ utils Ipfs utils for ipfs cli command . resolve _ addr def resolve_addr ( addr : str ) -> Tuple [ str , ... ] Multiaddr resolver. Arguments : addr : multiaddr string. Returns : http URL addr _ to _ url def addr_to_url ( addr : str ) -> str Convert address to url. IPFSDaemon Objects class IPFSDaemon () Set up the IPFS daemon. Raises : Exception : if IPFS is not installed. __ init __ def __init__ ( node_url : str = \"http://127.0.0.1:5001\" ) Initialise IPFS daemon. is _ started _ externally def is_started_externally () -> bool Check daemon was started externally. is _ started _ internally def is_started_internally () -> bool Check daemon was started internally. is _ started def is_started () -> bool Check daemon was started. start def start () -> None Run the ipfs daemon. stop def stop () -> None Terminate the ipfs daemon if it was started internally. __ enter __ def __enter__ () -> None Run the ipfs daemon. __ exit __ def __exit__ ( exc_type , exc_val , exc_tb ) -> None Terminate the ipfs daemon. IPFSTool Objects class IPFSTool () IPFS tool to add, publish, remove, download directories. __ init __ def __init__ ( addr : Optional [ str ] = None ) Init tool. Arguments : addr : multiaddr string for IPFS client. addr @property def addr () -> str Node address is _ a _ package def is_a_package ( package_hash : str ) -> bool Checks if a package with package_hash is pinned or not all _ pins def all_pins ( recursive_only : bool = True ) -> Set [ str ] Returns a list of all pins. add def add ( dir_path : str , pin : bool = True ) -> Tuple [ str , str , List ] Add directory to ipfs. It wraps into directory. Arguments : dir_path : str, path to dir to publish pin : bool, pin object or not Returns : dir name published, hash, list of items processed pin def pin ( hash_id : str ) -> Dict Pin content with hash_id remove def remove ( hash_id : str ) -> Dict Remove dir added by it's hash. Arguments : hash_id : str. hash of dir to remove Returns : dict with unlinked items. remove _ unpinned _ files def remove_unpinned_files () -> None Remove dir added by it's hash. download def download ( hash_id : str , target_dir : str , fix_path : bool = True ) -> str Download dir by it's hash. Arguments : hash_id : str. hash of file to download target_dir : str. directory to place downloaded fix_path : bool. default True. on download don't wrap result in to hash_id directory. Returns : downloaded path publish def publish ( hash_id : str ) -> Dict Publish directory by it's hash id. Arguments : hash_id : hash of the directory to publish. Returns : dict of names it was publish for. check _ ipfs _ node _ running def check_ipfs_node_running () -> None Check ipfs node running.","title":"Utils"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#pluginsaea-cli-ipfsaea_cli_ipfsipfs_utils","text":"Ipfs utils for ipfs cli command .","title":"plugins.aea-cli-ipfs.aea_cli_ipfs.ipfs_utils"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#resolve_addr","text":"def resolve_addr ( addr : str ) -> Tuple [ str , ... ] Multiaddr resolver. Arguments : addr : multiaddr string. Returns : http URL","title":"resolve_addr"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#addr_to_url","text":"def addr_to_url ( addr : str ) -> str Convert address to url.","title":"addr_to_url"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#ipfsdaemon-objects","text":"class IPFSDaemon () Set up the IPFS daemon. Raises : Exception : if IPFS is not installed.","title":"IPFSDaemon Objects"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#__init__","text":"def __init__ ( node_url : str = \"http://127.0.0.1:5001\" ) Initialise IPFS daemon.","title":"__init__"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#is_started_externally","text":"def is_started_externally () -> bool Check daemon was started externally.","title":"is_started_externally"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#is_started_internally","text":"def is_started_internally () -> bool Check daemon was started internally.","title":"is_started_internally"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#is_started","text":"def is_started () -> bool Check daemon was started.","title":"is_started"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#start","text":"def start () -> None Run the ipfs daemon.","title":"start"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#stop","text":"def stop () -> None Terminate the ipfs daemon if it was started internally.","title":"stop"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#__enter__","text":"def __enter__ () -> None Run the ipfs daemon.","title":"__enter__"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#__exit__","text":"def __exit__ ( exc_type , exc_val , exc_tb ) -> None Terminate the ipfs daemon.","title":"__exit__"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#ipfstool-objects","text":"class IPFSTool () IPFS tool to add, publish, remove, download directories.","title":"IPFSTool Objects"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#__init___1","text":"def __init__ ( addr : Optional [ str ] = None ) Init tool. Arguments : addr : multiaddr string for IPFS client.","title":"__init__"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#addr","text":"@property def addr () -> str Node address","title":"addr"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#is_a_package","text":"def is_a_package ( package_hash : str ) -> bool Checks if a package with package_hash is pinned or not","title":"is_a_package"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#all_pins","text":"def all_pins ( recursive_only : bool = True ) -> Set [ str ] Returns a list of all pins.","title":"all_pins"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#add","text":"def add ( dir_path : str , pin : bool = True ) -> Tuple [ str , str , List ] Add directory to ipfs. It wraps into directory. Arguments : dir_path : str, path to dir to publish pin : bool, pin object or not Returns : dir name published, hash, list of items processed","title":"add"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#pin","text":"def pin ( hash_id : str ) -> Dict Pin content with hash_id","title":"pin"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#remove","text":"def remove ( hash_id : str ) -> Dict Remove dir added by it's hash. Arguments : hash_id : str. hash of dir to remove Returns : dict with unlinked items.","title":"remove"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#remove_unpinned_files","text":"def remove_unpinned_files () -> None Remove dir added by it's hash.","title":"remove_unpinned_files"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#download","text":"def download ( hash_id : str , target_dir : str , fix_path : bool = True ) -> str Download dir by it's hash. Arguments : hash_id : str. hash of file to download target_dir : str. directory to place downloaded fix_path : bool. default True. on download don't wrap result in to hash_id directory. Returns : downloaded path","title":"download"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#publish","text":"def publish ( hash_id : str ) -> Dict Publish directory by it's hash id. Arguments : hash_id : hash of the directory to publish. Returns : dict of names it was publish for.","title":"publish"},{"location":"api/plugins/aea_cli_ipfs/ipfs_utils/#check_ipfs_node_running","text":"def check_ipfs_node_running () -> None Check ipfs node running.","title":"check_ipfs_node_running"},{"location":"api/plugins/aea_cli_ipfs/registry/","text":"plugins.aea-cli-ipfs.aea _ cli _ ipfs.registry Module with methods for ipfs registry. validate _ registry def validate_registry ( registry_data : LocalRegistry ) -> None Validate local registry data. Arguments : registry_data : json like object containing registry data. write _ local _ registry def write_local_registry ( registry_data : LocalRegistry , registry_path : str = LOCAL_REGISTRY_PATH ) -> None Write registry data to file. Arguments : registry_data : json like object containing registry data. registry_path : local registry path. load _ local _ registry def load_local_registry ( registry_path : str = LOCAL_REGISTRY_PATH ) -> LocalRegistry Returns local registry data. get _ ipfs _ hash _ from _ public _ id def get_ipfs_hash_from_public_id ( item_type : str , public_id : PublicId , registry_path : str = LOCAL_REGISTRY_PATH ) -> Optional [ str ] Get IPFS hash from local registry. register _ item _ to _ local _ registry def register_item_to_local_registry ( item_type : str , public_id : Union [ str , PublicId ], package_hash : str , registry_path : str = LOCAL_REGISTRY_PATH ) -> None Add PublicId to hash mapping in the local registry. Arguments : item_type : item type. public_id : public id of package. package_hash : hash of package. registry_path : local registry path. fetch _ ipfs def fetch_ipfs ( item_type : str , public_id : PublicId , dest : str , remote : bool = True ) -> Optional [ Path ] Fetch a package from IPFS node.","title":"Registry"},{"location":"api/plugins/aea_cli_ipfs/registry/#pluginsaea-cli-ipfsaea_cli_ipfsregistry","text":"Module with methods for ipfs registry.","title":"plugins.aea-cli-ipfs.aea_cli_ipfs.registry"},{"location":"api/plugins/aea_cli_ipfs/registry/#validate_registry","text":"def validate_registry ( registry_data : LocalRegistry ) -> None Validate local registry data. Arguments : registry_data : json like object containing registry data.","title":"validate_registry"},{"location":"api/plugins/aea_cli_ipfs/registry/#write_local_registry","text":"def write_local_registry ( registry_data : LocalRegistry , registry_path : str = LOCAL_REGISTRY_PATH ) -> None Write registry data to file. Arguments : registry_data : json like object containing registry data. registry_path : local registry path.","title":"write_local_registry"},{"location":"api/plugins/aea_cli_ipfs/registry/#load_local_registry","text":"def load_local_registry ( registry_path : str = LOCAL_REGISTRY_PATH ) -> LocalRegistry Returns local registry data.","title":"load_local_registry"},{"location":"api/plugins/aea_cli_ipfs/registry/#get_ipfs_hash_from_public_id","text":"def get_ipfs_hash_from_public_id ( item_type : str , public_id : PublicId , registry_path : str = LOCAL_REGISTRY_PATH ) -> Optional [ str ] Get IPFS hash from local registry.","title":"get_ipfs_hash_from_public_id"},{"location":"api/plugins/aea_cli_ipfs/registry/#register_item_to_local_registry","text":"def register_item_to_local_registry ( item_type : str , public_id : Union [ str , PublicId ], package_hash : str , registry_path : str = LOCAL_REGISTRY_PATH ) -> None Add PublicId to hash mapping in the local registry. Arguments : item_type : item type. public_id : public id of package. package_hash : hash of package. registry_path : local registry path.","title":"register_item_to_local_registry"},{"location":"api/plugins/aea_cli_ipfs/registry/#fetch_ipfs","text":"def fetch_ipfs ( item_type : str , public_id : PublicId , dest : str , remote : bool = True ) -> Optional [ Path ] Fetch a package from IPFS node.","title":"fetch_ipfs"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/","text":"plugins.aea-ledger-cosmos.aea _ ledger _ cosmos.cosmos Cosmos module wrapping the public and private key cryptography and ledger api. lazy _ load def lazy_load () Temporary solution because of protos mismatch. DataEncrypt Objects class DataEncrypt () Class to encrypt/decrypt data strings with password provided. encrypt @classmethod def encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password. bytes _ encode @staticmethod def bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string. bytes _ decode @staticmethod def bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes. decrypt @classmethod def decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided. CosmosHelper Objects class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class. is _ transaction _ settled @staticmethod def is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w. get _ code _ id @classmethod def get_code_id ( cls , tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present get _ event _ attributes @staticmethod def get_event_attributes ( tx_receipt : JSONLike ) -> Dict Retrieve events attributes from tx receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : dict get _ contract _ address @classmethod def get_contract_address ( cls , tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present is _ transaction _ valid @staticmethod def is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce @staticmethod def generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key @classmethod def get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message @classmethod def recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message @classmethod def recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash @staticmethod def get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. is _ valid _ address @classmethod def is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not load _ contract _ interface @classmethod def load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface CosmosCrypto Objects class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ def __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide private _ key @property def private_key () -> str Return a private key. Returns : a private key string public _ key @property def public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address @property def address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path @classmethod def load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity. sign _ message def sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction def sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key @classmethod def generate_private_key ( cls , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> SigningKey Generate a key pair for cosmos network. encrypt def encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key. decrypt @classmethod def decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key. _ CosmosApi Objects class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs. api @property def api () -> Any Get the underlying API object. get _ balance def get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state def get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary get _ deploy _ transaction","title":"API"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#pluginsaea-ledger-cosmosaea_ledger_cosmoscosmos","text":"Cosmos module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-cosmos.aea_ledger_cosmos.cosmos"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#lazy_load","text":"def lazy_load () Temporary solution because of protos mismatch.","title":"lazy_load"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#dataencrypt-objects","text":"class DataEncrypt () Class to encrypt/decrypt data strings with password provided.","title":"DataEncrypt Objects"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#encrypt","text":"@classmethod def encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password.","title":"encrypt"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#bytes_encode","text":"@staticmethod def bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string.","title":"bytes_encode"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#bytes_decode","text":"@staticmethod def bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes.","title":"bytes_decode"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#decrypt","text":"@classmethod def decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided.","title":"decrypt"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#cosmoshelper-objects","text":"class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class.","title":"CosmosHelper Objects"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#is_transaction_settled","text":"@staticmethod def is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_code_id","text":"@classmethod def get_code_id ( cls , tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present","title":"get_code_id"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_event_attributes","text":"@staticmethod def get_event_attributes ( tx_receipt : JSONLike ) -> Dict Retrieve events attributes from tx receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : dict","title":"get_event_attributes"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_contract_address","text":"@classmethod def get_contract_address ( cls , tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present","title":"get_contract_address"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#is_transaction_valid","text":"@staticmethod def is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#generate_tx_nonce","text":"@staticmethod def generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_address_from_public_key","text":"@classmethod def get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#recover_message","text":"@classmethod def recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#recover_public_keys_from_message","text":"@classmethod def recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_hash","text":"@staticmethod def get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#is_valid_address","text":"@classmethod def is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not","title":"is_valid_address"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#load_contract_interface","text":"@classmethod def load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#cosmoscrypto-objects","text":"class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger.","title":"CosmosCrypto Objects"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#__init__","text":"def __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide","title":"__init__"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#private_key","text":"@property def private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#public_key","text":"@property def public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#address","text":"@property def address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#load_private_key_from_path","text":"@classmethod def load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#sign_message","text":"def sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#sign_transaction","text":"def sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#generate_private_key","text":"@classmethod def generate_private_key ( cls , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> SigningKey Generate a key pair for cosmos network.","title":"generate_private_key"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#encrypt_1","text":"def encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key.","title":"encrypt"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#decrypt_1","text":"@classmethod def decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key.","title":"decrypt"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#_cosmosapi-objects","text":"class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"_CosmosApi Objects"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#__init___1","text":"def __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs.","title":"__init__"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#api","text":"@property def api () -> Any Get the underlying API object.","title":"api"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_balance","text":"def get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_state","text":"def get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary","title":"get_state"},{"location":"api/plugins/aea_ledger_cosmos/cosmos/#get_deploy_transaction","text":"","title":"get_deploy_transaction"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/","text":"plugins.aea-ledger-ethereum.aea _ ledger _ ethereum.ethereum Ethereum module wrapping the public and private key cryptography and ledger api. wei _ to _ gwei def wei_to_gwei ( number : Type [ int ]) -> Union [ int , decimal . Decimal ] Covert WEI to GWEI round _ to _ whole _ gwei def round_to_whole_gwei ( number : Type [ int ]) -> Wei Round WEI to equivalent GWEI get _ base _ fee _ multiplier def get_base_fee_multiplier ( base_fee_gwei : int ) -> float Returns multiplier value. estimate _ priority _ fee def estimate_priority_fee ( web3_object : Web3 , base_fee_gwei : int , block_number : int , priority_fee_estimation_trigger : int , default_priority_fee : int , fee_history_blocks : int , fee_history_percentile : int , priority_fee_increase_boundary : int ) -> int Estimate priority fee from base fee. get _ gas _ price _ strategy _ eip1559 def get_gas_price_strategy_eip1559 ( max_gas_fast : int , fee_history_blocks : int , fee_history_percentile : int , priority_fee_estimation_trigger : int , default_priority_fee : int , fallback_estimate : Dict [ str , Optional [ int ]], priority_fee_increase_boundary : int ) -> Callable [[ Web3 , TxParams ], Dict [ str , Wei ]] Get the gas price strategy. rpc _ gas _ price _ strategy _ wrapper def rpc_gas_price_strategy_wrapper ( web3 : Web3 , transaction_params : TxParams ) -> Dict [ str , Wei ] RPC gas price strategy wrapper. get _ gas _ price _ strategy def get_gas_price_strategy ( gas_price_strategy : Optional [ str ] = None , gas_price_api_key : Optional [ str ] = None ) -> Callable [[ Web3 , TxParams ], Dict [ str , Wei ]] Get the gas price strategy. SignedTransactionTranslator Objects class SignedTransactionTranslator () Translator for SignedTransaction. to _ dict @staticmethod def to_dict ( signed_transaction : SignedTransaction ) -> Dict [ str , Union [ str , int ]] Write SignedTransaction to dict. from _ dict @staticmethod def from_dict ( signed_transaction_dict : JSONLike ) -> SignedTransaction Get SignedTransaction from dict. AttributeDictTranslator Objects class AttributeDictTranslator () Translator for AttributeDict. to _ dict @classmethod def to_dict ( cls , attr_dict : Union [ AttributeDict , TxReceipt , TxData ]) -> JSONLike Simplify to dict. from _ dict @classmethod def from_dict ( cls , di : JSONLike ) -> AttributeDict Get back attribute dict. EthereumCrypto Objects class EthereumCrypto ( Crypto [ LocalAccount ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ def __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide private _ key @property def private_key () -> str Return a private key. 64 random hex characters (i.e. 32 bytes) + \"0x\" prefix. Returns : a private key string in hex format public _ key @property def public_key () -> str Return a public key in hex format. 128 hex characters (i.e. 64 bytes) + \"0x\" prefix. Returns : a public key string in hex format address @property def address () -> str Return the address for the key pair. 40 hex characters (i.e. 20 bytes) + \"0x\" prefix. Returns : an address string in hex format load _ private _ key _ from _ path @classmethod def load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> LocalAccount Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity. sign _ message def sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction def sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key @classmethod def generate_private_key ( cls , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> LocalAccount Generate a key pair for ethereum network. Arguments : extra_entropy : add extra randomness to whatever randomness your OS can provide Returns : account object encrypt def encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key. decrypt @classmethod def decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json str containing encrypted private key. password : the password to decrypt. Returns : the raw private key (without leading \"0x\"). EthereumHelper Objects class EthereumHelper ( Helper ) Helper class usable as Mixin for EthereumApi or as standalone class. is _ transaction _ settled @staticmethod def is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt associated to the transaction. Returns : True if the transaction has been settled, False o/w. get _ contract _ address @staticmethod def get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present is _ transaction _ valid @staticmethod def is_transaction_valid ( tx : dict , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce @staticmethod def generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key @classmethod def get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message @classmethod def recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message @classmethod def recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash @staticmethod def get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message as a hex string. load _ contract _ interface @classmethod def load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface EthereumApi Objects class EthereumApi ( LedgerApi , EthereumHelper ) Class to interact with the Ethereum Web3 APIs. __ init __ def __init__ ( ** kwargs : Any ) Initialize the Ethereum ledger APIs. Arguments : kwargs : keyword arguments api @property def api () -> Web3 Get the underlying API object. get _ balance def get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state def get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. get _ transfer _ transaction","title":"API"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#pluginsaea-ledger-ethereumaea_ledger_ethereumethereum","text":"Ethereum module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-ethereum.aea_ledger_ethereum.ethereum"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#wei_to_gwei","text":"def wei_to_gwei ( number : Type [ int ]) -> Union [ int , decimal . Decimal ] Covert WEI to GWEI","title":"wei_to_gwei"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#round_to_whole_gwei","text":"def round_to_whole_gwei ( number : Type [ int ]) -> Wei Round WEI to equivalent GWEI","title":"round_to_whole_gwei"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_base_fee_multiplier","text":"def get_base_fee_multiplier ( base_fee_gwei : int ) -> float Returns multiplier value.","title":"get_base_fee_multiplier"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#estimate_priority_fee","text":"def estimate_priority_fee ( web3_object : Web3 , base_fee_gwei : int , block_number : int , priority_fee_estimation_trigger : int , default_priority_fee : int , fee_history_blocks : int , fee_history_percentile : int , priority_fee_increase_boundary : int ) -> int Estimate priority fee from base fee.","title":"estimate_priority_fee"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_gas_price_strategy_eip1559","text":"def get_gas_price_strategy_eip1559 ( max_gas_fast : int , fee_history_blocks : int , fee_history_percentile : int , priority_fee_estimation_trigger : int , default_priority_fee : int , fallback_estimate : Dict [ str , Optional [ int ]], priority_fee_increase_boundary : int ) -> Callable [[ Web3 , TxParams ], Dict [ str , Wei ]] Get the gas price strategy.","title":"get_gas_price_strategy_eip1559"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#rpc_gas_price_strategy_wrapper","text":"def rpc_gas_price_strategy_wrapper ( web3 : Web3 , transaction_params : TxParams ) -> Dict [ str , Wei ] RPC gas price strategy wrapper.","title":"rpc_gas_price_strategy_wrapper"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_gas_price_strategy","text":"def get_gas_price_strategy ( gas_price_strategy : Optional [ str ] = None , gas_price_api_key : Optional [ str ] = None ) -> Callable [[ Web3 , TxParams ], Dict [ str , Wei ]] Get the gas price strategy.","title":"get_gas_price_strategy"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#signedtransactiontranslator-objects","text":"class SignedTransactionTranslator () Translator for SignedTransaction.","title":"SignedTransactionTranslator Objects"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#to_dict","text":"@staticmethod def to_dict ( signed_transaction : SignedTransaction ) -> Dict [ str , Union [ str , int ]] Write SignedTransaction to dict.","title":"to_dict"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#from_dict","text":"@staticmethod def from_dict ( signed_transaction_dict : JSONLike ) -> SignedTransaction Get SignedTransaction from dict.","title":"from_dict"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#attributedicttranslator-objects","text":"class AttributeDictTranslator () Translator for AttributeDict.","title":"AttributeDictTranslator Objects"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#to_dict_1","text":"@classmethod def to_dict ( cls , attr_dict : Union [ AttributeDict , TxReceipt , TxData ]) -> JSONLike Simplify to dict.","title":"to_dict"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#from_dict_1","text":"@classmethod def from_dict ( cls , di : JSONLike ) -> AttributeDict Get back attribute dict.","title":"from_dict"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#ethereumcrypto-objects","text":"class EthereumCrypto ( Crypto [ LocalAccount ]) Class wrapping the Account Generation from Ethereum ledger.","title":"EthereumCrypto Objects"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#__init__","text":"def __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide","title":"__init__"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#private_key","text":"@property def private_key () -> str Return a private key. 64 random hex characters (i.e. 32 bytes) + \"0x\" prefix. Returns : a private key string in hex format","title":"private_key"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#public_key","text":"@property def public_key () -> str Return a public key in hex format. 128 hex characters (i.e. 64 bytes) + \"0x\" prefix. Returns : a public key string in hex format","title":"public_key"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#address","text":"@property def address () -> str Return the address for the key pair. 40 hex characters (i.e. 20 bytes) + \"0x\" prefix. Returns : an address string in hex format","title":"address"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#load_private_key_from_path","text":"@classmethod def load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> LocalAccount Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#sign_message","text":"def sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#sign_transaction","text":"def sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#generate_private_key","text":"@classmethod def generate_private_key ( cls , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> LocalAccount Generate a key pair for ethereum network. Arguments : extra_entropy : add extra randomness to whatever randomness your OS can provide Returns : account object","title":"generate_private_key"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#encrypt","text":"def encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key.","title":"encrypt"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#decrypt","text":"@classmethod def decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json str containing encrypted private key. password : the password to decrypt. Returns : the raw private key (without leading \"0x\").","title":"decrypt"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#ethereumhelper-objects","text":"class EthereumHelper ( Helper ) Helper class usable as Mixin for EthereumApi or as standalone class.","title":"EthereumHelper Objects"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#is_transaction_settled","text":"@staticmethod def is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_contract_address","text":"@staticmethod def get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present","title":"get_contract_address"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#is_transaction_valid","text":"@staticmethod def is_transaction_valid ( tx : dict , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#generate_tx_nonce","text":"@staticmethod def generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_address_from_public_key","text":"@classmethod def get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#recover_message","text":"@classmethod def recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#recover_public_keys_from_message","text":"@classmethod def recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_hash","text":"@staticmethod def get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message as a hex string.","title":"get_hash"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#load_contract_interface","text":"@classmethod def load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#ethereumapi-objects","text":"class EthereumApi ( LedgerApi , EthereumHelper ) Class to interact with the Ethereum Web3 APIs.","title":"EthereumApi Objects"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#__init___1","text":"def __init__ ( ** kwargs : Any ) Initialize the Ethereum ledger APIs. Arguments : kwargs : keyword arguments","title":"__init__"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#api","text":"@property def api () -> Web3 Get the underlying API object.","title":"api"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_balance","text":"def get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_state","text":"def get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API.","title":"get_state"},{"location":"api/plugins/aea_ledger_ethereum/ethereum/#get_transfer_transaction","text":"","title":"get_transfer_transaction"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/","text":"plugins.aea-ledger-fetchai.aea _ ledger _ fetchai. _ cosmos Cosmos module wrapping the public and private key cryptography and ledger api. lazy _ load def lazy_load () Temporary solution because of protos mismatch. DataEncrypt Objects class DataEncrypt () Class to encrypt/decrypt data strings with password provided. encrypt @classmethod def encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password. bytes _ encode @staticmethod def bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string. bytes _ decode @staticmethod def bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes. decrypt @classmethod def decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided. CosmosHelper Objects class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class. is _ transaction _ settled @staticmethod def is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w. get _ code _ id @classmethod def get_code_id ( cls , tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present get _ event _ attributes @staticmethod def get_event_attributes ( tx_receipt : JSONLike ) -> Dict Retrieve events attributes from tx receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : dict get _ contract _ address @classmethod def get_contract_address ( cls , tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present is _ transaction _ valid @staticmethod def is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce @staticmethod def generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key @classmethod def get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message @classmethod def recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message @classmethod def recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash @staticmethod def get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. is _ valid _ address @classmethod def is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not load _ contract _ interface @classmethod def load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface CosmosCrypto Objects class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ def __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide private _ key @property def private_key () -> str Return a private key. Returns : a private key string public _ key @property def public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address @property def address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path @classmethod def load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity. sign _ message def sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction def sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key @classmethod def generate_private_key ( cls , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> SigningKey Generate a key pair for cosmos network. encrypt def encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key. decrypt @classmethod def decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key. _ CosmosApi Objects class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs. api @property def api () -> Any Get the underlying API object. get _ balance def get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state def get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary get _ deploy _ transaction","title":"Helper"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#pluginsaea-ledger-fetchaiaea_ledger_fetchai_cosmos","text":"Cosmos module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-fetchai.aea_ledger_fetchai._cosmos"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#lazy_load","text":"def lazy_load () Temporary solution because of protos mismatch.","title":"lazy_load"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#dataencrypt-objects","text":"class DataEncrypt () Class to encrypt/decrypt data strings with password provided.","title":"DataEncrypt Objects"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#encrypt","text":"@classmethod def encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password.","title":"encrypt"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#bytes_encode","text":"@staticmethod def bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string.","title":"bytes_encode"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#bytes_decode","text":"@staticmethod def bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes.","title":"bytes_decode"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#decrypt","text":"@classmethod def decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided.","title":"decrypt"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#cosmoshelper-objects","text":"class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class.","title":"CosmosHelper Objects"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#is_transaction_settled","text":"@staticmethod def is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_code_id","text":"@classmethod def get_code_id ( cls , tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present","title":"get_code_id"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_event_attributes","text":"@staticmethod def get_event_attributes ( tx_receipt : JSONLike ) -> Dict Retrieve events attributes from tx receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : dict","title":"get_event_attributes"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_contract_address","text":"@classmethod def get_contract_address ( cls , tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present","title":"get_contract_address"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#is_transaction_valid","text":"@staticmethod def is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#generate_tx_nonce","text":"@staticmethod def generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_address_from_public_key","text":"@classmethod def get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#recover_message","text":"@classmethod def recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#recover_public_keys_from_message","text":"@classmethod def recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_hash","text":"@staticmethod def get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#is_valid_address","text":"@classmethod def is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not","title":"is_valid_address"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#load_contract_interface","text":"@classmethod def load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#cosmoscrypto-objects","text":"class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger.","title":"CosmosCrypto Objects"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#__init__","text":"def __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. extra_entropy : add extra randomness to whatever randomness your OS can provide","title":"__init__"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#private_key","text":"@property def private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#public_key","text":"@property def public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#address","text":"@property def address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#load_private_key_from_path","text":"@classmethod def load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#sign_message","text":"def sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#sign_transaction","text":"def sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#generate_private_key","text":"@classmethod def generate_private_key ( cls , extra_entropy : Union [ str , bytes , int ] = \"\" ) -> SigningKey Generate a key pair for cosmos network.","title":"generate_private_key"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#encrypt_1","text":"def encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key.","title":"encrypt"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#decrypt_1","text":"@classmethod def decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key.","title":"decrypt"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#_cosmosapi-objects","text":"class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"_CosmosApi Objects"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#__init___1","text":"def __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs.","title":"__init__"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#api","text":"@property def api () -> Any Get the underlying API object.","title":"api"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_balance","text":"def get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_state","text":"def get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary","title":"get_state"},{"location":"api/plugins/aea_ledger_fetchai/_cosmos/#get_deploy_transaction","text":"","title":"get_deploy_transaction"},{"location":"api/plugins/aea_ledger_fetchai/fetchai/","text":"plugins.aea-ledger-fetchai.aea _ ledger _ fetchai.fetchai Fetchai module wrapping the public and private key cryptography and ledger api. FetchAIHelper Objects class FetchAIHelper ( CosmosHelper ) Helper class usable as Mixin for FetchAIApi or as standalone class. FetchAICrypto Objects class FetchAICrypto ( CosmosCrypto ) Class wrapping the Entity Generation from Fetch.AI ledger. FetchAIApi Objects class FetchAIApi ( _CosmosApi , FetchAIHelper ) Class to interact with the Fetch ledger APIs. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize the Fetch.ai ledger APIs. contract _ method _ call","title":"API"},{"location":"api/plugins/aea_ledger_fetchai/fetchai/#pluginsaea-ledger-fetchaiaea_ledger_fetchaifetchai","text":"Fetchai module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-fetchai.aea_ledger_fetchai.fetchai"},{"location":"api/plugins/aea_ledger_fetchai/fetchai/#fetchaihelper-objects","text":"class FetchAIHelper ( CosmosHelper ) Helper class usable as Mixin for FetchAIApi or as standalone class.","title":"FetchAIHelper Objects"},{"location":"api/plugins/aea_ledger_fetchai/fetchai/#fetchaicrypto-objects","text":"class FetchAICrypto ( CosmosCrypto ) Class wrapping the Entity Generation from Fetch.AI ledger.","title":"FetchAICrypto Objects"},{"location":"api/plugins/aea_ledger_fetchai/fetchai/#fetchaiapi-objects","text":"class FetchAIApi ( _CosmosApi , FetchAIHelper ) Class to interact with the Fetch ledger APIs.","title":"FetchAIApi Objects"},{"location":"api/plugins/aea_ledger_fetchai/fetchai/#__init__","text":"def __init__ ( ** kwargs : Any ) -> None Initialize the Fetch.ai ledger APIs.","title":"__init__"},{"location":"api/plugins/aea_ledger_fetchai/fetchai/#contract_method_call","text":"","title":"contract_method_call"},{"location":"api/protocols/base/","text":"aea.protocols.base This module contains the base message and serialization definition. Message Objects class Message () This class implements a message. Performative Objects class Performative ( Enum ) Performatives for the base message. __ str __ def __str__ () -> str Get the string representation. __ init __ def __init__ ( _body : Optional [ Dict ] = None , ** kwargs : Any ) -> None Initialize a Message object. Arguments : _body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values. json def json () -> dict Get json friendly str representation of the message. from _ json @classmethod def from_json ( cls , data : dict ) -> \"Message\" Construct message instance from json data. valid _ performatives @property def valid_performatives () -> Set [ str ] Get valid performatives. has _ sender @property def has_sender () -> bool Check if it has a sender. sender @property def sender () -> Address Get the sender of the message in Address form. sender @sender . setter def sender ( sender : Address ) -> None Set the sender of the message. has _ to @property def has_to () -> bool Check if it has a sender. to @property def to () -> Address Get address of receiver. to @to . setter def to ( to : Address ) -> None Set address of receiver. dialogue _ reference @property def dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id @property def message_id () -> int Get the message_id of the message. performative @property def performative () -> \"Performative\" Get the performative of the message. target @property def target () -> int Get the target of the message. set def set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. get def get ( key : str ) -> Optional [ Any ] Get value for key. is _ set def is_set ( key : str ) -> bool Check value is set for key. __ eq __ def __eq__ ( other : Any ) -> bool Compare with another object. __ repr __ def __repr__ () -> str Get the representation of the message. __ str __ def __str__ () -> str Get the string representation of the message. Abbreviated to prevent spamming of logs. encode def encode () -> bytes Encode the message. decode @classmethod def decode ( cls , data : bytes ) -> \"Message\" Decode the message. has _ dialogue _ info @property def has_dialogue_info () -> bool Check whether a message has the dialogue fields populated. More precisely, it checks whether the fields 'message_id', 'target' and 'dialogue_reference' are set. Returns : True if the message has the dialogue fields set, False otherwise. Encoder Objects class Encoder ( ABC ) Encoder interface. encode @staticmethod @abstractmethod def encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message. Decoder Objects class Decoder ( ABC ) Decoder interface. decode @staticmethod @abstractmethod def decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message. Serializer Objects class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol. Protocol Objects class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message. __ init __ def __init__ ( configuration : ProtocolConfig , message_class : Type [ Message ], ** kwargs : Any ) -> None Initialize the protocol manager. Arguments : configuration : the protocol configurations. message_class : the message class. kwargs : the keyword arguments. serializer @property def serializer () -> Type [ Serializer ] Get the serializer. from _ dir @classmethod def from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the protocol object. from _ config @classmethod def from_config ( cls , configuration : ProtocolConfig , ** kwargs : Any ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. kwargs : the keyword arguments. Returns : the protocol object. protocol _ id @property def protocol_id () -> PublicId Get protocol id. protocol _ specification _ id @property def protocol_specification_id () -> PublicId Get protocol specification id. __ repr __ def __repr__ () -> str Get str representation of the protocol.","title":"Base"},{"location":"api/protocols/base/#aeaprotocolsbase","text":"This module contains the base message and serialization definition.","title":"aea.protocols.base"},{"location":"api/protocols/base/#message-objects","text":"class Message () This class implements a message.","title":"Message Objects"},{"location":"api/protocols/base/#performative-objects","text":"class Performative ( Enum ) Performatives for the base message.","title":"Performative Objects"},{"location":"api/protocols/base/#__str__","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/protocols/base/#__init__","text":"def __init__ ( _body : Optional [ Dict ] = None , ** kwargs : Any ) -> None Initialize a Message object. Arguments : _body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values.","title":"__init__"},{"location":"api/protocols/base/#json","text":"def json () -> dict Get json friendly str representation of the message.","title":"json"},{"location":"api/protocols/base/#from_json","text":"@classmethod def from_json ( cls , data : dict ) -> \"Message\" Construct message instance from json data.","title":"from_json"},{"location":"api/protocols/base/#valid_performatives","text":"@property def valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"api/protocols/base/#has_sender","text":"@property def has_sender () -> bool Check if it has a sender.","title":"has_sender"},{"location":"api/protocols/base/#sender","text":"@property def sender () -> Address Get the sender of the message in Address form.","title":"sender"},{"location":"api/protocols/base/#sender_1","text":"@sender . setter def sender ( sender : Address ) -> None Set the sender of the message.","title":"sender"},{"location":"api/protocols/base/#has_to","text":"@property def has_to () -> bool Check if it has a sender.","title":"has_to"},{"location":"api/protocols/base/#to","text":"@property def to () -> Address Get address of receiver.","title":"to"},{"location":"api/protocols/base/#to_1","text":"@to . setter def to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"api/protocols/base/#dialogue_reference","text":"@property def dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"api/protocols/base/#message_id","text":"@property def message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"api/protocols/base/#performative","text":"@property def performative () -> \"Performative\" Get the performative of the message.","title":"performative"},{"location":"api/protocols/base/#target","text":"@property def target () -> int Get the target of the message.","title":"target"},{"location":"api/protocols/base/#set","text":"def set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value.","title":"set"},{"location":"api/protocols/base/#get","text":"def get ( key : str ) -> Optional [ Any ] Get value for key.","title":"get"},{"location":"api/protocols/base/#is_set","text":"def is_set ( key : str ) -> bool Check value is set for key.","title":"is_set"},{"location":"api/protocols/base/#__eq__","text":"def __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"api/protocols/base/#__repr__","text":"def __repr__ () -> str Get the representation of the message.","title":"__repr__"},{"location":"api/protocols/base/#__str___1","text":"def __str__ () -> str Get the string representation of the message. Abbreviated to prevent spamming of logs.","title":"__str__"},{"location":"api/protocols/base/#encode","text":"def encode () -> bytes Encode the message.","title":"encode"},{"location":"api/protocols/base/#decode","text":"@classmethod def decode ( cls , data : bytes ) -> \"Message\" Decode the message.","title":"decode"},{"location":"api/protocols/base/#has_dialogue_info","text":"@property def has_dialogue_info () -> bool Check whether a message has the dialogue fields populated. More precisely, it checks whether the fields 'message_id', 'target' and 'dialogue_reference' are set. Returns : True if the message has the dialogue fields set, False otherwise.","title":"has_dialogue_info"},{"location":"api/protocols/base/#encoder-objects","text":"class Encoder ( ABC ) Encoder interface.","title":"Encoder Objects"},{"location":"api/protocols/base/#encode_1","text":"@staticmethod @abstractmethod def encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message.","title":"encode"},{"location":"api/protocols/base/#decoder-objects","text":"class Decoder ( ABC ) Decoder interface.","title":"Decoder Objects"},{"location":"api/protocols/base/#decode_1","text":"@staticmethod @abstractmethod def decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message.","title":"decode"},{"location":"api/protocols/base/#serializer-objects","text":"class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol.","title":"Serializer Objects"},{"location":"api/protocols/base/#protocol-objects","text":"class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message.","title":"Protocol Objects"},{"location":"api/protocols/base/#__init___1","text":"def __init__ ( configuration : ProtocolConfig , message_class : Type [ Message ], ** kwargs : Any ) -> None Initialize the protocol manager. Arguments : configuration : the protocol configurations. message_class : the message class. kwargs : the keyword arguments.","title":"__init__"},{"location":"api/protocols/base/#serializer","text":"@property def serializer () -> Type [ Serializer ] Get the serializer.","title":"serializer"},{"location":"api/protocols/base/#from_dir","text":"@classmethod def from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the protocol object.","title":"from_dir"},{"location":"api/protocols/base/#from_config","text":"@classmethod def from_config ( cls , configuration : ProtocolConfig , ** kwargs : Any ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. kwargs : the keyword arguments. Returns : the protocol object.","title":"from_config"},{"location":"api/protocols/base/#protocol_id","text":"@property def protocol_id () -> PublicId Get protocol id.","title":"protocol_id"},{"location":"api/protocols/base/#protocol_specification_id","text":"@property def protocol_specification_id () -> PublicId Get protocol specification id.","title":"protocol_specification_id"},{"location":"api/protocols/base/#__repr___1","text":"def __repr__ () -> str Get str representation of the protocol.","title":"__repr__"},{"location":"api/protocols/dialogue/base/","text":"aea.protocols.dialogue.base This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues. InvalidDialogueMessage Objects class InvalidDialogueMessage ( Exception ) Exception for adding invalid message to a dialogue. DialogueLabel Objects class DialogueLabel () The dialogue label class acts as an identifier for dialogues. __ init __ def __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. dialogue _ reference @property def dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference. dialogue _ starter _ reference @property def dialogue_starter_reference () -> str Get the dialogue starter reference. dialogue _ responder _ reference @property def dialogue_responder_reference () -> str Get the dialogue responder reference. dialogue _ opponent _ addr @property def dialogue_opponent_addr () -> str Get the address of the dialogue opponent. dialogue _ starter _ addr @property def dialogue_starter_addr () -> str Get the address of the dialogue starter. __ eq __ def __eq__ ( other : Any ) -> bool Check for equality between two DialogueLabel objects. __ hash __ def __hash__ () -> int Turn object into hash. json @property def json () -> Dict Return the JSON representation. from _ json @classmethod def from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json. is _ complete def is_complete () -> bool Check if the dialogue label is complete. get _ incomplete _ version def get_incomplete_version () -> \"DialogueLabel\" Get the incomplete version of the label. get _ both _ versions def get_both_versions () -> Tuple [ \"DialogueLabel\" , Optional [ \"DialogueLabel\" ]] Get the incomplete and complete versions of the label. __ str __ def __str__ () -> str Get the string representation. from _ str @classmethod def from_str ( cls , obj : str ) -> \"DialogueLabel\" Get the dialogue label from string representation. _ DialogueMeta Objects class _DialogueMeta ( type ) Metaclass for Dialogue. Creates class level Rules instance to share among instances __ new __ def __new__ ( cls , name : str , bases : Tuple [ Type ], dct : Dict ) -> \"_DialogueMeta\" Construct a new type. Dialogue Objects","title":"Base"},{"location":"api/protocols/dialogue/base/#aeaprotocolsdialoguebase","text":"This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues.","title":"aea.protocols.dialogue.base"},{"location":"api/protocols/dialogue/base/#invaliddialoguemessage-objects","text":"class InvalidDialogueMessage ( Exception ) Exception for adding invalid message to a dialogue.","title":"InvalidDialogueMessage Objects"},{"location":"api/protocols/dialogue/base/#dialoguelabel-objects","text":"class DialogueLabel () The dialogue label class acts as an identifier for dialogues.","title":"DialogueLabel Objects"},{"location":"api/protocols/dialogue/base/#__init__","text":"def __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue.","title":"__init__"},{"location":"api/protocols/dialogue/base/#dialogue_reference","text":"@property def dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference.","title":"dialogue_reference"},{"location":"api/protocols/dialogue/base/#dialogue_starter_reference","text":"@property def dialogue_starter_reference () -> str Get the dialogue starter reference.","title":"dialogue_starter_reference"},{"location":"api/protocols/dialogue/base/#dialogue_responder_reference","text":"@property def dialogue_responder_reference () -> str Get the dialogue responder reference.","title":"dialogue_responder_reference"},{"location":"api/protocols/dialogue/base/#dialogue_opponent_addr","text":"@property def dialogue_opponent_addr () -> str Get the address of the dialogue opponent.","title":"dialogue_opponent_addr"},{"location":"api/protocols/dialogue/base/#dialogue_starter_addr","text":"@property def dialogue_starter_addr () -> str Get the address of the dialogue starter.","title":"dialogue_starter_addr"},{"location":"api/protocols/dialogue/base/#__eq__","text":"def __eq__ ( other : Any ) -> bool Check for equality between two DialogueLabel objects.","title":"__eq__"},{"location":"api/protocols/dialogue/base/#__hash__","text":"def __hash__ () -> int Turn object into hash.","title":"__hash__"},{"location":"api/protocols/dialogue/base/#json","text":"@property def json () -> Dict Return the JSON representation.","title":"json"},{"location":"api/protocols/dialogue/base/#from_json","text":"@classmethod def from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json.","title":"from_json"},{"location":"api/protocols/dialogue/base/#is_complete","text":"def is_complete () -> bool Check if the dialogue label is complete.","title":"is_complete"},{"location":"api/protocols/dialogue/base/#get_incomplete_version","text":"def get_incomplete_version () -> \"DialogueLabel\" Get the incomplete version of the label.","title":"get_incomplete_version"},{"location":"api/protocols/dialogue/base/#get_both_versions","text":"def get_both_versions () -> Tuple [ \"DialogueLabel\" , Optional [ \"DialogueLabel\" ]] Get the incomplete and complete versions of the label.","title":"get_both_versions"},{"location":"api/protocols/dialogue/base/#__str__","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/protocols/dialogue/base/#from_str","text":"@classmethod def from_str ( cls , obj : str ) -> \"DialogueLabel\" Get the dialogue label from string representation.","title":"from_str"},{"location":"api/protocols/dialogue/base/#_dialoguemeta-objects","text":"class _DialogueMeta ( type ) Metaclass for Dialogue. Creates class level Rules instance to share among instances","title":"_DialogueMeta Objects"},{"location":"api/protocols/dialogue/base/#__new__","text":"def __new__ ( cls , name : str , bases : Tuple [ Type ], dct : Dict ) -> \"_DialogueMeta\" Construct a new type.","title":"__new__"},{"location":"api/protocols/dialogue/base/#dialogue-objects","text":"","title":"Dialogue Objects"},{"location":"api/protocols/generator/base/","text":"","title":"Base"},{"location":"api/protocols/generator/common/","text":"aea.protocols.generator.common This module contains utility code for generator modules. is _ installed def is_installed ( programme : str ) -> bool Check whether a programme is installed on the system. Arguments : programme : the name of the programme. Returns : True if installed, False otherwise base _ protolint _ command def base_protolint_command () -> str Return the base protolint command. Returns : The base protolint command check _ prerequisites def check_prerequisites () -> None Check whether a programme is installed on the system. get _ protoc _ version def get_protoc_version () -> str Get the protoc version used. load _ protocol _ specification def load_protocol_specification ( specification_path : str ) -> ProtocolSpecification Load a protocol specification. Arguments : specification_path : path to the protocol specification yaml file. Returns : A ProtocolSpecification object try _ run _ black _ formatting def try_run_black_formatting ( path_to_protocol_package : str ) -> None Run Black code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. try _ run _ isort _ formatting def try_run_isort_formatting ( path_to_protocol_package : str ) -> None Run Isort code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. try _ run _ protoc def try_run_protoc ( path_to_generated_protocol_package : str , name : str , language : str = PROTOCOL_LANGUAGE_PYTHON ) -> None Run 'protoc' protocol buffer compiler via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file try _ run _ protolint def try_run_protolint ( path_to_generated_protocol_package : str , name : str ) -> None Run 'protolint' linter via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. check _ protobuf _ using _ protoc def check_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str ) -> Tuple [ bool , str ] Check whether a protocol buffer schema file is valid. Validation is via trying to compile the schema file. If successfully compiled it is valid, otherwise invalid. If valid, return True and a 'protobuf file is valid' message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message compile _ protobuf _ using _ protoc def compile_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str , language : str ) -> Tuple [ bool , str ] Compile a protocol buffer schema file using protoc. If successfully compiled, return True and a success message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file Returns : Boolean result and an accompanying message apply _ protolint def apply_protolint ( path_to_proto_file : str , name : str ) -> Tuple [ bool , str ] Apply protolint linter to a protocol buffer schema file. If no output, return True and a success message, otherwise return False and the output shown by the linter (minus the indentation suggestions which are automatically fixed by protolint). Arguments : path_to_proto_file : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"Common"},{"location":"api/protocols/generator/common/#aeaprotocolsgeneratorcommon","text":"This module contains utility code for generator modules.","title":"aea.protocols.generator.common"},{"location":"api/protocols/generator/common/#is_installed","text":"def is_installed ( programme : str ) -> bool Check whether a programme is installed on the system. Arguments : programme : the name of the programme. Returns : True if installed, False otherwise","title":"is_installed"},{"location":"api/protocols/generator/common/#base_protolint_command","text":"def base_protolint_command () -> str Return the base protolint command. Returns : The base protolint command","title":"base_protolint_command"},{"location":"api/protocols/generator/common/#check_prerequisites","text":"def check_prerequisites () -> None Check whether a programme is installed on the system.","title":"check_prerequisites"},{"location":"api/protocols/generator/common/#get_protoc_version","text":"def get_protoc_version () -> str Get the protoc version used.","title":"get_protoc_version"},{"location":"api/protocols/generator/common/#load_protocol_specification","text":"def load_protocol_specification ( specification_path : str ) -> ProtocolSpecification Load a protocol specification. Arguments : specification_path : path to the protocol specification yaml file. Returns : A ProtocolSpecification object","title":"load_protocol_specification"},{"location":"api/protocols/generator/common/#try_run_black_formatting","text":"def try_run_black_formatting ( path_to_protocol_package : str ) -> None Run Black code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied.","title":"try_run_black_formatting"},{"location":"api/protocols/generator/common/#try_run_isort_formatting","text":"def try_run_isort_formatting ( path_to_protocol_package : str ) -> None Run Isort code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied.","title":"try_run_isort_formatting"},{"location":"api/protocols/generator/common/#try_run_protoc","text":"def try_run_protoc ( path_to_generated_protocol_package : str , name : str , language : str = PROTOCOL_LANGUAGE_PYTHON ) -> None Run 'protoc' protocol buffer compiler via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file","title":"try_run_protoc"},{"location":"api/protocols/generator/common/#try_run_protolint","text":"def try_run_protolint ( path_to_generated_protocol_package : str , name : str ) -> None Run 'protolint' linter via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file.","title":"try_run_protolint"},{"location":"api/protocols/generator/common/#check_protobuf_using_protoc","text":"def check_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str ) -> Tuple [ bool , str ] Check whether a protocol buffer schema file is valid. Validation is via trying to compile the schema file. If successfully compiled it is valid, otherwise invalid. If valid, return True and a 'protobuf file is valid' message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"check_protobuf_using_protoc"},{"location":"api/protocols/generator/common/#compile_protobuf_using_protoc","text":"def compile_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str , language : str ) -> Tuple [ bool , str ] Compile a protocol buffer schema file using protoc. If successfully compiled, return True and a success message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file Returns : Boolean result and an accompanying message","title":"compile_protobuf_using_protoc"},{"location":"api/protocols/generator/common/#apply_protolint","text":"def apply_protolint ( path_to_proto_file : str , name : str ) -> Tuple [ bool , str ] Apply protolint linter to a protocol buffer schema file. If no output, return True and a success message, otherwise return False and the output shown by the linter (minus the indentation suggestions which are automatically fixed by protolint). Arguments : path_to_proto_file : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"apply_protolint"},{"location":"api/protocols/generator/extract_specification/","text":"aea.protocols.generator.extract _ specification This module extracts a valid protocol specification into pythonic objects. PythonicProtocolSpecification Objects class PythonicProtocolSpecification () This class represents a protocol specification in python. __ init __ def __init__ () -> None Instantiate a Pythonic protocol specification. extract def extract ( protocol_specification : ProtocolSpecification ) -> PythonicProtocolSpecification Converts a protocol specification into a Pythonic protocol specification. Arguments : protocol_specification : a protocol specification Returns : a Pythonic protocol specification","title":"Extract Specification"},{"location":"api/protocols/generator/extract_specification/#aeaprotocolsgeneratorextract_specification","text":"This module extracts a valid protocol specification into pythonic objects.","title":"aea.protocols.generator.extract_specification"},{"location":"api/protocols/generator/extract_specification/#pythonicprotocolspecification-objects","text":"class PythonicProtocolSpecification () This class represents a protocol specification in python.","title":"PythonicProtocolSpecification Objects"},{"location":"api/protocols/generator/extract_specification/#__init__","text":"def __init__ () -> None Instantiate a Pythonic protocol specification.","title":"__init__"},{"location":"api/protocols/generator/extract_specification/#extract","text":"def extract ( protocol_specification : ProtocolSpecification ) -> PythonicProtocolSpecification Converts a protocol specification into a Pythonic protocol specification. Arguments : protocol_specification : a protocol specification Returns : a Pythonic protocol specification","title":"extract"},{"location":"api/protocols/generator/validate/","text":"aea.protocols.generator.validate This module validates a protocol specification. validate def validate ( protocol_specification : ProtocolSpecification ) -> Tuple [ bool , str ] Evaluate whether a protocol specification is valid. Arguments : protocol_specification : a protocol specification. Returns : Boolean result, and associated message.","title":"Validate"},{"location":"api/protocols/generator/validate/#aeaprotocolsgeneratorvalidate","text":"This module validates a protocol specification.","title":"aea.protocols.generator.validate"},{"location":"api/protocols/generator/validate/#validate","text":"def validate ( protocol_specification : ProtocolSpecification ) -> Tuple [ bool , str ] Evaluate whether a protocol specification is valid. Arguments : protocol_specification : a protocol specification. Returns : Boolean result, and associated message.","title":"validate"},{"location":"api/protocols/signing/custom_types/","text":"packages.open _ aea.protocols.signing.custom _ types This module contains class representations corresponding to every custom type in the protocol specification. ErrorCode Objects class ErrorCode ( Enum ) This class represents an instance of ErrorCode. encode @staticmethod def encode ( error_code_protobuf_object : Any , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. decode @classmethod def decode ( cls , error_code_protobuf_object : Any ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"Custom Types"},{"location":"api/protocols/signing/custom_types/#packagesopen_aeaprotocolssigningcustom_types","text":"This module contains class representations corresponding to every custom type in the protocol specification.","title":"packages.open_aea.protocols.signing.custom_types"},{"location":"api/protocols/signing/custom_types/#errorcode-objects","text":"class ErrorCode ( Enum ) This class represents an instance of ErrorCode.","title":"ErrorCode Objects"},{"location":"api/protocols/signing/custom_types/#encode","text":"@staticmethod def encode ( error_code_protobuf_object : Any , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"api/protocols/signing/custom_types/#decode","text":"@classmethod def decode ( cls , error_code_protobuf_object : Any ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"decode"},{"location":"api/protocols/signing/dialogues/","text":"packages.open _ aea.protocols.signing.dialogues This module contains the classes required for signing dialogue management. SigningDialogue: The dialogue class maintains state of a dialogue and manages it. SigningDialogues: The dialogues class keeps track of all dialogues. SigningDialogue Objects class SigningDialogue ( Dialogue ) The signing dialogue class maintains state of a dialogue and manages it. Role Objects class Role ( Dialogue . Role ) This class defines the agent's role in a signing dialogue. EndState Objects class EndState ( Dialogue . EndState ) This class defines the end states of a signing dialogue. __ init __ def __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for message_class : the message class used SigningDialogues Objects class SigningDialogues ( Dialogues , ABC ) This class keeps track of all signing dialogues. __ init __ def __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ SigningDialogue ] = SigningDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained dialogue_class : the dialogue class used role_from_first_message : the callable determining role from first message","title":"Dialogues"},{"location":"api/protocols/signing/dialogues/#packagesopen_aeaprotocolssigningdialogues","text":"This module contains the classes required for signing dialogue management. SigningDialogue: The dialogue class maintains state of a dialogue and manages it. SigningDialogues: The dialogues class keeps track of all dialogues.","title":"packages.open_aea.protocols.signing.dialogues"},{"location":"api/protocols/signing/dialogues/#signingdialogue-objects","text":"class SigningDialogue ( Dialogue ) The signing dialogue class maintains state of a dialogue and manages it.","title":"SigningDialogue Objects"},{"location":"api/protocols/signing/dialogues/#role-objects","text":"class Role ( Dialogue . Role ) This class defines the agent's role in a signing dialogue.","title":"Role Objects"},{"location":"api/protocols/signing/dialogues/#endstate-objects","text":"class EndState ( Dialogue . EndState ) This class defines the end states of a signing dialogue.","title":"EndState Objects"},{"location":"api/protocols/signing/dialogues/#__init__","text":"def __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for message_class : the message class used","title":"__init__"},{"location":"api/protocols/signing/dialogues/#signingdialogues-objects","text":"class SigningDialogues ( Dialogues , ABC ) This class keeps track of all signing dialogues.","title":"SigningDialogues Objects"},{"location":"api/protocols/signing/dialogues/#__init___1","text":"def __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ SigningDialogue ] = SigningDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained dialogue_class : the dialogue class used role_from_first_message : the callable determining role from first message","title":"__init__"},{"location":"api/protocols/signing/message/","text":"packages.open _ aea.protocols.signing.message This module contains signing's message definition. SigningMessage Objects class SigningMessage ( Message ) A protocol for communication between skills and decision maker. Performative Objects class Performative ( Message . Performative ) Performatives for the signing protocol. __ str __ def __str__ () -> str Get the string representation. __ init __","title":"Message"},{"location":"api/protocols/signing/message/#packagesopen_aeaprotocolssigningmessage","text":"This module contains signing's message definition.","title":"packages.open_aea.protocols.signing.message"},{"location":"api/protocols/signing/message/#signingmessage-objects","text":"class SigningMessage ( Message ) A protocol for communication between skills and decision maker.","title":"SigningMessage Objects"},{"location":"api/protocols/signing/message/#performative-objects","text":"class Performative ( Message . Performative ) Performatives for the signing protocol.","title":"Performative Objects"},{"location":"api/protocols/signing/message/#__str__","text":"def __str__ () -> str Get the string representation.","title":"__str__"},{"location":"api/protocols/signing/message/#__init__","text":"","title":"__init__"},{"location":"api/protocols/signing/serialization/","text":"packages.open _ aea.protocols.signing.serialization Serialization module for signing protocol. SigningSerializer Objects class SigningSerializer ( Serializer ) Serialization for the 'signing' protocol. encode @staticmethod def encode ( msg : Message ) -> bytes Encode a 'Signing' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode @staticmethod def decode ( obj : bytes ) -> Message Decode bytes into a 'Signing' message. Arguments : obj : the bytes object. Returns : the 'Signing' message.","title":"Serialization"},{"location":"api/protocols/signing/serialization/#packagesopen_aeaprotocolssigningserialization","text":"Serialization module for signing protocol.","title":"packages.open_aea.protocols.signing.serialization"},{"location":"api/protocols/signing/serialization/#signingserializer-objects","text":"class SigningSerializer ( Serializer ) Serialization for the 'signing' protocol.","title":"SigningSerializer Objects"},{"location":"api/protocols/signing/serialization/#encode","text":"@staticmethod def encode ( msg : Message ) -> bytes Encode a 'Signing' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"api/protocols/signing/serialization/#decode","text":"@staticmethod def decode ( obj : bytes ) -> Message Decode bytes into a 'Signing' message. Arguments : obj : the bytes object. Returns : the 'Signing' message.","title":"decode"},{"location":"api/registries/base/","text":"aea.registries.base This module contains registries. Registry Objects class Registry ( Generic [ ItemId , Item ], WithLogger , ABC ) This class implements an abstract registry. __ init __ def __init__ ( agent_name : str = \"standalone\" ) -> None Initialize the registry. Arguments : agent_name : the name of the agent register @abstractmethod def register ( item_id : ItemId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. is_dynamically_added : whether or not the item is dynamically added. Raises : None : ValueError if an item is already registered with that item id. Returns : None unregister @abstractmethod def unregister ( item_id : ItemId ) -> Optional [ Item ] Unregister an item. Arguments : item_id : the public id of the item. Raises : None : ValueError if no item registered with that item id. Returns : the item fetch @abstractmethod def fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ all @abstractmethod def fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items. ids @abstractmethod def ids () -> Set [ ItemId ] Return the set of all the used item ids. Returns : the set of item ids. setup @abstractmethod def setup () -> None Set up registry. Returns : None teardown @abstractmethod def teardown () -> None Teardown the registry. Returns : None PublicIdRegistry Objects class PublicIdRegistry ( Generic [ Item ], Registry [ PublicId , Item ]) This class implement a registry whose keys are public ids. In particular, it is able to handle the case when the public id points to the 'latest' version of a package. __ init __ def __init__ () -> None Initialize the registry. register def register ( public_id : PublicId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. unregister def unregister ( public_id : PublicId ) -> Item Unregister an item. fetch def fetch ( public_id : PublicId ) -> Optional [ Item ] Fetch an item associated with a public id. Arguments : public_id : the public id. Returns : an item, or None if the key is not present. fetch _ all def fetch_all () -> List [ Item ] Fetch all the items. ids def ids () -> Set [ PublicId ] Get all the item ids. setup def setup () -> None Set up the items. teardown def teardown () -> None Tear down the items. AgentComponentRegistry Objects class AgentComponentRegistry ( Registry [ ComponentId , Component ]) This class implements a simple dictionary-based registry for agent components. __ init __ def __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs register def register ( component_id : ComponentId , component : Component , is_dynamically_added : bool = False ) -> None Register a component. Arguments : component_id : the id of the component. component : the component object. is_dynamically_added : whether or not the item is dynamically added. unregister def unregister ( component_id : ComponentId ) -> Optional [ Component ] Unregister a component. Arguments : component_id : the ComponentId Returns : the item fetch def fetch ( component_id : ComponentId ) -> Optional [ Component ] Fetch the component by id. Arguments : component_id : the contract id Returns : the component or None if the component is not registered fetch _ all def fetch_all () -> List [ Component ] Fetch all the components. Returns : the list of registered components. fetch _ by _ type def fetch_by_type ( component_type : ComponentType ) -> List [ Component ] Fetch all the components by a given type.. Arguments : component_type : a component type Returns : the list of registered components of a given type. ids def ids () -> Set [ ComponentId ] Get the item ids. setup def setup () -> None Set up the registry. teardown def teardown () -> None Teardown the registry. ComponentRegistry Objects class ComponentRegistry ( Registry [ Tuple [ PublicId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components. __ init __ def __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs register def register ( item_id : Tuple [ PublicId , str ], item : SkillComponentType , is_dynamically_added : bool = False ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. is_dynamically_added : whether or not the item is dynamically added. Raises : None : ValueError if an item is already registered with that item id. unregister def unregister ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Unregister a item. Arguments : item_id : a pair (skill id, item name). Raises : None : ValueError if no item registered with that item id. Returns : skill component fetch def fetch ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ by _ skill def fetch_by_skill ( skill_id : PublicId ) -> List [ SkillComponentType ] Fetch all the items of a given skill. fetch _ all def fetch_all () -> List [ SkillComponentType ] Fetch all the items. unregister _ by _ skill def unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill. ids def ids () -> Set [ Tuple [ PublicId , str ]] Get the item ids. setup def setup () -> None Set up the items in the registry. teardown def teardown () -> None Teardown the registry. HandlerRegistry Objects class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry. __ init __ def __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs register def register ( item_id : Tuple [ PublicId , str ], item : Handler , is_dynamically_added : bool = False ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. is_dynamically_added : whether or not the item is dynamically added. Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists. unregister def unregister ( item_id : Tuple [ PublicId , str ]) -> Handler Unregister a item. Arguments : item_id : a pair (skill id, item name). Raises : None : ValueError if no item is registered with that item id. Returns : the unregistered handler unregister _ by _ skill def unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill. fetch _ by _ protocol def fetch_by_protocol ( protocol_id : PublicId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id fetch _ by _ protocol _ and _ skill def fetch_by_protocol_and_skill ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id","title":"Base"},{"location":"api/registries/base/#aearegistriesbase","text":"This module contains registries.","title":"aea.registries.base"},{"location":"api/registries/base/#registry-objects","text":"class Registry ( Generic [ ItemId , Item ], WithLogger , ABC ) This class implements an abstract registry.","title":"Registry Objects"},{"location":"api/registries/base/#__init__","text":"def __init__ ( agent_name : str = \"standalone\" ) -> None Initialize the registry. Arguments : agent_name : the name of the agent","title":"__init__"},{"location":"api/registries/base/#register","text":"@abstractmethod def register ( item_id : ItemId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. is_dynamically_added : whether or not the item is dynamically added. Raises : None : ValueError if an item is already registered with that item id. Returns : None","title":"register"},{"location":"api/registries/base/#unregister","text":"@abstractmethod def unregister ( item_id : ItemId ) -> Optional [ Item ] Unregister an item. Arguments : item_id : the public id of the item. Raises : None : ValueError if no item registered with that item id. Returns : the item","title":"unregister"},{"location":"api/registries/base/#fetch","text":"@abstractmethod def fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"api/registries/base/#fetch_all","text":"@abstractmethod def fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items.","title":"fetch_all"},{"location":"api/registries/base/#ids","text":"@abstractmethod def ids () -> Set [ ItemId ] Return the set of all the used item ids. Returns : the set of item ids.","title":"ids"},{"location":"api/registries/base/#setup","text":"@abstractmethod def setup () -> None Set up registry. Returns : None","title":"setup"},{"location":"api/registries/base/#teardown","text":"@abstractmethod def teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"api/registries/base/#publicidregistry-objects","text":"class PublicIdRegistry ( Generic [ Item ], Registry [ PublicId , Item ]) This class implement a registry whose keys are public ids. In particular, it is able to handle the case when the public id points to the 'latest' version of a package.","title":"PublicIdRegistry Objects"},{"location":"api/registries/base/#__init___1","text":"def __init__ () -> None Initialize the registry.","title":"__init__"},{"location":"api/registries/base/#register_1","text":"def register ( public_id : PublicId , item : Item , is_dynamically_added : bool = False ) -> None Register an item.","title":"register"},{"location":"api/registries/base/#unregister_1","text":"def unregister ( public_id : PublicId ) -> Item Unregister an item.","title":"unregister"},{"location":"api/registries/base/#fetch_1","text":"def fetch ( public_id : PublicId ) -> Optional [ Item ] Fetch an item associated with a public id. Arguments : public_id : the public id. Returns : an item, or None if the key is not present.","title":"fetch"},{"location":"api/registries/base/#fetch_all_1","text":"def fetch_all () -> List [ Item ] Fetch all the items.","title":"fetch_all"},{"location":"api/registries/base/#ids_1","text":"def ids () -> Set [ PublicId ] Get all the item ids.","title":"ids"},{"location":"api/registries/base/#setup_1","text":"def setup () -> None Set up the items.","title":"setup"},{"location":"api/registries/base/#teardown_1","text":"def teardown () -> None Tear down the items.","title":"teardown"},{"location":"api/registries/base/#agentcomponentregistry-objects","text":"class AgentComponentRegistry ( Registry [ ComponentId , Component ]) This class implements a simple dictionary-based registry for agent components.","title":"AgentComponentRegistry Objects"},{"location":"api/registries/base/#__init___2","text":"def __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs","title":"__init__"},{"location":"api/registries/base/#register_2","text":"def register ( component_id : ComponentId , component : Component , is_dynamically_added : bool = False ) -> None Register a component. Arguments : component_id : the id of the component. component : the component object. is_dynamically_added : whether or not the item is dynamically added.","title":"register"},{"location":"api/registries/base/#unregister_2","text":"def unregister ( component_id : ComponentId ) -> Optional [ Component ] Unregister a component. Arguments : component_id : the ComponentId Returns : the item","title":"unregister"},{"location":"api/registries/base/#fetch_2","text":"def fetch ( component_id : ComponentId ) -> Optional [ Component ] Fetch the component by id. Arguments : component_id : the contract id Returns : the component or None if the component is not registered","title":"fetch"},{"location":"api/registries/base/#fetch_all_2","text":"def fetch_all () -> List [ Component ] Fetch all the components. Returns : the list of registered components.","title":"fetch_all"},{"location":"api/registries/base/#fetch_by_type","text":"def fetch_by_type ( component_type : ComponentType ) -> List [ Component ] Fetch all the components by a given type.. Arguments : component_type : a component type Returns : the list of registered components of a given type.","title":"fetch_by_type"},{"location":"api/registries/base/#ids_2","text":"def ids () -> Set [ ComponentId ] Get the item ids.","title":"ids"},{"location":"api/registries/base/#setup_2","text":"def setup () -> None Set up the registry.","title":"setup"},{"location":"api/registries/base/#teardown_2","text":"def teardown () -> None Teardown the registry.","title":"teardown"},{"location":"api/registries/base/#componentregistry-objects","text":"class ComponentRegistry ( Registry [ Tuple [ PublicId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components.","title":"ComponentRegistry Objects"},{"location":"api/registries/base/#__init___3","text":"def __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs","title":"__init__"},{"location":"api/registries/base/#register_3","text":"def register ( item_id : Tuple [ PublicId , str ], item : SkillComponentType , is_dynamically_added : bool = False ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. is_dynamically_added : whether or not the item is dynamically added. Raises : None : ValueError if an item is already registered with that item id.","title":"register"},{"location":"api/registries/base/#unregister_3","text":"def unregister ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Unregister a item. Arguments : item_id : a pair (skill id, item name). Raises : None : ValueError if no item registered with that item id. Returns : skill component","title":"unregister"},{"location":"api/registries/base/#fetch_3","text":"def fetch ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"api/registries/base/#fetch_by_skill","text":"def fetch_by_skill ( skill_id : PublicId ) -> List [ SkillComponentType ] Fetch all the items of a given skill.","title":"fetch_by_skill"},{"location":"api/registries/base/#fetch_all_3","text":"def fetch_all () -> List [ SkillComponentType ] Fetch all the items.","title":"fetch_all"},{"location":"api/registries/base/#unregister_by_skill","text":"def unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"api/registries/base/#ids_3","text":"def ids () -> Set [ Tuple [ PublicId , str ]] Get the item ids.","title":"ids"},{"location":"api/registries/base/#setup_3","text":"def setup () -> None Set up the items in the registry.","title":"setup"},{"location":"api/registries/base/#teardown_3","text":"def teardown () -> None Teardown the registry.","title":"teardown"},{"location":"api/registries/base/#handlerregistry-objects","text":"class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry.","title":"HandlerRegistry Objects"},{"location":"api/registries/base/#__init___4","text":"def __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs","title":"__init__"},{"location":"api/registries/base/#register_4","text":"def register ( item_id : Tuple [ PublicId , str ], item : Handler , is_dynamically_added : bool = False ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. is_dynamically_added : whether or not the item is dynamically added. Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists.","title":"register"},{"location":"api/registries/base/#unregister_4","text":"def unregister ( item_id : Tuple [ PublicId , str ]) -> Handler Unregister a item. Arguments : item_id : a pair (skill id, item name). Raises : None : ValueError if no item is registered with that item id. Returns : the unregistered handler","title":"unregister"},{"location":"api/registries/base/#unregister_by_skill_1","text":"def unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"api/registries/base/#fetch_by_protocol","text":"def fetch_by_protocol ( protocol_id : PublicId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol"},{"location":"api/registries/base/#fetch_by_protocol_and_skill","text":"def fetch_by_protocol_and_skill ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol_and_skill"},{"location":"api/registries/filter/","text":"aea.registries.filter This module contains registries. Filter Objects class Filter ( WithLogger ) This class implements the filter of an AEA. __ init __ def __init__ ( resources : Resources , decision_maker_out_queue : AsyncFriendlyQueue ) -> None Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue resources @property def resources () -> Resources Get resources. decision _ maker _ out _ queue @property def decision_maker_out_queue () -> AsyncFriendlyQueue Get decision maker (out) queue. get _ active _ handlers def get_active_handlers ( protocol_id : PublicId , skill_id : Optional [ PublicId ] = None ) -> List [ Handler ] Get active handlers based on protocol id and optional skill id. Arguments : protocol_id : the protocol id skill_id : the skill id Returns : the list of handlers currently active get _ active _ behaviours def get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active handle _ new _ handlers _ and _ behaviours def handle_new_handlers_and_behaviours () -> None Handle the messages from the decision maker. get _ internal _ message async def get_internal_message () -> Optional [ Message ] Get a message from decision_maker_out_queue. handle _ internal _ message def handle_internal_message ( internal_message : Optional [ Message ]) -> None Handle internal message.","title":"Filter"},{"location":"api/registries/filter/#aearegistriesfilter","text":"This module contains registries.","title":"aea.registries.filter"},{"location":"api/registries/filter/#filter-objects","text":"class Filter ( WithLogger ) This class implements the filter of an AEA.","title":"Filter Objects"},{"location":"api/registries/filter/#__init__","text":"def __init__ ( resources : Resources , decision_maker_out_queue : AsyncFriendlyQueue ) -> None Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue","title":"__init__"},{"location":"api/registries/filter/#resources","text":"@property def resources () -> Resources Get resources.","title":"resources"},{"location":"api/registries/filter/#decision_maker_out_queue","text":"@property def decision_maker_out_queue () -> AsyncFriendlyQueue Get decision maker (out) queue.","title":"decision_maker_out_queue"},{"location":"api/registries/filter/#get_active_handlers","text":"def get_active_handlers ( protocol_id : PublicId , skill_id : Optional [ PublicId ] = None ) -> List [ Handler ] Get active handlers based on protocol id and optional skill id. Arguments : protocol_id : the protocol id skill_id : the skill id Returns : the list of handlers currently active","title":"get_active_handlers"},{"location":"api/registries/filter/#get_active_behaviours","text":"def get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active","title":"get_active_behaviours"},{"location":"api/registries/filter/#handle_new_handlers_and_behaviours","text":"def handle_new_handlers_and_behaviours () -> None Handle the messages from the decision maker.","title":"handle_new_handlers_and_behaviours"},{"location":"api/registries/filter/#get_internal_message","text":"async def get_internal_message () -> Optional [ Message ] Get a message from decision_maker_out_queue.","title":"get_internal_message"},{"location":"api/registries/filter/#handle_internal_message","text":"def handle_internal_message ( internal_message : Optional [ Message ]) -> None Handle internal message.","title":"handle_internal_message"},{"location":"api/registries/resources/","text":"aea.registries.resources This module contains the resources class. Resources Objects class Resources () This class implements the object that holds the resources of an AEA. __ init __ def __init__ ( agent_name : str = \"standalone\" ) -> None Instantiate the resources. Arguments : agent_name : the name of the agent agent _ name @property def agent_name () -> str Get the agent name. component _ registry @property def component_registry () -> AgentComponentRegistry Get the agent component registry. behaviour _ registry @property def behaviour_registry () -> ComponentRegistry [ Behaviour ] Get the behaviour registry. handler _ registry @property def handler_registry () -> HandlerRegistry Get the handler registry. model _ registry @property def model_registry () -> ComponentRegistry [ Model ] Get the model registry. add _ component def add_component ( component : Component ) -> None Add a component to resources. add _ protocol def add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol get _ protocol def get_protocol ( protocol_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None get _ protocol _ by _ specification _ id def get_protocol_by_specification_id ( protocol_specification_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol_specification_id. Arguments : protocol_specification_id : the protocol id Returns : a matching protocol, if present, else None get _ all _ protocols def get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols. remove _ protocol def remove_protocol ( protocol_id : PublicId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed. add _ contract def add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract get _ contract def get_contract ( contract_id : PublicId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None get _ all _ contracts def get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts. remove _ contract def remove_contract ( contract_id : PublicId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed. add _ connection def add_connection ( connection : Connection ) -> None Add a connection to the set of resources. Arguments : connection : a connection get _ connection def get_connection ( connection_id : PublicId ) -> Optional [ Connection ] Get connection for given connection id. Arguments : connection_id : the connection id Returns : a matching connection, if present, else None get _ all _ connections def get_all_connections () -> List [ Connection ] Get the list of all the connections. Returns : the list of connections. remove _ connection def remove_connection ( connection_id : PublicId ) -> None Remove a connection from the set of resources. Arguments : connection_id : the connection id for the connection to be removed. add _ skill def add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill get _ skill def get_skill ( skill_id : PublicId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None get _ all _ skills def get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills. remove _ skill def remove_skill ( skill_id : PublicId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed. get _ handler def get_handler ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler get _ handlers def get_handlers ( protocol_id : PublicId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol get _ all _ handlers def get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers get _ behaviour def get_behaviour ( skill_id : PublicId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None get _ behaviours def get_behaviours ( skill_id : PublicId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill get _ all _ behaviours def get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours setup def setup () -> None Set up the resources. Calls setup on all resources. teardown def teardown () -> None Teardown the resources. Calls teardown on all resources.","title":"Resources"},{"location":"api/registries/resources/#aearegistriesresources","text":"This module contains the resources class.","title":"aea.registries.resources"},{"location":"api/registries/resources/#resources-objects","text":"class Resources () This class implements the object that holds the resources of an AEA.","title":"Resources Objects"},{"location":"api/registries/resources/#__init__","text":"def __init__ ( agent_name : str = \"standalone\" ) -> None Instantiate the resources. Arguments : agent_name : the name of the agent","title":"__init__"},{"location":"api/registries/resources/#agent_name","text":"@property def agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"api/registries/resources/#component_registry","text":"@property def component_registry () -> AgentComponentRegistry Get the agent component registry.","title":"component_registry"},{"location":"api/registries/resources/#behaviour_registry","text":"@property def behaviour_registry () -> ComponentRegistry [ Behaviour ] Get the behaviour registry.","title":"behaviour_registry"},{"location":"api/registries/resources/#handler_registry","text":"@property def handler_registry () -> HandlerRegistry Get the handler registry.","title":"handler_registry"},{"location":"api/registries/resources/#model_registry","text":"@property def model_registry () -> ComponentRegistry [ Model ] Get the model registry.","title":"model_registry"},{"location":"api/registries/resources/#add_component","text":"def add_component ( component : Component ) -> None Add a component to resources.","title":"add_component"},{"location":"api/registries/resources/#add_protocol","text":"def add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol","title":"add_protocol"},{"location":"api/registries/resources/#get_protocol","text":"def get_protocol ( protocol_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None","title":"get_protocol"},{"location":"api/registries/resources/#get_protocol_by_specification_id","text":"def get_protocol_by_specification_id ( protocol_specification_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol_specification_id. Arguments : protocol_specification_id : the protocol id Returns : a matching protocol, if present, else None","title":"get_protocol_by_specification_id"},{"location":"api/registries/resources/#get_all_protocols","text":"def get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols.","title":"get_all_protocols"},{"location":"api/registries/resources/#remove_protocol","text":"def remove_protocol ( protocol_id : PublicId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed.","title":"remove_protocol"},{"location":"api/registries/resources/#add_contract","text":"def add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract","title":"add_contract"},{"location":"api/registries/resources/#get_contract","text":"def get_contract ( contract_id : PublicId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None","title":"get_contract"},{"location":"api/registries/resources/#get_all_contracts","text":"def get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts.","title":"get_all_contracts"},{"location":"api/registries/resources/#remove_contract","text":"def remove_contract ( contract_id : PublicId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed.","title":"remove_contract"},{"location":"api/registries/resources/#add_connection","text":"def add_connection ( connection : Connection ) -> None Add a connection to the set of resources. Arguments : connection : a connection","title":"add_connection"},{"location":"api/registries/resources/#get_connection","text":"def get_connection ( connection_id : PublicId ) -> Optional [ Connection ] Get connection for given connection id. Arguments : connection_id : the connection id Returns : a matching connection, if present, else None","title":"get_connection"},{"location":"api/registries/resources/#get_all_connections","text":"def get_all_connections () -> List [ Connection ] Get the list of all the connections. Returns : the list of connections.","title":"get_all_connections"},{"location":"api/registries/resources/#remove_connection","text":"def remove_connection ( connection_id : PublicId ) -> None Remove a connection from the set of resources. Arguments : connection_id : the connection id for the connection to be removed.","title":"remove_connection"},{"location":"api/registries/resources/#add_skill","text":"def add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill","title":"add_skill"},{"location":"api/registries/resources/#get_skill","text":"def get_skill ( skill_id : PublicId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None","title":"get_skill"},{"location":"api/registries/resources/#get_all_skills","text":"def get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills.","title":"get_all_skills"},{"location":"api/registries/resources/#remove_skill","text":"def remove_skill ( skill_id : PublicId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed.","title":"remove_skill"},{"location":"api/registries/resources/#get_handler","text":"def get_handler ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler","title":"get_handler"},{"location":"api/registries/resources/#get_handlers","text":"def get_handlers ( protocol_id : PublicId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol","title":"get_handlers"},{"location":"api/registries/resources/#get_all_handlers","text":"def get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers","title":"get_all_handlers"},{"location":"api/registries/resources/#get_behaviour","text":"def get_behaviour ( skill_id : PublicId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None","title":"get_behaviour"},{"location":"api/registries/resources/#get_behaviours","text":"def get_behaviours ( skill_id : PublicId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill","title":"get_behaviours"},{"location":"api/registries/resources/#get_all_behaviours","text":"def get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours","title":"get_all_behaviours"},{"location":"api/registries/resources/#setup","text":"def setup () -> None Set up the resources. Calls setup on all resources.","title":"setup"},{"location":"api/registries/resources/#teardown","text":"def teardown () -> None Teardown the resources. Calls teardown on all resources.","title":"teardown"},{"location":"api/skills/base/","text":"aea.skills.base This module contains the base classes for the skills. SkillContext Objects class SkillContext () This class implements the context of a skill. __ init __ def __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) -> None Initialize a skill context. Arguments : agent_context : the agent context. skill : the skill. logger @property def logger () -> Logger Get the logger. logger @logger . setter def logger ( logger_ : Logger ) -> None Set the logger. data _ dir @property def data_dir () -> str Get the agent's data directory set _ agent _ context def set_agent_context ( agent_context : AgentContext ) -> None Set the agent context. shared _ state @property def shared_state () -> Dict [ str , Any ] Get the shared state dictionary. agent _ name @property def agent_name () -> str Get agent name. skill _ id @property def skill_id () -> PublicId Get the skill id of the skill context. is _ active @property def is_active () -> bool Get the status of the skill (active/not active). is _ active @is_active . setter def is_active ( value : bool ) -> None Set the status of the skill (active/not active). new _ behaviours @property def new_behaviours () -> \"Queue[Behaviour]\" Queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. Returns : the queue of new behaviours. new _ handlers @property def new_handlers () -> \"Queue[Handler]\" Queue for the new handlers. This queue can be used to send messages to the framework to request the registration of a handler. Returns : the queue of new handlers. agent _ addresses @property def agent_addresses () -> Dict [ str , str ] Get addresses. agent _ address @property def agent_address () -> str Get address. public _ key @property def public_key () -> str Get public key. public _ keys @property def public_keys () -> Dict [ str , str ] Get public keys. connection _ status @property def connection_status () -> MultiplexerStatus Get connection status. outbox @property def outbox () -> OutBox Get outbox. storage @property def storage () -> Optional [ Storage ] Get optional storage for agent. message _ in _ queue @property def message_in_queue () -> Queue Get message in queue. decision _ maker _ message _ queue @property def decision_maker_message_queue () -> Queue Get message queue of decision maker. decision _ maker _ handler _ context @property def decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context. task _ manager @property def task_manager () -> TaskManager Get behaviours of the skill. default _ ledger _ id @property def default_ledger_id () -> str Get the default ledger id. currency _ denominations @property def currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations. search _ service _ address @property def search_service_address () -> Address Get the address of the search service. decision _ maker _ address @property def decision_maker_address () -> Address Get the address of the decision maker. handlers @property def handlers () -> SimpleNamespace Get handlers of the skill. behaviours @property def behaviours () -> SimpleNamespace Get behaviours of the skill. namespace @property def namespace () -> SimpleNamespace Get the agent context namespace. __ getattr __ def __getattr__ ( item : Any ) -> Any Get attribute. send _ to _ skill def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context SkillComponent Objects class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes. __ init __","title":"Base"},{"location":"api/skills/base/#aeaskillsbase","text":"This module contains the base classes for the skills.","title":"aea.skills.base"},{"location":"api/skills/base/#skillcontext-objects","text":"class SkillContext () This class implements the context of a skill.","title":"SkillContext Objects"},{"location":"api/skills/base/#__init__","text":"def __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) -> None Initialize a skill context. Arguments : agent_context : the agent context. skill : the skill.","title":"__init__"},{"location":"api/skills/base/#logger","text":"@property def logger () -> Logger Get the logger.","title":"logger"},{"location":"api/skills/base/#logger_1","text":"@logger . setter def logger ( logger_ : Logger ) -> None Set the logger.","title":"logger"},{"location":"api/skills/base/#data_dir","text":"@property def data_dir () -> str Get the agent's data directory","title":"data_dir"},{"location":"api/skills/base/#set_agent_context","text":"def set_agent_context ( agent_context : AgentContext ) -> None Set the agent context.","title":"set_agent_context"},{"location":"api/skills/base/#shared_state","text":"@property def shared_state () -> Dict [ str , Any ] Get the shared state dictionary.","title":"shared_state"},{"location":"api/skills/base/#agent_name","text":"@property def agent_name () -> str Get agent name.","title":"agent_name"},{"location":"api/skills/base/#skill_id","text":"@property def skill_id () -> PublicId Get the skill id of the skill context.","title":"skill_id"},{"location":"api/skills/base/#is_active","text":"@property def is_active () -> bool Get the status of the skill (active/not active).","title":"is_active"},{"location":"api/skills/base/#is_active_1","text":"@is_active . setter def is_active ( value : bool ) -> None Set the status of the skill (active/not active).","title":"is_active"},{"location":"api/skills/base/#new_behaviours","text":"@property def new_behaviours () -> \"Queue[Behaviour]\" Queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. Returns : the queue of new behaviours.","title":"new_behaviours"},{"location":"api/skills/base/#new_handlers","text":"@property def new_handlers () -> \"Queue[Handler]\" Queue for the new handlers. This queue can be used to send messages to the framework to request the registration of a handler. Returns : the queue of new handlers.","title":"new_handlers"},{"location":"api/skills/base/#agent_addresses","text":"@property def agent_addresses () -> Dict [ str , str ] Get addresses.","title":"agent_addresses"},{"location":"api/skills/base/#agent_address","text":"@property def agent_address () -> str Get address.","title":"agent_address"},{"location":"api/skills/base/#public_key","text":"@property def public_key () -> str Get public key.","title":"public_key"},{"location":"api/skills/base/#public_keys","text":"@property def public_keys () -> Dict [ str , str ] Get public keys.","title":"public_keys"},{"location":"api/skills/base/#connection_status","text":"@property def connection_status () -> MultiplexerStatus Get connection status.","title":"connection_status"},{"location":"api/skills/base/#outbox","text":"@property def outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"api/skills/base/#storage","text":"@property def storage () -> Optional [ Storage ] Get optional storage for agent.","title":"storage"},{"location":"api/skills/base/#message_in_queue","text":"@property def message_in_queue () -> Queue Get message in queue.","title":"message_in_queue"},{"location":"api/skills/base/#decision_maker_message_queue","text":"@property def decision_maker_message_queue () -> Queue Get message queue of decision maker.","title":"decision_maker_message_queue"},{"location":"api/skills/base/#decision_maker_handler_context","text":"@property def decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context.","title":"decision_maker_handler_context"},{"location":"api/skills/base/#task_manager","text":"@property def task_manager () -> TaskManager Get behaviours of the skill.","title":"task_manager"},{"location":"api/skills/base/#default_ledger_id","text":"@property def default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"api/skills/base/#currency_denominations","text":"@property def currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations.","title":"currency_denominations"},{"location":"api/skills/base/#search_service_address","text":"@property def search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"api/skills/base/#decision_maker_address","text":"@property def decision_maker_address () -> Address Get the address of the decision maker.","title":"decision_maker_address"},{"location":"api/skills/base/#handlers","text":"@property def handlers () -> SimpleNamespace Get handlers of the skill.","title":"handlers"},{"location":"api/skills/base/#behaviours","text":"@property def behaviours () -> SimpleNamespace Get behaviours of the skill.","title":"behaviours"},{"location":"api/skills/base/#namespace","text":"@property def namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"api/skills/base/#__getattr__","text":"def __getattr__ ( item : Any ) -> Any Get attribute.","title":"__getattr__"},{"location":"api/skills/base/#send_to_skill","text":"def send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context","title":"send_to_skill"},{"location":"api/skills/base/#skillcomponent-objects","text":"class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes.","title":"SkillComponent Objects"},{"location":"api/skills/base/#__init___1","text":"","title":"__init__"},{"location":"api/skills/behaviours/","text":"aea.skills.behaviours This module contains the classes for specific behaviours. SimpleBehaviour Objects class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour. __ init __ def __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs : Any ) -> None Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class. setup def setup () -> None Set the behaviour up. act def act () -> None Do the action. teardown def teardown () -> None Tear the behaviour down. CompositeBehaviour Objects class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour. CyclicBehaviour Objects class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour. number _ of _ executions @property def number_of_executions () -> int Get the number of executions. act _ wrapper def act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ done def is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition. Returns : bool indicating status OneShotBehaviour Objects class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour. is _ done def is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper def act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. TickerBehaviour Objects class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval. __ init __ def __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs : Any ) -> None Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset. kwargs : the keyword arguments. tick _ interval @property def tick_interval () -> float Get the tick_interval in seconds. start _ at @property def start_at () -> datetime . datetime Get the start time. last _ act _ time @property def last_act_time () -> datetime . datetime Get the last time the act method has been called. act _ wrapper def act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ time _ to _ act def is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise. SequenceBehaviour Objects class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially. __ init __ def __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs : Any ) -> None Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs : the keyword arguments current _ behaviour @property def current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done. Returns : current behaviour or None act def act () -> None Implement the behaviour. is _ done def is_done () -> bool Return True if the behaviour is terminated, False otherwise. State Objects class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize a state of the state machine. event @property def event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour. is _ done @abstractmethod def is_done () -> bool Return True if the behaviour is terminated, False otherwise. reset def reset () -> None Reset initial conditions. FSMBehaviour Objects class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize the finite-state machine behaviour. is _ started @property def is_started () -> bool Check if the behaviour is started. register _ state def register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Raises : ValueError : if a state with the provided name already exists. register _ final _ state def register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Raises : ValueError : if a state with the provided name already exists. unregister _ state def unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Raises : ValueError : if the state is not registered. states @property def states () -> Set [ str ] Get all the state names. initial _ state @property def initial_state () -> Optional [ str ] Get the initial state name. initial _ state @initial_state . setter def initial_state ( name : str ) -> None Set the initial state. final _ states @property def final_states () -> Set [ str ] Get the final state names. get _ state def get_state ( name : str ) -> Optional [ State ] Get a state from its name. act def act () -> None Implement the behaviour. is _ done def is_done () -> bool Return True if the behaviour is terminated, False otherwise. register _ transition def register_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is already present. unregister _ transition def unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is not present.","title":"Behaviors"},{"location":"api/skills/behaviours/#aeaskillsbehaviours","text":"This module contains the classes for specific behaviours.","title":"aea.skills.behaviours"},{"location":"api/skills/behaviours/#simplebehaviour-objects","text":"class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour.","title":"SimpleBehaviour Objects"},{"location":"api/skills/behaviours/#__init__","text":"def __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs : Any ) -> None Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class.","title":"__init__"},{"location":"api/skills/behaviours/#setup","text":"def setup () -> None Set the behaviour up.","title":"setup"},{"location":"api/skills/behaviours/#act","text":"def act () -> None Do the action.","title":"act"},{"location":"api/skills/behaviours/#teardown","text":"def teardown () -> None Tear the behaviour down.","title":"teardown"},{"location":"api/skills/behaviours/#compositebehaviour-objects","text":"class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour.","title":"CompositeBehaviour Objects"},{"location":"api/skills/behaviours/#cyclicbehaviour-objects","text":"class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped.","title":"CyclicBehaviour Objects"},{"location":"api/skills/behaviours/#__init___1","text":"def __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour.","title":"__init__"},{"location":"api/skills/behaviours/#number_of_executions","text":"@property def number_of_executions () -> int Get the number of executions.","title":"number_of_executions"},{"location":"api/skills/behaviours/#act_wrapper","text":"def act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"api/skills/behaviours/#is_done","text":"def is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition. Returns : bool indicating status","title":"is_done"},{"location":"api/skills/behaviours/#oneshotbehaviour-objects","text":"class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once.","title":"OneShotBehaviour Objects"},{"location":"api/skills/behaviours/#__init___2","text":"def __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour.","title":"__init__"},{"location":"api/skills/behaviours/#is_done_1","text":"def is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"api/skills/behaviours/#act_wrapper_1","text":"def act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"api/skills/behaviours/#tickerbehaviour-objects","text":"class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval.","title":"TickerBehaviour Objects"},{"location":"api/skills/behaviours/#__init___3","text":"def __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs : Any ) -> None Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset. kwargs : the keyword arguments.","title":"__init__"},{"location":"api/skills/behaviours/#tick_interval","text":"@property def tick_interval () -> float Get the tick_interval in seconds.","title":"tick_interval"},{"location":"api/skills/behaviours/#start_at","text":"@property def start_at () -> datetime . datetime Get the start time.","title":"start_at"},{"location":"api/skills/behaviours/#last_act_time","text":"@property def last_act_time () -> datetime . datetime Get the last time the act method has been called.","title":"last_act_time"},{"location":"api/skills/behaviours/#act_wrapper_2","text":"def act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"api/skills/behaviours/#is_time_to_act","text":"def is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise.","title":"is_time_to_act"},{"location":"api/skills/behaviours/#sequencebehaviour-objects","text":"class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially.","title":"SequenceBehaviour Objects"},{"location":"api/skills/behaviours/#__init___4","text":"def __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs : Any ) -> None Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs : the keyword arguments","title":"__init__"},{"location":"api/skills/behaviours/#current_behaviour","text":"@property def current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done. Returns : current behaviour or None","title":"current_behaviour"},{"location":"api/skills/behaviours/#act_1","text":"def act () -> None Implement the behaviour.","title":"act"},{"location":"api/skills/behaviours/#is_done_2","text":"def is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"api/skills/behaviours/#state-objects","text":"class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger.","title":"State Objects"},{"location":"api/skills/behaviours/#__init___5","text":"def __init__ ( ** kwargs : Any ) -> None Initialize a state of the state machine.","title":"__init__"},{"location":"api/skills/behaviours/#event","text":"@property def event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour.","title":"event"},{"location":"api/skills/behaviours/#is_done_3","text":"@abstractmethod def is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"api/skills/behaviours/#reset","text":"def reset () -> None Reset initial conditions.","title":"reset"},{"location":"api/skills/behaviours/#fsmbehaviour-objects","text":"class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour.","title":"FSMBehaviour Objects"},{"location":"api/skills/behaviours/#__init___6","text":"def __init__ ( ** kwargs : Any ) -> None Initialize the finite-state machine behaviour.","title":"__init__"},{"location":"api/skills/behaviours/#is_started","text":"@property def is_started () -> bool Check if the behaviour is started.","title":"is_started"},{"location":"api/skills/behaviours/#register_state","text":"def register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Raises : ValueError : if a state with the provided name already exists.","title":"register_state"},{"location":"api/skills/behaviours/#register_final_state","text":"def register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Raises : ValueError : if a state with the provided name already exists.","title":"register_final_state"},{"location":"api/skills/behaviours/#unregister_state","text":"def unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Raises : ValueError : if the state is not registered.","title":"unregister_state"},{"location":"api/skills/behaviours/#states","text":"@property def states () -> Set [ str ] Get all the state names.","title":"states"},{"location":"api/skills/behaviours/#initial_state","text":"@property def initial_state () -> Optional [ str ] Get the initial state name.","title":"initial_state"},{"location":"api/skills/behaviours/#initial_state_1","text":"@initial_state . setter def initial_state ( name : str ) -> None Set the initial state.","title":"initial_state"},{"location":"api/skills/behaviours/#final_states","text":"@property def final_states () -> Set [ str ] Get the final state names.","title":"final_states"},{"location":"api/skills/behaviours/#get_state","text":"def get_state ( name : str ) -> Optional [ State ] Get a state from its name.","title":"get_state"},{"location":"api/skills/behaviours/#act_2","text":"def act () -> None Implement the behaviour.","title":"act"},{"location":"api/skills/behaviours/#is_done_4","text":"def is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"api/skills/behaviours/#register_transition","text":"def register_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is already present.","title":"register_transition"},{"location":"api/skills/behaviours/#unregister_transition","text":"def unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is not present.","title":"unregister_transition"},{"location":"api/skills/tasks/","text":"aea.skills.tasks This module contains the classes for tasks. Task Objects class Task ( WithLogger ) This class implements an abstract task. __ init __ def __init__ ( ** kwargs : Any ) -> None Initialize a task. __ call __ def __call__ ( * args : Any , ** kwargs : Any ) -> Any Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. Raises : ValueError : if the task has already been executed. Returns : the task instance is _ executed @property def is_executed () -> bool Check if the task has already been executed. result @property def result () -> Any Get the result. Raises : ValueError : if the task has not been executed yet. Returns : the result from the execute method. setup def setup () -> None Implement the task setup. execute @abstractmethod def execute ( * args : Any , ** kwargs : Any ) -> Any Run the task logic. Arguments : args : the positional arguments kwargs : the keyword arguments Returns : any teardown def teardown () -> None Implement the task teardown. init _ worker def init_worker () -> None Initialize a worker. Disable the SIGINT handler of process pool is using. Related to a well-known bug: https://bugs.python.org/issue8296 TaskManager Objects class TaskManager ( WithLogger ) A Task manager. __ init __ def __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None , pool_mode : str = THREAD_POOL_MODE ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger. pool_mode : str. multithread or multiprocess is _ started @property def is_started () -> bool Get started status of TaskManager. Returns : bool nb _ workers @property def nb_workers () -> int Get the number of workers. Returns : int enqueue _ task def enqueue_task ( func : Callable , args : Sequence = (), kwargs : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwargs : the keyword arguments to be passed to the function. Raises : ValueError : if the task manager is not running. Returns : the task id to get the the result. get _ task _ result def get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Arguments : task_id : the task id Returns : async result for task_id start def start () -> None Start the task manager. stop def stop () -> None Stop the task manager. ThreadedTaskManager Objects class ThreadedTaskManager ( TaskManager ) A threaded task manager. __ init __ def __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger. ProcessTaskManager Objects class ProcessTaskManager ( TaskManager ) A multiprocess task manager. __ init __ def __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger.","title":"Task"},{"location":"api/skills/tasks/#aeaskillstasks","text":"This module contains the classes for tasks.","title":"aea.skills.tasks"},{"location":"api/skills/tasks/#task-objects","text":"class Task ( WithLogger ) This class implements an abstract task.","title":"Task Objects"},{"location":"api/skills/tasks/#__init__","text":"def __init__ ( ** kwargs : Any ) -> None Initialize a task.","title":"__init__"},{"location":"api/skills/tasks/#__call__","text":"def __call__ ( * args : Any , ** kwargs : Any ) -> Any Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. Raises : ValueError : if the task has already been executed. Returns : the task instance","title":"__call__"},{"location":"api/skills/tasks/#is_executed","text":"@property def is_executed () -> bool Check if the task has already been executed.","title":"is_executed"},{"location":"api/skills/tasks/#result","text":"@property def result () -> Any Get the result. Raises : ValueError : if the task has not been executed yet. Returns : the result from the execute method.","title":"result"},{"location":"api/skills/tasks/#setup","text":"def setup () -> None Implement the task setup.","title":"setup"},{"location":"api/skills/tasks/#execute","text":"@abstractmethod def execute ( * args : Any , ** kwargs : Any ) -> Any Run the task logic. Arguments : args : the positional arguments kwargs : the keyword arguments Returns : any","title":"execute"},{"location":"api/skills/tasks/#teardown","text":"def teardown () -> None Implement the task teardown.","title":"teardown"},{"location":"api/skills/tasks/#init_worker","text":"def init_worker () -> None Initialize a worker. Disable the SIGINT handler of process pool is using. Related to a well-known bug: https://bugs.python.org/issue8296","title":"init_worker"},{"location":"api/skills/tasks/#taskmanager-objects","text":"class TaskManager ( WithLogger ) A Task manager.","title":"TaskManager Objects"},{"location":"api/skills/tasks/#__init___1","text":"def __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None , pool_mode : str = THREAD_POOL_MODE ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger. pool_mode : str. multithread or multiprocess","title":"__init__"},{"location":"api/skills/tasks/#is_started","text":"@property def is_started () -> bool Get started status of TaskManager. Returns : bool","title":"is_started"},{"location":"api/skills/tasks/#nb_workers","text":"@property def nb_workers () -> int Get the number of workers. Returns : int","title":"nb_workers"},{"location":"api/skills/tasks/#enqueue_task","text":"def enqueue_task ( func : Callable , args : Sequence = (), kwargs : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwargs : the keyword arguments to be passed to the function. Raises : ValueError : if the task manager is not running. Returns : the task id to get the the result.","title":"enqueue_task"},{"location":"api/skills/tasks/#get_task_result","text":"def get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Arguments : task_id : the task id Returns : async result for task_id","title":"get_task_result"},{"location":"api/skills/tasks/#start","text":"def start () -> None Start the task manager.","title":"start"},{"location":"api/skills/tasks/#stop","text":"def stop () -> None Stop the task manager.","title":"stop"},{"location":"api/skills/tasks/#threadedtaskmanager-objects","text":"class ThreadedTaskManager ( TaskManager ) A threaded task manager.","title":"ThreadedTaskManager Objects"},{"location":"api/skills/tasks/#__init___2","text":"def __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger.","title":"__init__"},{"location":"api/skills/tasks/#processtaskmanager-objects","text":"class ProcessTaskManager ( TaskManager ) A multiprocess task manager.","title":"ProcessTaskManager Objects"},{"location":"api/skills/tasks/#__init___3","text":"def __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger.","title":"__init__"},{"location":"api/test_tools/constants/","text":"aea.test _ tools.constants This is a module with constants for test tools.","title":"Constants"},{"location":"api/test_tools/constants/#aeatest_toolsconstants","text":"This is a module with constants for test tools.","title":"aea.test_tools.constants"},{"location":"api/test_tools/exceptions/","text":"aea.test _ tools.exceptions Module with AEA testing exceptions. AEATestingException Objects class AEATestingException ( Exception ) An exception to be raised on incorrect testing tools usage.","title":"Exceptions"},{"location":"api/test_tools/exceptions/#aeatest_toolsexceptions","text":"Module with AEA testing exceptions.","title":"aea.test_tools.exceptions"},{"location":"api/test_tools/exceptions/#aeatestingexception-objects","text":"class AEATestingException ( Exception ) An exception to be raised on incorrect testing tools usage.","title":"AEATestingException Objects"},{"location":"api/test_tools/generic/","text":"aea.test _ tools.generic This module contains generic tools for AEA end-to-end testing. write _ envelope _ to _ file def write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path read _ envelope _ from _ file def read_envelope_from_file ( file_path : str ) -> Envelope Read an envelope from a file. Arguments : file_path : the file path. Returns : envelope nested _ set _ config def nested_set_config ( dotted_path : str , value : Any , author : str = DEFAULT_AUTHOR ) -> None Set an AEA config with nested values. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. author : the author name, used to parse the dotted path.","title":"Generic"},{"location":"api/test_tools/generic/#aeatest_toolsgeneric","text":"This module contains generic tools for AEA end-to-end testing.","title":"aea.test_tools.generic"},{"location":"api/test_tools/generic/#write_envelope_to_file","text":"def write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path","title":"write_envelope_to_file"},{"location":"api/test_tools/generic/#read_envelope_from_file","text":"def read_envelope_from_file ( file_path : str ) -> Envelope Read an envelope from a file. Arguments : file_path : the file path. Returns : envelope","title":"read_envelope_from_file"},{"location":"api/test_tools/generic/#nested_set_config","text":"def nested_set_config ( dotted_path : str , value : Any , author : str = DEFAULT_AUTHOR ) -> None Set an AEA config with nested values. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. author : the author name, used to parse the dotted path.","title":"nested_set_config"},{"location":"api/test_tools/test_cases/","text":"aea.test _ tools.test _ cases This module contains test case classes based on pytest for AEA end-to-end testing. BaseAEATestCase Objects class BaseAEATestCase ( ABC ) Base class for AEA test cases. set _ agent _ context @classmethod def set_agent_context ( cls , agent_name : str ) -> None Set the current agent context. unset _ agent _ context @classmethod def unset_agent_context ( cls ) -> None Unset the current agent context. set _ config @classmethod def set_config ( cls , dotted_path : str , value : Any , type_ : Optional [ str ] = None ) -> Result Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type_ : the type Returns : Result nested _ set _ config @classmethod def nested_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config. disable _ aea _ logging @classmethod def disable_aea_logging ( cls ) -> None Disable AEA logging of specific agent. Run from agent's directory. run _ cli _ command @classmethod def run_cli_command ( cls , * args : str , cwd : str = \".\" , ** kwargs : str ) -> Result Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. kwargs : other keyword arguments to click.CliRunner.invoke. Raises : AEATestingException : if command fails. Returns : Result start _ subprocess @classmethod def start_subprocess ( cls , * args : str , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args cwd : the current working directory Returns : subprocess object. start _ thread @classmethod def start_thread ( cls , target : Callable , ** kwargs : subprocess . Popen ) -> Thread Start python Thread. Arguments : target : target method. kwargs : thread keyword arguments Returns : thread create _ agents @classmethod def create_agents ( cls , * agents_names : str , is_local : bool = True , is_empty : bool = False ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. is_local : a flag for local folder add True by default. is_empty : optional boolean flag for skip adding default dependencies. fetch _ agent @classmethod def fetch_agent ( cls , public_id : str , agent_name : str , is_local : bool = True ) -> None Create agents in current working directory. Arguments : public_id : str public id agent_name : str agent name. is_local : a flag for local folder add True by default. difference _ to _ fetched _ agent @classmethod def difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agent_name : str agent name. Returns : list of files differing in the projects delete _ agents @classmethod def delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names. run _ agent @classmethod def run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object. run _ interaction @classmethod def run_interaction ( cls ) -> subprocess . Popen Run interaction as subprocess. Run from agent's directory. Returns : subprocess object. terminate _ agents @classmethod def terminate_agents ( cls , * subprocesses : subprocess . Popen , timeout : int = 20 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents timeout : the timeout for interruption is _ successfully _ terminated @classmethod def is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) -> bool Check if all subprocesses terminated successfully. initialize _ aea @classmethod def initialize_aea ( cls , author : str ) -> None Initialize AEA locally with author name. add _ item @classmethod def add_item ( cls , item_type : str , public_id : str , local : bool = True ) -> Result Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. local : a flag for local folder add True by default. Returns : Result remove _ item @classmethod def remove_item ( cls , item_type : str , public_id : str ) -> Result Remove an item from the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result scaffold _ item @classmethod def scaffold_item ( cls , item_type : str , name : str , skip_consistency_check : bool = False ) -> Result Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. skip_consistency_check : if True, skip consistency check. Returns : Result fingerprint _ item @classmethod def fingerprint_item ( cls , item_type : str , public_id : str ) -> Result Fingerprint an item for the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result eject _ item @classmethod def eject_item ( cls , item_type : str , public_id : str ) -> Result Eject an item in the agent in quiet mode (i.e. no interaction). Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None run _ install @classmethod def run_install ( cls ) -> Result Execute AEA CLI install command. Run from agent's directory. Returns : Result generate _ private _ key @classmethod def generate_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_file : Optional [ str ] = None , password : Optional [ str ] = None ) -> Result Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_file : the private key file. password : the password. Returns : Result add _ private _ key @classmethod def add_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE , connection : bool = False , password : Optional [ str ] = None ) -> Result Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. connection : whether or not the private key filepath is for a connection. password : the password to encrypt private keys. Returns : Result remove _ private _ key @classmethod def remove_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , connection : bool = False ) -> Result Remove private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. connection : whether or not the private key filepath is for a connection. Returns : Result replace _ private _ key _ in _ file @classmethod def replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file Raises : None : exception if file does not exist generate _ wealth @classmethod def generate_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> Result Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password. Returns : Result get _ wealth @classmethod def get_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output get _ address @classmethod def get_address ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get address with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output replace _ file _ content @classmethod def replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the destination file. Arguments : src : the source file. dest : the destination file. change _ directory @classmethod def change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory. send _ envelope _ to _ agent @classmethod def send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) -> None Send an envelope to an agent, using the stub connection. read _ envelope _ from _ agent @classmethod def read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection. missing _ from _ output @classmethod def missing_from_output ( cls , process : subprocess . Popen , strings : Sequence [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings. is _ running @classmethod def is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) -> bool Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete Returns : bool indicating status invoke @classmethod def invoke ( cls , * args : str ) -> Result Call the cli command. load _ agent _ config @classmethod def load_agent_config ( cls , agent_name : str ) -> AgentConfig Load agent configuration. setup _ class @classmethod def setup_class ( cls ) -> None Set up the test class. teardown _ class @classmethod def teardown_class ( cls ) -> None Teardown the test. AEATestCaseEmpty Objects class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project. setup _ class @classmethod def setup_class ( cls ) -> None Set up the test class. teardown _ class @classmethod def teardown_class ( cls ) -> None Teardown the test class. AEATestCaseEmptyFlaky Objects class AEATestCaseEmptyFlaky ( AEATestCaseEmpty ) Test case for a default AEA project. This test case will create a default AEA project. Use for flaky tests with the flaky decorator. setup _ class @classmethod def setup_class ( cls ) -> None Set up the test class. teardown _ class @classmethod def teardown_class ( cls ) -> None Teardown the test class. AEATestCaseMany Objects class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects. setup _ class @classmethod def setup_class ( cls ) -> None Set up the test class. teardown _ class @classmethod def teardown_class ( cls ) -> None Teardown the test class. AEATestCaseManyFlaky Objects class AEATestCaseManyFlaky ( AEATestCaseMany ) Test case for many AEA projects which are flaky. Use for flaky tests with the flaky decorator. setup _ class @classmethod def setup_class ( cls ) -> None Set up the test class. teardown _ class @classmethod def teardown_class ( cls ) -> None Teardown the test class. AEATestCase Objects class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory. setup _ class @classmethod def setup_class ( cls ) -> None Set up the test class. teardown _ class @classmethod def teardown_class ( cls ) -> None Teardown the test class.","title":"Test Cases"},{"location":"api/test_tools/test_cases/#aeatest_toolstest_cases","text":"This module contains test case classes based on pytest for AEA end-to-end testing.","title":"aea.test_tools.test_cases"},{"location":"api/test_tools/test_cases/#baseaeatestcase-objects","text":"class BaseAEATestCase ( ABC ) Base class for AEA test cases.","title":"BaseAEATestCase Objects"},{"location":"api/test_tools/test_cases/#set_agent_context","text":"@classmethod def set_agent_context ( cls , agent_name : str ) -> None Set the current agent context.","title":"set_agent_context"},{"location":"api/test_tools/test_cases/#unset_agent_context","text":"@classmethod def unset_agent_context ( cls ) -> None Unset the current agent context.","title":"unset_agent_context"},{"location":"api/test_tools/test_cases/#set_config","text":"@classmethod def set_config ( cls , dotted_path : str , value : Any , type_ : Optional [ str ] = None ) -> Result Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type_ : the type Returns : Result","title":"set_config"},{"location":"api/test_tools/test_cases/#nested_set_config","text":"@classmethod def nested_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config.","title":"nested_set_config"},{"location":"api/test_tools/test_cases/#disable_aea_logging","text":"@classmethod def disable_aea_logging ( cls ) -> None Disable AEA logging of specific agent. Run from agent's directory.","title":"disable_aea_logging"},{"location":"api/test_tools/test_cases/#run_cli_command","text":"@classmethod def run_cli_command ( cls , * args : str , cwd : str = \".\" , ** kwargs : str ) -> Result Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. kwargs : other keyword arguments to click.CliRunner.invoke. Raises : AEATestingException : if command fails. Returns : Result","title":"run_cli_command"},{"location":"api/test_tools/test_cases/#start_subprocess","text":"@classmethod def start_subprocess ( cls , * args : str , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args cwd : the current working directory Returns : subprocess object.","title":"start_subprocess"},{"location":"api/test_tools/test_cases/#start_thread","text":"@classmethod def start_thread ( cls , target : Callable , ** kwargs : subprocess . Popen ) -> Thread Start python Thread. Arguments : target : target method. kwargs : thread keyword arguments Returns : thread","title":"start_thread"},{"location":"api/test_tools/test_cases/#create_agents","text":"@classmethod def create_agents ( cls , * agents_names : str , is_local : bool = True , is_empty : bool = False ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. is_local : a flag for local folder add True by default. is_empty : optional boolean flag for skip adding default dependencies.","title":"create_agents"},{"location":"api/test_tools/test_cases/#fetch_agent","text":"@classmethod def fetch_agent ( cls , public_id : str , agent_name : str , is_local : bool = True ) -> None Create agents in current working directory. Arguments : public_id : str public id agent_name : str agent name. is_local : a flag for local folder add True by default.","title":"fetch_agent"},{"location":"api/test_tools/test_cases/#difference_to_fetched_agent","text":"@classmethod def difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agent_name : str agent name. Returns : list of files differing in the projects","title":"difference_to_fetched_agent"},{"location":"api/test_tools/test_cases/#delete_agents","text":"@classmethod def delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names.","title":"delete_agents"},{"location":"api/test_tools/test_cases/#run_agent","text":"@classmethod def run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object.","title":"run_agent"},{"location":"api/test_tools/test_cases/#run_interaction","text":"@classmethod def run_interaction ( cls ) -> subprocess . Popen Run interaction as subprocess. Run from agent's directory. Returns : subprocess object.","title":"run_interaction"},{"location":"api/test_tools/test_cases/#terminate_agents","text":"@classmethod def terminate_agents ( cls , * subprocesses : subprocess . Popen , timeout : int = 20 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents timeout : the timeout for interruption","title":"terminate_agents"},{"location":"api/test_tools/test_cases/#is_successfully_terminated","text":"@classmethod def is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) -> bool Check if all subprocesses terminated successfully.","title":"is_successfully_terminated"},{"location":"api/test_tools/test_cases/#initialize_aea","text":"@classmethod def initialize_aea ( cls , author : str ) -> None Initialize AEA locally with author name.","title":"initialize_aea"},{"location":"api/test_tools/test_cases/#add_item","text":"@classmethod def add_item ( cls , item_type : str , public_id : str , local : bool = True ) -> Result Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. local : a flag for local folder add True by default. Returns : Result","title":"add_item"},{"location":"api/test_tools/test_cases/#remove_item","text":"@classmethod def remove_item ( cls , item_type : str , public_id : str ) -> Result Remove an item from the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result","title":"remove_item"},{"location":"api/test_tools/test_cases/#scaffold_item","text":"@classmethod def scaffold_item ( cls , item_type : str , name : str , skip_consistency_check : bool = False ) -> Result Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. skip_consistency_check : if True, skip consistency check. Returns : Result","title":"scaffold_item"},{"location":"api/test_tools/test_cases/#fingerprint_item","text":"@classmethod def fingerprint_item ( cls , item_type : str , public_id : str ) -> Result Fingerprint an item for the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result","title":"fingerprint_item"},{"location":"api/test_tools/test_cases/#eject_item","text":"@classmethod def eject_item ( cls , item_type : str , public_id : str ) -> Result Eject an item in the agent in quiet mode (i.e. no interaction). Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None","title":"eject_item"},{"location":"api/test_tools/test_cases/#run_install","text":"@classmethod def run_install ( cls ) -> Result Execute AEA CLI install command. Run from agent's directory. Returns : Result","title":"run_install"},{"location":"api/test_tools/test_cases/#generate_private_key","text":"@classmethod def generate_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_file : Optional [ str ] = None , password : Optional [ str ] = None ) -> Result Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_file : the private key file. password : the password. Returns : Result","title":"generate_private_key"},{"location":"api/test_tools/test_cases/#add_private_key","text":"@classmethod def add_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE , connection : bool = False , password : Optional [ str ] = None ) -> Result Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. connection : whether or not the private key filepath is for a connection. password : the password to encrypt private keys. Returns : Result","title":"add_private_key"},{"location":"api/test_tools/test_cases/#remove_private_key","text":"@classmethod def remove_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , connection : bool = False ) -> Result Remove private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. connection : whether or not the private key filepath is for a connection. Returns : Result","title":"remove_private_key"},{"location":"api/test_tools/test_cases/#replace_private_key_in_file","text":"@classmethod def replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file Raises : None : exception if file does not exist","title":"replace_private_key_in_file"},{"location":"api/test_tools/test_cases/#generate_wealth","text":"@classmethod def generate_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> Result Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password. Returns : Result","title":"generate_wealth"},{"location":"api/test_tools/test_cases/#get_wealth","text":"@classmethod def get_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output","title":"get_wealth"},{"location":"api/test_tools/test_cases/#get_address","text":"@classmethod def get_address ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get address with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output","title":"get_address"},{"location":"api/test_tools/test_cases/#replace_file_content","text":"@classmethod def replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the destination file. Arguments : src : the source file. dest : the destination file.","title":"replace_file_content"},{"location":"api/test_tools/test_cases/#change_directory","text":"@classmethod def change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory.","title":"change_directory"},{"location":"api/test_tools/test_cases/#send_envelope_to_agent","text":"@classmethod def send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) -> None Send an envelope to an agent, using the stub connection.","title":"send_envelope_to_agent"},{"location":"api/test_tools/test_cases/#read_envelope_from_agent","text":"@classmethod def read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection.","title":"read_envelope_from_agent"},{"location":"api/test_tools/test_cases/#missing_from_output","text":"@classmethod def missing_from_output ( cls , process : subprocess . Popen , strings : Sequence [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings.","title":"missing_from_output"},{"location":"api/test_tools/test_cases/#is_running","text":"@classmethod def is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) -> bool Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete Returns : bool indicating status","title":"is_running"},{"location":"api/test_tools/test_cases/#invoke","text":"@classmethod def invoke ( cls , * args : str ) -> Result Call the cli command.","title":"invoke"},{"location":"api/test_tools/test_cases/#load_agent_config","text":"@classmethod def load_agent_config ( cls , agent_name : str ) -> AgentConfig Load agent configuration.","title":"load_agent_config"},{"location":"api/test_tools/test_cases/#setup_class","text":"@classmethod def setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"api/test_tools/test_cases/#teardown_class","text":"@classmethod def teardown_class ( cls ) -> None Teardown the test.","title":"teardown_class"},{"location":"api/test_tools/test_cases/#aeatestcaseempty-objects","text":"class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project.","title":"AEATestCaseEmpty Objects"},{"location":"api/test_tools/test_cases/#setup_class_1","text":"@classmethod def setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"api/test_tools/test_cases/#teardown_class_1","text":"@classmethod def teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"api/test_tools/test_cases/#aeatestcaseemptyflaky-objects","text":"class AEATestCaseEmptyFlaky ( AEATestCaseEmpty ) Test case for a default AEA project. This test case will create a default AEA project. Use for flaky tests with the flaky decorator.","title":"AEATestCaseEmptyFlaky Objects"},{"location":"api/test_tools/test_cases/#setup_class_2","text":"@classmethod def setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"api/test_tools/test_cases/#teardown_class_2","text":"@classmethod def teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"api/test_tools/test_cases/#aeatestcasemany-objects","text":"class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects.","title":"AEATestCaseMany Objects"},{"location":"api/test_tools/test_cases/#setup_class_3","text":"@classmethod def setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"api/test_tools/test_cases/#teardown_class_3","text":"@classmethod def teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"api/test_tools/test_cases/#aeatestcasemanyflaky-objects","text":"class AEATestCaseManyFlaky ( AEATestCaseMany ) Test case for many AEA projects which are flaky. Use for flaky tests with the flaky decorator.","title":"AEATestCaseManyFlaky Objects"},{"location":"api/test_tools/test_cases/#setup_class_4","text":"@classmethod def setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"api/test_tools/test_cases/#teardown_class_4","text":"@classmethod def teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"api/test_tools/test_cases/#aeatestcase-objects","text":"class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory.","title":"AEATestCase Objects"},{"location":"api/test_tools/test_cases/#setup_class_5","text":"@classmethod def setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"api/test_tools/test_cases/#teardown_class_5","text":"@classmethod def teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"api/test_tools/test_contract/","text":"aea.test _ tools.test _ contract This module contains test case classes based on pytest for AEA contract testing. BaseContractTestCase Objects class BaseContractTestCase ( ABC ) A class to test a contract. contract @property def contract () -> Contract Get the contract. setup @classmethod def setup ( cls , ** kwargs : Any ) -> None Set up the contract test case. finish _ contract _ deployment @classmethod @abstractmethod def finish_contract_deployment ( cls ) -> str Finish deploying contract. Returns : contract address refill _ from _ faucet @staticmethod def refill_from_faucet ( ledger_api : LedgerApi , faucet_api : FaucetApi , address : str ) -> None Refill from faucet. sign _ send _ confirm _ receipt _ multisig _ transaction @staticmethod def sign_send_confirm_receipt_multisig_transaction ( tx : JSONLike , ledger_api : LedgerApi , cryptos : List [ Crypto ], sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api cryptos : Cryptos to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt sign _ send _ confirm _ receipt _ transaction @classmethod def sign_send_confirm_receipt_transaction ( cls , tx : JSONLike , ledger_api : LedgerApi , crypto : Crypto , sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api crypto : Crypto to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt","title":"Test Contract"},{"location":"api/test_tools/test_contract/#aeatest_toolstest_contract","text":"This module contains test case classes based on pytest for AEA contract testing.","title":"aea.test_tools.test_contract"},{"location":"api/test_tools/test_contract/#basecontracttestcase-objects","text":"class BaseContractTestCase ( ABC ) A class to test a contract.","title":"BaseContractTestCase Objects"},{"location":"api/test_tools/test_contract/#contract","text":"@property def contract () -> Contract Get the contract.","title":"contract"},{"location":"api/test_tools/test_contract/#setup","text":"@classmethod def setup ( cls , ** kwargs : Any ) -> None Set up the contract test case.","title":"setup"},{"location":"api/test_tools/test_contract/#finish_contract_deployment","text":"@classmethod @abstractmethod def finish_contract_deployment ( cls ) -> str Finish deploying contract. Returns : contract address","title":"finish_contract_deployment"},{"location":"api/test_tools/test_contract/#refill_from_faucet","text":"@staticmethod def refill_from_faucet ( ledger_api : LedgerApi , faucet_api : FaucetApi , address : str ) -> None Refill from faucet.","title":"refill_from_faucet"},{"location":"api/test_tools/test_contract/#sign_send_confirm_receipt_multisig_transaction","text":"@staticmethod def sign_send_confirm_receipt_multisig_transaction ( tx : JSONLike , ledger_api : LedgerApi , cryptos : List [ Crypto ], sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api cryptos : Cryptos to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt","title":"sign_send_confirm_receipt_multisig_transaction"},{"location":"api/test_tools/test_contract/#sign_send_confirm_receipt_transaction","text":"@classmethod def sign_send_confirm_receipt_transaction ( cls , tx : JSONLike , ledger_api : LedgerApi , crypto : Crypto , sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api crypto : Crypto to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt","title":"sign_send_confirm_receipt_transaction"},{"location":"api/test_tools/test_skill/","text":"aea.test _ tools.test _ skill This module contains test case classes based on pytest for AEA skill testing. BaseSkillTestCase Objects class BaseSkillTestCase () A class to test a skill. skill @property def skill () -> Skill Get the skill. get _ quantity _ in _ outbox def get_quantity_in_outbox () -> int Get the quantity of envelopes in the outbox. get _ message _ from _ outbox def get_message_from_outbox () -> Optional [ Message ] Get message from outbox. drop _ messages _ from _ outbox def drop_messages_from_outbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from outbox. get _ quantity _ in _ decision _ maker _ inbox def get_quantity_in_decision_maker_inbox () -> int Get the quantity of messages in the decision maker inbox. get _ message _ from _ decision _ maker _ inbox def get_message_from_decision_maker_inbox () -> Optional [ Message ] Get message from decision maker inbox. drop _ messages _ from _ decision _ maker _ inbox def drop_messages_from_decision_maker_inbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from decision maker inbox. assert _ quantity _ in _ outbox def assert_quantity_in_outbox ( expected_quantity : int ) -> None Assert the quantity of messages in the outbox. assert _ quantity _ in _ decision _ making _ queue def assert_quantity_in_decision_making_queue ( expected_quantity : int ) -> None Assert the quantity of messages in the decision maker queue. message _ has _ attributes","title":"Test Skill"},{"location":"api/test_tools/test_skill/#aeatest_toolstest_skill","text":"This module contains test case classes based on pytest for AEA skill testing.","title":"aea.test_tools.test_skill"},{"location":"api/test_tools/test_skill/#baseskilltestcase-objects","text":"class BaseSkillTestCase () A class to test a skill.","title":"BaseSkillTestCase Objects"},{"location":"api/test_tools/test_skill/#skill","text":"@property def skill () -> Skill Get the skill.","title":"skill"},{"location":"api/test_tools/test_skill/#get_quantity_in_outbox","text":"def get_quantity_in_outbox () -> int Get the quantity of envelopes in the outbox.","title":"get_quantity_in_outbox"},{"location":"api/test_tools/test_skill/#get_message_from_outbox","text":"def get_message_from_outbox () -> Optional [ Message ] Get message from outbox.","title":"get_message_from_outbox"},{"location":"api/test_tools/test_skill/#drop_messages_from_outbox","text":"def drop_messages_from_outbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from outbox.","title":"drop_messages_from_outbox"},{"location":"api/test_tools/test_skill/#get_quantity_in_decision_maker_inbox","text":"def get_quantity_in_decision_maker_inbox () -> int Get the quantity of messages in the decision maker inbox.","title":"get_quantity_in_decision_maker_inbox"},{"location":"api/test_tools/test_skill/#get_message_from_decision_maker_inbox","text":"def get_message_from_decision_maker_inbox () -> Optional [ Message ] Get message from decision maker inbox.","title":"get_message_from_decision_maker_inbox"},{"location":"api/test_tools/test_skill/#drop_messages_from_decision_maker_inbox","text":"def drop_messages_from_decision_maker_inbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from decision maker inbox.","title":"drop_messages_from_decision_maker_inbox"},{"location":"api/test_tools/test_skill/#assert_quantity_in_outbox","text":"def assert_quantity_in_outbox ( expected_quantity : int ) -> None Assert the quantity of messages in the outbox.","title":"assert_quantity_in_outbox"},{"location":"api/test_tools/test_skill/#assert_quantity_in_decision_making_queue","text":"def assert_quantity_in_decision_making_queue ( expected_quantity : int ) -> None Assert the quantity of messages in the decision maker queue.","title":"assert_quantity_in_decision_making_queue"},{"location":"api/test_tools/test_skill/#message_has_attributes","text":"","title":"message_has_attributes"}]}